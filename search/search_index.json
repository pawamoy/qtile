{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"|logo| A full-featured, hackable tiling window manager written and configured in Python |website| |pypi| |ci| |rtd| |license| |black| |coverage| Features Simple, small and extensible. It's easy to write your own layouts, widgets and commands. Configured in Python. Runs as an X11 WM or a Wayland compositor. Command shell that allows all aspects of Qtile to be managed and inspected. Complete remote scriptability - write scripts to set up workspaces, manipulate windows, update status bar widgets and more. Qtile's remote scriptability makes it one of the most thoroughly unit-tested window managers around. Community Qtile is supported by a dedicated group of users. If you need any help, please don't hesitate to fire off an email to our mailing list or join us on IRC. You can also ask questions on the discussions board. :Mailing List: https://groups.google.com/group/qtile-dev :Q&A: https://github.com/qtile/qtile/discussions/categories/q-a :IRC: irc://irc.oftc.net:6667/qtile :Discord: https://discord.gg/ehh233wCrC (Bridged with IRC) Example code Check out the qtile-examples _ repo which contains examples of users' configurations, scripts and other useful links. .. _ qtile-examples : https://github.com/qtile/qtile-examples Contributing Please report any suggestions, feature requests, bug reports, or annoyances to the GitHub issue tracker . There are also a few tips & tricks , and guidelines _ for contributing in the documentation. Please also consider submitting useful scripts etc. to the qtile-examples repo (see above). .. issue tracker : https://github.com/qtile/qtile/issues .. tips & tricks : https://docs.qtile.org/en/latest/manual/hacking.html .. _ guidelines : https://docs.qtile.org/en/latest/manual/contributing.html .. |logo| image:: https://raw.githubusercontent.com/qtile/qtile/master/logo.png :alt: Logo :target: https://www.qtile.org .. |website| image:: https://img.shields.io/badge/website-qtile.org-blue.svg :alt: Website :target: https://www.qtile.org .. |pypi| image:: https://img.shields.io/pypi/v/qtile.svg :alt: PyPI :target: https://pypi.org/project/qtile/ .. |ci| image:: https://github.com/qtile/qtile/workflows/ci/badge.svg?branch=master :alt: CI status :target: https://github.com/qtile/qtile/actions .. |rtd| image:: https://readthedocs.org/projects/qtile/badge/?version=latest :alt: Read the Docs :target: https://docs.qtile.org/en/latest/ .. |license| image:: https://img.shields.io/github/license/qtile/qtile.svg :alt: License :target: https://github.com/qtile/qtile/blob/master/LICENSE .. |black| image:: https://img.shields.io/badge/code%20style-black-000000.svg :alt: Codestyle :target: https://github.com/psf/black .. |coverage| image:: https://coveralls.io/repos/github/qtile/qtile/badge.svg :alt: Coverage :target: https://coveralls.io/github/qtile/qtile Maintainers | @tych0 GPG: 3CCA B226 289D E016 0C61 BDB4 18D1 8F1B C464 DCA3 | @ramnes GPG: 99CC A84E 2C8C 74F3 2E12 AD53 8C17 0207 0803 487A | @m-col GPG: 35D9 2E7C C735 7A81 173E A1C9 74F9 FDD2 0984 FBEC | @flacjacket GPG: 58B5 F350 8339 BFE5 CA93 AC9F 439D 9701 E7EA C588 | @elParaguayo _ GPG: A6BA A1E1 7D26 64AD B97B 2C6F 58A9 AA7C 8672 7DF7 .. @tych0 : https://github.com/tych0 .. @ramnes : https://github.com/ramnes .. @m-col : https://github.com/m-col .. @flacjacket : https://github.com/flacjacket .. _ @elParaguayo : https://github.com/elparaguayo","title":"Overview"},{"location":"#features","text":"Simple, small and extensible. It's easy to write your own layouts, widgets and commands. Configured in Python. Runs as an X11 WM or a Wayland compositor. Command shell that allows all aspects of Qtile to be managed and inspected. Complete remote scriptability - write scripts to set up workspaces, manipulate windows, update status bar widgets and more. Qtile's remote scriptability makes it one of the most thoroughly unit-tested window managers around.","title":"Features"},{"location":"#community","text":"Qtile is supported by a dedicated group of users. If you need any help, please don't hesitate to fire off an email to our mailing list or join us on IRC. You can also ask questions on the discussions board. :Mailing List: https://groups.google.com/group/qtile-dev :Q&A: https://github.com/qtile/qtile/discussions/categories/q-a :IRC: irc://irc.oftc.net:6667/qtile :Discord: https://discord.gg/ehh233wCrC (Bridged with IRC)","title":"Community"},{"location":"#example-code","text":"Check out the qtile-examples _ repo which contains examples of users' configurations, scripts and other useful links. .. _ qtile-examples : https://github.com/qtile/qtile-examples","title":"Example code"},{"location":"#contributing","text":"Please report any suggestions, feature requests, bug reports, or annoyances to the GitHub issue tracker . There are also a few tips & tricks , and guidelines _ for contributing in the documentation. Please also consider submitting useful scripts etc. to the qtile-examples repo (see above). .. issue tracker : https://github.com/qtile/qtile/issues .. tips & tricks : https://docs.qtile.org/en/latest/manual/hacking.html .. _ guidelines : https://docs.qtile.org/en/latest/manual/contributing.html .. |logo| image:: https://raw.githubusercontent.com/qtile/qtile/master/logo.png :alt: Logo :target: https://www.qtile.org .. |website| image:: https://img.shields.io/badge/website-qtile.org-blue.svg :alt: Website :target: https://www.qtile.org .. |pypi| image:: https://img.shields.io/pypi/v/qtile.svg :alt: PyPI :target: https://pypi.org/project/qtile/ .. |ci| image:: https://github.com/qtile/qtile/workflows/ci/badge.svg?branch=master :alt: CI status :target: https://github.com/qtile/qtile/actions .. |rtd| image:: https://readthedocs.org/projects/qtile/badge/?version=latest :alt: Read the Docs :target: https://docs.qtile.org/en/latest/ .. |license| image:: https://img.shields.io/github/license/qtile/qtile.svg :alt: License :target: https://github.com/qtile/qtile/blob/master/LICENSE .. |black| image:: https://img.shields.io/badge/code%20style-black-000000.svg :alt: Codestyle :target: https://github.com/psf/black .. |coverage| image:: https://coveralls.io/repos/github/qtile/qtile/badge.svg :alt: Coverage :target: https://coveralls.io/github/qtile/qtile","title":"Contributing"},{"location":"#maintainers","text":"| @tych0 GPG: 3CCA B226 289D E016 0C61 BDB4 18D1 8F1B C464 DCA3 | @ramnes GPG: 99CC A84E 2C8C 74F3 2E12 AD53 8C17 0207 0803 487A | @m-col GPG: 35D9 2E7C C735 7A81 173E A1C9 74F9 FDD2 0984 FBEC | @flacjacket GPG: 58B5 F350 8339 BFE5 CA93 AC9F 439D 9701 E7EA C588 | @elParaguayo _ GPG: A6BA A1E1 7D26 64AD B97B 2C6F 58A9 AA7C 8672 7DF7 .. @tych0 : https://github.com/tych0 .. @ramnes : https://github.com/ramnes .. @m-col : https://github.com/m-col .. @flacjacket : https://github.com/flacjacket .. _ @elParaguayo : https://github.com/elparaguayo","title":"Maintainers"},{"location":"changelog/","text":"Qtile x.xx.x, released XXXX-XX-XX: !!! config breakage/changes !!! - The cmd_ prefix has been dropped from all commands (this means command names are common when accessed via the command interface or internal python objects). - Custom widgets should now expose command methods with the @expose_command decorator (available via from libqtile.command.base import expose_command ). - Some commands have been renamed (in addition to dropping the 'cmd_' prefix): hints -> get_hints groups -> get_groups screens -> get_screens - Layouts need to rename some methods: - add to add_client - cmd_next to next - cmd_previous to previous - Layouts or widgets that redefine the commands property need to update the signature: @expose_command() def commands(self) -> list[str]: - Window.getsize has been renamed Window.get_size (i.e. merged with the get_size command). - Window.getposition has been renamed Window.get_position (i.e. merged with the get_position command). - The StockTicker widget function option is being deprecated: rename it to func . * features - Add ability to set icon size in LaunchBar widget. - Add 'warp_pointer' option to Drag that when set will warp the pointer to the bottom right of the window when dragging begins. - Add ability to disable group toggling in GroupBox widget * bugfixes - Fix bug where Window.center() centers window on the wrong screen when using multiple monitors. Qtile 0.22.0, released 2022-09-22: !!! Config breakage !!! - lazy.qtile.display_kb() no longer receives any arguments. If you passed it any arguments (which were ignored previously), remove them. - If you have a custom startup Python script that you use instead of qtile start and run init_log manually, the signature has changed. Please check the source for the updated arguments. - KeyChord 's signature has changed. mode is now a boolean to indicate whether the mode should persist. The name parameter should be used to name the chord (e.g. for the Chord widget). * features - Add ability to draw borders and add margins to the Max layout. - The default XWayland cursor is now set at startup to left_ptr, so an xsetroot call is not needed to avoid the ugly X cursor. - Wayland: primary clipboard should now behave same way as with X after selecting something it should be copied into clipboard - Add resume hook when computer resumes from sleep/suspend/hibernate. - Add text_only option for LaunchBar widget. - Add force_update command to ThreadPoolText widgets to simplify updating from key bindings - Add scrolling ability to _TextBox -based widgets. - Add player controls (via mouse callbacks) to Mpris2 widget. - Wayland: input inhibitor protocol support added (pywayland>=0.4.14 & pywlroots>=0.15.19) - Add commands to control Pomodoro widget. - Add icon theme support to TaskList widget (available on X11 and Wayland backends). - Wayland: Use qtile cmd-obj -o core -f get_inputs to get input device identifiers for configuring inputs. Also input configs will be updated by config reloads (pywlroots>=0.15.21) * bugfixes - Widgets that are incompatible with a backend (e.g. Systray on Wayland) will no longer show as a ConfigError in the bar. Instead the widget is silently removed from the bar and a message included in the logs. - Reduce error messages in StatusNotifier widget from certain apps. - Reset colours in Chord widget - Prevent crash in LaunchBar when using SVG icons - Improve scrolling in Mpris2 widget (options to repeat scrolling etc.) Qtile 0.21.0, released 2022-03-23: * features - Add lazy.window.center() command to center a floating window on the screen. - Wayland: added power-output-management-v1 protocol support, added idle protocol, added idle inhibit protocol - Add MonadThreeCol layout based on XMonad's ThreeColumns. - Add lazy.screen.set_wallpaper command. - Added ability to scale the battery icon's size - Add Spiral layout - Add toggle argument to Window.togroup with the same functionality as in Group.toscreen . - Added margin_on_single and border_on_single to Bsp layout * bugfixes - Fix Systray crash on reconfigure_screens . - Fix bug where widgets can't be mirrored in same bar. - Fix various issues with setting fullscreen windows floating and vice versa. - Fix a bug where a .when() check for lazy functions errors out when matching on focused windows when none is focused. By default we do not match on focused windows, to change this set if_no_focused to True. - Widget with duplicate names will be automatically renamed by appending numeric suffixes - Fix resizing of wallpaper when screen scale changes (X11) - Two small bugfixes for StatusNotifier - better handling of Ayatana indicators - Fix bug where StatusNotifierItem crashes due to invalid object paths (e.g. Zoom) Qtile 0.20.0, released 2022-01-24: * features - Add place_right option in the TreeTab layout to place the tab panel on the right side - X11: Add support for _NET_DESKTOP_VIEWPORT. E.g. can be used by rofi to map on current output. - Wayland: Bump wlroots version. 0.15.x wlroots and 0.15.2+ pywlroots are required. - Add XWayland support to the Wayland backend. XWayland will start up as needed, if it is installed. * bugfixes - Remove non-commandable windows from IPC. Fixes bug where IPC would fail when trying to get info on all windows but Systray has icons (which are non-commandable _Window s.) - Fix bug where bars were not reconfigured correctly when screen layout changes. - Fix a Wayland bug where layer-shell surface like dunst would freeze up and stop updating. - Change timing of screens_reconfigured hook. Will now be called ONLY if cmd_reconfigure_screens has been called and completed. - Fix order of icons in Systray widget when restarting/reloading config. - Fix rounding error in PulseVolume widget's reported volume. - Fix bug where Volume widget did not load images where theme_path had been set in widget_defaults . - Remove ability to have multiple Systray widgets. Additional Systray widgets will result in a ConfigError. - Release notification name from dbus when finalising Notify widget. This allows other notification managers to request the name. - Fix bug where Battery widget did not retrieve background from widget_defaults . - Fix bug where widgets in a WidgetBox are rendered on top of bar borders. Qtile 0.19.0, released 2021-12-22: * features - Add ability to draw borders to the Bar. Can customise size and colour per edge. - Add StatusNotifier widget implementing the StatusNotifierItem specification. NB Widget does not provide context menus. - Add total bandwidth format value to the Net widget. - Scratchpad groups could be defined as single so that only one of the scratchpad in the group is visible at a given time. - All scratchpads in a Scratchpad group can be hidden with hide_all() function. - For saving states of scratchpads during restart, we use wids instead of pids. - Scratchpads can now be defined with an optional matcher to match with window properties. - Qtile.cmd_reload_config is added for reloading the config without completely restarting. - Window.cmd_togroup's argument groupName should be changed to group_name . For the time being a log warning is in place and a migration is added. In the future groupName will fail. - Add min/max_ratio to Tile layout and fix bug where windows can extend offscreen. - Add ability for widget mouse_callbacks to take lazy calls (similar to keybindings) - Add aliases to lazy.spawncmd() which takes a dictionary mapping convenient aliases to full command lines. - Add a new 'prefix' option to the net widget to display speeds with a static unit (e.g. MB). - lazy.group.toscreen() now does not toggle groups by default. To get this behaviour back, use lazy.group.toscreen(toggle=True) - Tile layout has new margin_on_single and border_on_single option to specify whether to draw margin and border when there is only one window. - Thermal zone widget. - Allow TextBox-based widgets to display in vertical bars. - Added a focused attribute to lazy.function.when which can be used to Match on focused windows. - Allow to update Image widget with update() function by giving a new path. * bugfixes - Windows are now properly re-ordered in the layouts when toggled on and off fullscreen Qtile 0.18.1, released 2021-09-16: * features - All layouts will accept a list of colors for border_* options with which they will draw multiple borders on the appropriate windows. Qtile 0.18.0, released 2021-07-04: !!! Config breakage !!! - The qtile entry point doesn't run qtile start by default anymore - New optional dependency for dbus related features: dbus-next. Replaces previous reliance on dbus/Glib and allows qtile to use async dbus calls within asyncio's eventloop. - widget.BatteryIcon no longer has a fallback text mode; use widget.Battery instead - MonadX layout key new_at_current is deprecated, use new_client_position. - libqtile.window has been moved to libqtile.backend.x11.window ; a migration has been added for this. !!! deprecation warning !!! - 'main' config functions, deprecated in 0.16.1, will no longer be executed. !!! Notice for packagers - new dependencies !!! - Tests now require the 'dbus-next' python module plus 'dbus-launch' and 'notify-send' applications * features - added transparency in x11 and wayland backends - added measure_mem and measure_swap attributes to memory widget to allow user to choose measurement units. - memory widget can now be displayed with decimal values - new \"qtile migrate\" command, which will attempt to upgrade previous configs to the current version in the case of qtile API breaks. - A new reconfigure_screens config setting. When True (default) it hooks Qtile.reconfigure_screens to the screen_change hook, reconfiguring qtile's screens in response to randr events. This removes the need to restart qtile when adding/removing external monitors. - improved key chord / sequence functionality. Leaving a chord with mode set brings you to a named mode you activated before, see #2264. A new command, lazy.ungrab_all_chords , was introduced to return to the root bindings. The enter_chord hook is now always called with a string argument. The third argument to KeyChord was renamed from submaping to submapping (typo fix). - added new argument for CheckUpdates widget: custom_command_modify which allows user to modify the the line count of the output of custom_command with a lambda function (i.e. lambda x: x-3 ). Argument defaults to lambda x: x and is overridden by distro argument's internal lambda. - added new argument for the WindowName, WindowTabs and Tasklist widgets: parse_text which allows users to define a function that takes a window name as an input, modify it in some way (e.g. str.replace(), str.upper() or regex) and show that modification on screen. - A Wayland backend has been added which can be used by calling qtile start -b wayland directly in your TTY. It requires the latest releases of wlroots, python-xkbcommon, pywayland and pywlroots. It is expected to be unstable so please let us know if you find any bugs! - The 'focus argument to Click and Drag` objects in your config are no longer necessary (and are ignored). Qtile 0.17.0, released 2021-02-13: !!! Python version breakage !!! - Python 3.5 and 3.6 are no longer supported !!! Config breakage !!! - Pacman widget has been removed. Use CheckUpdates instead. - Mpris widget has been removed. Use Mpris2 instead. - property \"masterWindows\" of Tile layout renamed to master_length - Match objects now only allow one string argument for their wm name/class/etc. properties. to update your config, do e.g. Group('www', spawn='firefox', layout='xmonad', - matches=[Match(wm_class=['Firefox', 'google-chrome', 'Google-chrome'])]), + matches=[Match(wm_class='Firefox'), Match(wm_class='google-chrome'), Match(wm_class='Google-chrome')]), - properties wname, wmclass and role of Slice-layout replaced by Match- type property \"match\" - rules specified in layout.Floating 's float_rules are now evaluated with AND-semantics instead of OR-semantics, i.e. if you specify 2 different property rules, both have to match - check the new float_rules for floating_layout in the default config and extend your own rules appropriately: some non-configurable auto-floating rules were made explicit and added to the default config - using dict s for layout.Floating 's float_rules is now deprecated, please use config.Match objects instead - no_reposition_match in layout.Floating has been removed; use the list of config.Match -objects no_reposition_rules instead - Command line has been modernized to a single entry point, the qtile binary. Translations are below: qtile -> qtile start qtile-cmd -> qtile cmd-obj qtile-run -> qtile run-cmd qtile-top -> qtile top qshell -> qtile shell iqshell and dqtile-cmd are no longer distributed with the package, as they were either user or developer scripts. Both are still available in the qtile repo in /scripts. Running `qtile` without arguments will continue to work for the forseeable future, but will be eventually deprecated. qtile prints a warning when run in this configuration. - Qtile.cmd_focus_by_click is no longer an available command. - Qtile.cmd_get_info is no longer an available command. - libqtile.command_* has been deprecated, it has been moved to libqtile.command.* - libqtile.widget.base.ThreadedPollText has been removed; out of tree widgets can use ThreadPoolText in the same package instead. - the YahooWeather widget was removed since Yahoo retired their free tier of the weather API - Deprecated hook `window_name_change` got removed, use `client_name_updated` instead. - show_state attribute from WindowName widget has been removed. Use format attribute instead. show_state = True -> format = '{state}{name}' show_state = False -> format = '{name}' - mouse_callbacks no longer receives the qtile object as an argument (they receive no arguments); import it via `from libqtile import qtile` instead. * features - new WidgetBox widget - new restart and shutdown hooks - rules specified in `layout.Floating`'s `float_rules` are now evaluated with AND-semantics, allowing for more complex and specific rules - Python 3.9 support - switch to Github Actions for CI - Columns layout has new `margin_on_single` option to specify margin size when there is only one window (default -1: use `margin` option). - new OpenWeather widget to replace YahooWeather - new format attribute for WindowName widget - new max_chars attribute for WindowName widget - libqtile now exports type information - add a new `qtile check` subcommand, which will check qtile configs for various things: - validates configs against the newly exported type information if mypy is present in the environment - validates that qtile can import the config file (e.g. that syntax is correct, ends in a .py extension, etc.) - validates Key and Mouse mod/keysym arguments are ok. - Columns layout now enables column swapping by using swap_column_left and swap_column_right !!! warning !!! - When (re)starting, Qtile passes its state to the new process in a file now, where previously it passed state directly as a string. This fixes a bug where some character encodings (i.e. in group names) were getting messed up in the conversion to/from said string. This change will cause issues if you update Qtile then restart it, causing the running old version to pass state in the previous format to the new process which recognises the new. Qtile 0.16.1, released 2020-08-11: !!! Config breakage !!! - Hooks 'addgroup', 'delgroup' and 'screen_change' will no longer receive the qtile object as an argument. It can be accessed directly at libqtile.qtile. !!! deprecation warning !!! - defining a main function in your config is deprecated. You should use @hook.subscribe.startup_complete instead. If you need access to the qtile object, import it from libqtile directly. * bugfixes - include tests in the release for distros to consume - don't resize 0th screen incorrectly on root ConfigureNotify - expose qtile object as libqtile.qtile (note that we still consider anything not prefixed with cmd_ to be a private API) - fix transparent borders - MonadTall, MonadWide, and TreeTab now work with Slice Qtile 0.16.0, released 2020-07-20: !!! Config breakage !!! - Imports from libqtile.widget are now made through a function proxy to avoid the side effects of importing all widgets at once. If you subclass a widget in your config, import it from its own module. e.g. from libqtile.widget.pomodoro import Pomodoro * features - added guess_terminal in utils - added keybinding cheet sheet image generator - custom keyboardlayout display - added native support for key chords - validate config before restart and refuse to restart with a bad config - added a bunch of type annotations to config objects (more to come) * bugfixes - major focus rework; Java-based IDEs such as PyCharm, NetBrains, etc. now focus correctly - fix a bug where spotify (or any window with focus-to=parent) was closed, nothing would be focused and no hotkeys would work - support windows unsetting the input hint - respects window's/user's location setting if present (WM_SIZE_HINTS) - fixed YahooWeather widget for new API - fix a bug where _NET_WM_DESKTOPS wasn't correctly updated when switching screens in some cases - fix a crash in the BSP layout - fix a stacktrace when unknown keysyms are encounted - make qtile --version output more sane - fix a rendering issue with special characters in window names - keyboard widget no longer re-sets the keyboard settings every second - fix qtile-top with the new IPC model - Image widget respects its background setting now - correctly re-draw non-focused screens on qtile restart - fix a crash when decoding images - fix the .when() constraint for lazy objects Qtile 0.15.1, released 2020-04-14 * bugfixes - fix qtile reload (it was crashing) Qtile 0.15.0, released 2020-04-12: !!! Config breakage !!! - removed the mpd widget, which depended on python-mpd. - the Clock widget now requires pytz to handle timezones that are passed as string - libqtile.command.Client does not exist anymore and has been replaced by libqtile.command_client.CommandClient !!! deprecation warning !!! - libqtile.command.lazy is deprecated in favor of libqtile.lazy.lazy * features - Python 3.8 support - wallpaper and wallpaper_mode for screens - bars can now have margins - lazy.toscreen called twice will now toggle the groups (optional with the toggle parameter) - lazy.window.togroup now has switch_group parameter to follow the window to the group it is sent to - qtile now copies the default config if the config file does not exist - all widgets now use Pango markup by default - add an fmt option for all textbox widgets - new PulseVolume widget for controlling PulseAudio - new QuickExit widget, mainly for the default config - new non-graph CPU widget - KeyboardLayout widget: new options parameter - CheckUpdates widget: support ArchLinux yay - GroupBox widget: new block_highlight_text_color parameter - Mpd2 widget: new color_progress parameter - Maildir widget can now display the inbox grand total - the Net widget can now use bits as unit - Spacer widget: new background_color parameter - More consistent resize behavior in Columns layout - various improvements of the default config - large documentation update and improvements (e.g. widget dependencies) * bugfixes - qtile binary: don't fail if we can't set the locale - don't print help if qtile-cmd function returns nothing - Monad layout: fix margins when flipped Qtile 0.14.2, released 2019-06-19: * bugfixes - previous release still exhibited same issues with package data, really fix it this time Qtile 0.14.1, released 2019-06-19: * bugfixes - properly include png files in the package data to install included icons Qtile 0.14.0, released 2019-06-19: !!! Python version breakage !!! - Python 2 is no longer supported - Python 3.4 and older is no longer supported !!! Config breakage !!! - Many internal things were renamed from camel case to snake case. If your config uses main(), or any lazy.function() invocations that interact directly with the qtile object, you may need to forward port them. Also note that we do not consider the qtile object to be a stable api, so you will need to continue forward porting these things for future refactorings (for wayland, etc.). A better approach may be to add an upstream API for what you want to do ;) - Maildir's subFolder and maildirPath changed to maildir_path and sub_folder. - the graph widget requires the psutil library to be installed * features - add custom change_command to backlight widget - add CommandSet extension to list available commands - simplify battery monitoring widget interface and add freebsd compatible battery widget implementation - track last known mouse coordinates on the qtile manager - allow configuration of warping behavior in columns layout * bugfixes - with cursor warp enabled, the cursor is warped on screen change - fix stepping groups to skip the scratch pad group - fix stack layout to properly shuffle - silence errors when unmapping windows Qtile 0.13.0, released 2018-12-23: !!! deprecation warning !!! - wmii layout is deprecated in terms of columns layout, which has the same behavior with different defaults, see the wmii definition for more details * features - add svg handling for images - allow addgroup command to set the layout - add command to get current log level - allow groupbox to hide unused groups - add caps lock indicator widget - add custom_command to check_update widget * bugfixes - better shutdown handling - fix clientlist current client tracking - fix typo in up command on ratiotile layout - various fixes to check_update widget - fix 0 case for resize screen Qtile 0.12.0, released 2018-07-20: !!! Config breakage !!! - Tile layout commands up/down/shuffle_up/shuffle_down changed to be more consistent with other layouts - move qcmd to qtile-cmd because of conflict with renameutils, move dqcmd to dqtile-cmd for symmetry * features - add add_after_last option to Tile layout to add windows to the end of the list. - add new formatting options to TaskList - allow Volume to open app on right click * bugfixes - fix floating of file transfer windows and java drop-downs - fix exception when calling cmd_next and cmd_previous on layout without windows - fix caps lock affected behaviour of key bindings - re-create cache dir if it is deleted while qtile is running - fix CheckUpdates widget color when no updates - handle cases where BAT_DIR does not exist - fix the wallpaper widget when using wallpaper_command - fix Tile layout order to not reverse on reset - fix calling focus_previous/next with no windows - fix floating bug is BSP layout Qtile 0.11.1, released 2018-03-01: * bug fix - fixed pip install of qtile Qtile 0.11.0, released 2018-02-28: !!! Completely changed extension configuration, see the documentation !!! !!! extention subpackage renamed to extension !!! !!! extentions configuration variable changed to extension_defaults !!! * features - qshell improvements - new MonadWide layout - new Bsp layout - new pomodoro widget - new stock ticker widget - new client_name_updated hook - new RunCommand and J4DmenuDesktop extension - task list expands to fill space, configurable via spacing parameter - add group.focus_by_name() and group.info_by_name() - add disk usage ratio to df widget - allow displayed group name to differ from group name - enable custom TaskList icon size - add qcmd and dqcmd to extend functionality around qtile.command functionality - add ScratchPad group that has configurable drop downs * bugfixes - fix race condition in Window.fullscreen - fix for string formatting in qtile_top - fix unicode literal in tasklist - move mpris2 initialization out of constructor - fix wlan widget variable naming and division - normalize behavior of layouts on various commands - add better fallback to default config - update btc widget to use coinbase - fix cursor warp when using default layout implementation - don't crash when using widget with unmet dependencies - fix floating window default location Qtile 0.10.7, released 2017-02-14: * features - new MPD widget, widget.MPD2, based on mpd2 library - add option to ignore duplicates in prompt widget - add additional margin options to GroupBox widget - add option to ignore mouse wheel to GroupBox widget - add watts formatting string option to Battery widgets - add volume commands to Volume widget - add Window.focus command * bugfixes - place transient windows in the middle of their parents - fix TreeTab layout - fix CurrentLayoutIcon in Python 3 - fix xcb handling for xcffib 0.5.0 - fix bug in Screen.resize - fix Qtile.display_kb command Qtile 0.10.6, released 2016-05-24: !!! qsh renamed to qshell !!! This avoids name collision with other packages * features - Test framework changed to pytest - Add startup_complete hook * bugfixes - Restore dynamic groups on restart - Correct placement of transient_for windows - Major bug fixes with floating window handling * file path changes (XDG Base Directory specification) - the default log file path changed from ~/.qtile.log to ~/.local/share/qtile/qtile.log - the cache directory changed from ~/.cache to ~/.cache/qtile - the prompt widget's history file changed from ~/.qtile_history to ~/.cache/qtile/prompt_history Qtile 0.10.5, released 2016-03-06: !!! Python 3.2 support dropped !!! !!! GoogleCalendar widget dropped for KhalCalendar widget !!! !!! qtile-session script removed in favor of qtile script !!! * features - new Columns layout, composed of dynamic and configurable columns of windows - new iPython kernel for qsh, called iqsh, see docs for installing - new qsh command display_kb to show current key binding - add json interface to IPC server - add commands for resizing MonadTall main panel - wlan widget shows when you are disconnected and uses a configurable format * bugfixes - fix path handling in PromptWidget - fix KeyboardLayout widget cycling keyboard - properly guard against setting screen to too large screen index Qtile 0.10.4, released 2016-01-19: !!! Config breakage !!! - positional arguments to Slice layout removed, now side and width must be passed in as keyword arguments * features - add alt coin support to BitcoinTracker widget * bugfixes - don't use six.moves assignment (fix for >=setuptools-19.3) - improved floating and fullscreen handling - support empty or non-charging secondary battery in BatteryWidget - fix GoogleCalendar widget crash Qtile 0.10.3, released 2015-12-25: * features - add wmii layout - add BSD support to graph widgets * bugfixes - fix (some) fullscreen problems - update google calendar widget to latest google api - improve multiple keyboard layout support - fix displaying Systray widget on secondary monitor - fix spawn file descriptor handling in Python 3 - remove duplicate assert code in test_verticaltile.py - allow padding_{x,y} and margin_{x,y} widget attrs to be set to 0 Qtile 0.10.2, released 2015-10-19: * features - add qtile-top memory monitoring - GroupBox can set visible groups - new GroupBox highlighting, line - allow window state to be hidden on WindowName widget - cmd_togroup can move to current group when None sent - added MOC playback widget - added memory usage widget - log truncation, max log size, and number of log backups configurable - add a command to change to specific layout index (lazy.to_layout_index(index)) * bugfixes - fixed memory leak in dgroups - margin fixes for MonalTall layout - improved cursor warp - remove deprecated imp for Python >= 3.3 - properly close file for NetGraph - fix MondadTall layout grow/shrink secondary panes for Python 2 - Clock widget uses datetime.now() rather than .fromtimestamp() - fix Python 3 compatibility of ThermalSensor widget - various Systray fixes, including implementing XEMBED protocol - print exception to log during loading config - fixed xmonad layout margins between main and secondary panes - clear last window name from group widgets when closed - add toggleable window border to single xmonad layout * config breakage - layouts.VerticalTile windows is now clients - layouts.VerticalTile focus_next/focus_previous now take a single argument, similar to other layouts Qtile 0.10.1, released 2015-07-08: This release fixes a problem that made the PyPI package uninstallable, qtile will work with a pip install now Qtile 0.10.0, released 2015-07-07: !!! Config breakage !!! - various deprecated commands have been removed: Screen.cmd_nextgroup: use cmd_next_group Screen.cmd_prevgroup: use cmd_prev_group Qtile.cmd_nextlayout: use cmd_next_layout Qtile.cmd_prevlayout: use cmd_prev_layout Qtile.cmd_to_next_screen: use cmd_next_screen Qtile.cmd_to_prev_screen: use cmd_prev_screen - Clock widget: remove fmt kwarg, use format kwarg - GmailChecker widget: remove settings parameter - Maildir widget: remove maildirPath, subFolders, and separator kwargs * Dependency updates - cffi>=1.1 is now required, along with xcffib>=0.3 and cairocffi>=0.7 (the cffi 1.0 compatible versions of each) - Care must be taken that xcffib is installed before cairocffi * features - add support for themed cursors using xcb-cursor if available - add CheckUpdate widget, for checking package updates, this deprecates the Pacman widget - add KeyboardKbdd widget, for changing keyboard layouts - add Cmus widget, for showing song playing in cmus - add Wallpaper widget, for showing and cycling wallpaper - add EzConfig classes allowing shortcuts to define key bindings - allow GroupBox urgent highlighting through text - Bar can be placed vertically on sides of screens (widgets must be adapted for vertical viewing) - add recognizing brightness keys * bugfixes - deprecation warnings were not printing to logs, this has been fixed - fix calculation of y property of Gap - fix focus after closing floating windows and floating windows - fix various Python 3 related int/float problems - remember screen focus across restarts - handle length 1 list passed to Drawer.set_source_rgb without raising divide by zero error - properly close files opened in Graph widget - handle _NET_WM_STATE_DEMANDS_ATTENTION as setting urgency - fix get_wm_transient_for, request WINDOW, not ATOM Qtile 0.9.1, released 2015-02-13: This is primarily a unicode bugfix release for 0.9.0; there were several nits related to the python2/3 unicode conversion that were simply wrong. This release also adds license headers to each file, which is necessary for distro maintainers to package Qtile. * bugfixes - fix python2's importing of gobject - fix unicode handling in several places Qtile 0.9.0, released 2015-01-20: * !!! Dependency Changes !!! New dependencies will need to be installed for Qtile to work - drop xpyb for xcffib (XCB bindings) - drop py2cairo for cairocffi (Cairo bindings) - drop PyGTK for asyncio (event loop, pangocairo bindings managed internally) - Qtile still depends on gobject if you want to use anything that uses dbus (e.g. the mpris widgets or the libnotify widget) * features - add Python 3 and pypy support (made possible by dependency changes) - new layout for vertical monitors - add startup_once hook, which is called exactly once per session (i.e. it is not called when qtile is restarted via lazy.restart()). This eliminates the need for the execute_once() function found in lots of user configs. - add a command for showing/hiding the bar (lazy.hide_show_bar()) - warn when a widget's dependencies cannot be imported - make qtile.log more useful via better warnings in general, including deprecation and various other warnings that were previously nonexistent - new text-polling widget super classes, which enable easy implementation of various widgets that need to poll things outside the event loop. - add man pages - large documentation update, widget/layout documentation is now autogenerated from the docstrings - new ImapWidget for checking imap mailboxes * bugfixes - change default wmname to \"LG3D\" (this prevents some java apps from not working out of the box) - all code passes flake8 - default log level is now WARNING - all widgets now use our config framework - windows with the \"About\" role float by default - got rid of a bunch of unnecessary bare except: clauses Qtile 0.8.0, released 2014-08-18: * features - massive widget/layout documentation update - new widget debuginfo for use in Qtile development - stack has new autosplit, fair options - matrix, ratiotile, stack, xmonad, zoomy get 'margin' option - new launchbar widget - support for matching WM_CLASS and pid in Match - add support for adding dgroups rules dynamically and via ipc - Clock supports non-system timezones - new mpris2 widget - volume widget can use emoji instead of numbers - add an 'eval' function to qsh at every object level - bar gradients support more colors - new Clipboard widget (very handy!) * bugfixes - bitcoin ticker widget switched from MtGox (dead) to btc-e - all widgets now use Qtile's defaults system, so their defaults are settable globally, etc. - fix behavior when screens are cloned - all widgets use a unified polling framework - \"dialog\" WM_TYPEs float by default - respect xrandr --primary - use a consistent font size in the default config - default config supports mouse movements and floating - fix a bug where the bar was not redrawn correctly in some multiscreen environments - add travis-ci support and make tests vastly more robust * config breakage - libqtile.layout.Stack's stacks parameter is now num_stacks Qtile 0.7.0, released 2014-03-30: * features - new disk free percentage widget - new widget to display static image - per core CPU graphs - add \"screen affinity\" in dynamic groups - volume widget changes volume linear-ly instead of log-ly - only draw bar when idle, vastly reducing the number of bar draws and speeding things up - new Gmail widget - Tile now supports automatically managing master windows via the master_match parameter. - include support for minimum height, width, size increment hints * bugfixes - don't crash on any exception in main loop - don't crash on exceptions in hooks - fix a ZeroDivisionError in CPU graph - remove a lot of duplicate and unused code - Steam windows are placed more correctly - Fixed several crashes in qsh - performance improvements for some layouts - keyboard layout widget behaves better with multiple keyboard configurations * config breakage - Tile's shuffleMatch is renamed to resetMaster Qtile 0.6, released 2013-05-11: !!! Config breakage !!! This release breaks your config file in several ways: - The Textbox widget no longer takes a name'' positional parameter, since it was redundant; you can use the name'' kwarg to define it. - manager.Group (now _Group) is not used to configure groups any more; config.Group replaces it. For simple configurations (i.e. Group(\"a\") type configs), this should be a drop in replacement. config.Group also provides many more options for showing and hiding groups, assigning windows to groups by default, etc. - The Key, Screen, Drag, and Click objects have moved from the manager module to the config module. - The Match object has moved from the dgroups module to the config module. - The addgroup hook now takes two parameters: the qtile object and the name of the group added: @hook.subscribe def addgroup_hook(qtile, name): pass - The nextgroup and prevgroup commands are now on Screen instead of Group. For most people, you should be able to just: sed -i -e 's/libqtile.manager/libqtile.config' config.py ...dgroups users will need to go to a bit more work, but hopefully configuration will be much simpler now for new users. * features - New widgets: task list, - New layout: Matrix - Added ability to drag and drop groups on GroupBox - added \"next urgent window\" command - added font shadowing on widgets - maildir widget supports multiple folders - new config option log_level to set logging level (any of logging.{DEBUG, INFO, WARNING, ERROR, CRITICAL}) - add option to battery widget to hide while level is above a certain amount - vastly simplify configuration of dynamic groups - MPD widget now supports lots of metadata options * bugfixes - don't crash on restart when the config has errors - save layout and selected group state on restart - varous EWMH properties implemented correctly - fix non-black systray icon backgrounds - drastically reduce the number of timeout_add calls in most widgets - restart on RandR attach events to allow for new screens - log level defaults to ERROR - default config options are no longer initialized when users define their corresponding option (preventing duplicate widgets, etc.) - don't try to load config in qsh (not used) - fix font alignment across Textbox based widgets Qtile 0.5, released 2012-11-11: (Note, this is not complete! Many, many changes have gone in to 0.5, by a large number of contributors. Thanks to everyone who reported a bug or fixed one!) * features - Test framework is now nose - Documentation is now in sphinx - Several install guides for various OSes - New widgets: battery based icon, MPRIS1, canto, current layout, yahoo weather, sensors, screen brightness, notifiy, pacman, windowtabs, she, crashme, wifi. - Several improvements to old widgets (e.g. battery widget displays low battery in red, GroupBox now has a better indication of which screen has focus in multi-screen setups, improvements to Prompt, etc.) - Desktop notification service. - More sane way to handle configuration files - Promote dgroups to a first class entity in libqtile - Allow layouts to be named on an instance level, so you can: layouts = [ # a layout just for gimp layout.Slice('left', 192, name='gimp', role='gimp-toolbox', fallback=layout.Slice('right', 256, role='gimp-dock', fallback=layout.Stack(stacks=1, **border_args))) ] ... dynamic_groups = { 'gimp': {'layout': 'gimp'} } Dgroups(..., dynamic_groups, ...) - New Layout: Zoomy - Add a session manager to re-exec qtile if things go south - Support for WM_TAKE_FOCUS protocol - Basic .desktop file for support in login managers - Qsh reconnects after qtile is restarted from within it - Textbox supports pango markup - Examples moved to qtile-examples repository. * bugfixes - Fix several classes of X races in a more sane way - Minor typo fixes to most widgets - Fix several crashes when drawing systray icons too early - Create directories for qtile socket as necessary - PEP8 formatting updates (though we're not totally there yet) - All unit tests pass - Lots of bugfixes to MonadTall - Create IPC socket directory if necessary - Better error if two widgets have STRETCH length - Autofloat window classes can now be overridden - xkeysyms updated vim :set ts=4 sw=4 sts=4 et :","title":"Changelog"},{"location":"changelog/#vim-set-ts4-sw4-sts4-et","text":"","title":"vim :set ts=4 sw=4 sts=4 et :"},{"location":"contributing/","text":"How to contribute Instead of making this document a copy of the contributing section of our documentation , we just link to it here.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"Instead of making this document a copy of the contributing section of our documentation , we just link to it here.","title":"How to contribute"},{"location":"credits/","text":"Traceback ( most recent call last ): File \"/home/pawamoy/data/dev/qtile/.venv/lib/python3.10/site-packages/markdown_exec/formatters/python.py\" , line 23 , in _run_python exec ( code , exec_globals ) # noqa: S102 File \"<executed code block>\" , line 6 , in < module > import toml ModuleNotFoundError : No module named 'toml'","title":"Credits"},{"location":"license/","text":"Copyright (c) 2008, Aldo Cortesi. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"libqtile backend base wayland core drawer inputs layer libinput_ffi_build output subsurface window wlrq xdgwindow xwindow x11 core drawer window xcbq xcursors xcursors_ffi_build xkeysyms bar command base client graph interface command_client command_graph command_interface command_object config configurable confreader core lifecycle loop manager state dgroups drawer extension base command_set dmenu window_list group hook images interactive iqshell_install iqshell_kernel ipc layout base bsp columns floating matrix max ratiotile slice spiral stack tile tree verticaltile xmonad zoomy lazy log_utils notify pango_ffi_build pangocffi popup resources default_config scratchpad scripts check cmd_obj main migrate run_cmd shell start top sh utils widget backlight base battery bluetooth canto caps_num_lock_indicator check_updates chord clipboard clock cmus config_error countdown cpu crashme crypto_ticker currentlayout currentscreen df generic_poll_text gmail_checker graph groupbox idlerpg image imapwidget import_error keyboardkbdd keyboardlayout khal_calendar launchbar load maildir memory moc mpd2widget mpris2widget net notify nvidia_sensors open_weather pomodoro prompt pulse_volume pulseaudio_ffi quick_exit sensors sep she spacer statusnotifier stock_ticker systray tasklist textbox thermal_zone volume wallpaper widgetbox window_count windowname windowtabs wlan wttr","title":"SUMMARY"},{"location":"reference/libqtile/","text":"","title":"libqtile"},{"location":"reference/libqtile/bar/","text":"Bar ( widgets , size , ** config ) Bases: Gap , configurable . Configurable , CommandObject A bar, which can contain widgets Parameters widgets : A list of widget objects. size : The \"thickness\" of the bar, i.e. the height of a horizontal bar, or the width of a vertical bar. Source code in libqtile/bar.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , widgets , size , ** config ): Gap . __init__ ( self , size ) configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( Bar . defaults ) self . widgets = widgets self . saved_focus = None self . cursor_in = None self . window = None self . size_calculated = 0 self . _configured = False self . has_keyboard : _Widget | None = None if isinstance ( self . margin , int ): self . margin = [ self . margin ] * 4 if isinstance ( self . border_width , int ): self . border_width = [ self . border_width ] * 4 self . _initial_margin = self . margin [:] self . struts = [ 0 , 0 , 0 , 0 ] self . _add_strut = False self . queued_draws = 0 self . future = None self . _borders_drawn = False fake_button_press ( screen , position , x , y , button = 1 ) Fake a mouse-button-press on the bar. Co-ordinates are relative to the top-left corner of the bar. :screen The integer screen offset :position One of \"top\", \"bottom\", \"left\", or \"right\" Source code in libqtile/bar.py 668 669 670 671 672 673 674 675 676 677 @expose_command () def fake_button_press ( self , screen , position , x , y , button = 1 ): \"\"\" Fake a mouse-button-press on the bar. Co-ordinates are relative to the top-left corner of the bar. :screen The integer screen offset :position One of \"top\", \"bottom\", \"left\", or \"right\" \"\"\" self . process_button_click ( x , y , button ) kill_window () Kill the window when the bar's screen is no longer being used. Source code in libqtile/bar.py 391 392 393 394 395 396 397 398 399 def kill_window ( self ): \"\"\"Kill the window when the bar's screen is no longer being used.\"\"\" for name , w in self . qtile . widgets_map . copy () . items (): if w in self . widgets : w . finalize () del self . qtile . widgets_map [ name ] self . drawer . finalize () self . window . kill () self . window = None process_window_expose () If the window is being redrawn we need to redraw borders too. Source code in libqtile/bar.py 554 555 556 557 558 559 def process_window_expose ( self ): \"\"\" If the window is being redrawn we need to redraw borders too. \"\"\" self . _borders_drawn = False self . draw () widget_grab_keyboard ( widget ) A widget can call this method to grab the keyboard focus and receive keyboard messages. When done, widget_ungrab_keyboard() must be called. Source code in libqtile/bar.py 536 537 538 539 540 541 542 543 544 def widget_grab_keyboard ( self , widget ): \"\"\" A widget can call this method to grab the keyboard focus and receive keyboard messages. When done, widget_ungrab_keyboard() must be called. \"\"\" self . has_keyboard = widget self . saved_focus = self . qtile . current_window self . window . focus ( False ) widget_ungrab_keyboard () Removes keyboard focus from the widget. Source code in libqtile/bar.py 546 547 548 549 550 551 552 def widget_ungrab_keyboard ( self ): \"\"\" Removes keyboard focus from the widget. \"\"\" if self . saved_focus is not None : self . saved_focus . focus ( False ) self . has_keyboard = None Gap ( size ) A gap placed along one of the edges of the screen If a gap has been defined, Qtile will avoid covering it with windows. The most probable reason for configuring a gap is to make space for a third-party bar or other static window. Parameters size : The \"thickness\" of the gap, i.e. the height of a horizontal gap, or the width of a vertical gap. Source code in libqtile/bar.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , size ): \"\"\" \"\"\" # 'size' corresponds to the height of a horizontal gap, or the width # of a vertical gap self . size = size self . initial_size = size # 'length' corresponds to the width of a horizontal gap, or the height # of a vertical gap self . length = None self . qtile = None self . screen = None self . x = None self . y = None self . width = None self . height = None self . horizontal = None info () Info for this object. Source code in libqtile/bar.py 117 118 119 120 121 122 @expose_command () def info ( self ): \"\"\" Info for this object. \"\"\" return dict ( position = self . position )","title":"bar"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar","text":"Bases: Gap , configurable . Configurable , CommandObject A bar, which can contain widgets","title":"Bar"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar--parameters","text":"widgets : A list of widget objects. size : The \"thickness\" of the bar, i.e. the height of a horizontal bar, or the width of a vertical bar. Source code in libqtile/bar.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , widgets , size , ** config ): Gap . __init__ ( self , size ) configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( Bar . defaults ) self . widgets = widgets self . saved_focus = None self . cursor_in = None self . window = None self . size_calculated = 0 self . _configured = False self . has_keyboard : _Widget | None = None if isinstance ( self . margin , int ): self . margin = [ self . margin ] * 4 if isinstance ( self . border_width , int ): self . border_width = [ self . border_width ] * 4 self . _initial_margin = self . margin [:] self . struts = [ 0 , 0 , 0 , 0 ] self . _add_strut = False self . queued_draws = 0 self . future = None self . _borders_drawn = False","title":"Parameters"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar.fake_button_press","text":"Fake a mouse-button-press on the bar. Co-ordinates are relative to the top-left corner of the bar. :screen The integer screen offset :position One of \"top\", \"bottom\", \"left\", or \"right\" Source code in libqtile/bar.py 668 669 670 671 672 673 674 675 676 677 @expose_command () def fake_button_press ( self , screen , position , x , y , button = 1 ): \"\"\" Fake a mouse-button-press on the bar. Co-ordinates are relative to the top-left corner of the bar. :screen The integer screen offset :position One of \"top\", \"bottom\", \"left\", or \"right\" \"\"\" self . process_button_click ( x , y , button )","title":"fake_button_press()"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar.kill_window","text":"Kill the window when the bar's screen is no longer being used. Source code in libqtile/bar.py 391 392 393 394 395 396 397 398 399 def kill_window ( self ): \"\"\"Kill the window when the bar's screen is no longer being used.\"\"\" for name , w in self . qtile . widgets_map . copy () . items (): if w in self . widgets : w . finalize () del self . qtile . widgets_map [ name ] self . drawer . finalize () self . window . kill () self . window = None","title":"kill_window()"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar.process_window_expose","text":"If the window is being redrawn we need to redraw borders too. Source code in libqtile/bar.py 554 555 556 557 558 559 def process_window_expose ( self ): \"\"\" If the window is being redrawn we need to redraw borders too. \"\"\" self . _borders_drawn = False self . draw ()","title":"process_window_expose()"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar.widget_grab_keyboard","text":"A widget can call this method to grab the keyboard focus and receive keyboard messages. When done, widget_ungrab_keyboard() must be called. Source code in libqtile/bar.py 536 537 538 539 540 541 542 543 544 def widget_grab_keyboard ( self , widget ): \"\"\" A widget can call this method to grab the keyboard focus and receive keyboard messages. When done, widget_ungrab_keyboard() must be called. \"\"\" self . has_keyboard = widget self . saved_focus = self . qtile . current_window self . window . focus ( False )","title":"widget_grab_keyboard()"},{"location":"reference/libqtile/bar/#libqtile.bar.Bar.widget_ungrab_keyboard","text":"Removes keyboard focus from the widget. Source code in libqtile/bar.py 546 547 548 549 550 551 552 def widget_ungrab_keyboard ( self ): \"\"\" Removes keyboard focus from the widget. \"\"\" if self . saved_focus is not None : self . saved_focus . focus ( False ) self . has_keyboard = None","title":"widget_ungrab_keyboard()"},{"location":"reference/libqtile/bar/#libqtile.bar.Gap","text":"A gap placed along one of the edges of the screen If a gap has been defined, Qtile will avoid covering it with windows. The most probable reason for configuring a gap is to make space for a third-party bar or other static window.","title":"Gap"},{"location":"reference/libqtile/bar/#libqtile.bar.Gap--parameters","text":"size : The \"thickness\" of the gap, i.e. the height of a horizontal gap, or the width of a vertical gap. Source code in libqtile/bar.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , size ): \"\"\" \"\"\" # 'size' corresponds to the height of a horizontal gap, or the width # of a vertical gap self . size = size self . initial_size = size # 'length' corresponds to the width of a horizontal gap, or the height # of a vertical gap self . length = None self . qtile = None self . screen = None self . x = None self . y = None self . width = None self . height = None self . horizontal = None","title":"Parameters"},{"location":"reference/libqtile/bar/#libqtile.bar.Gap.info","text":"Info for this object. Source code in libqtile/bar.py 117 118 119 120 121 122 @expose_command () def info ( self ): \"\"\" Info for this object. \"\"\" return dict ( position = self . position )","title":"info()"},{"location":"reference/libqtile/command_client/","text":"","title":"command_client"},{"location":"reference/libqtile/command_graph/","text":"","title":"command_graph"},{"location":"reference/libqtile/command_interface/","text":"","title":"command_interface"},{"location":"reference/libqtile/command_object/","text":"","title":"command_object"},{"location":"reference/libqtile/config/","text":"Click Bases: Mouse Bind commands to a clicking action. Parameters modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . button: The button used to start dragging e.g. \"Button1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. Drag ( modifiers , button , * commands , start = None , warp_pointer = False ) Bases: Mouse Bind commands to a dragging action. On each motion event the bound commands are executed with two additional parameters specifying the x and y offset from the previous position. Parameters modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . button: The button used to start dragging e.g. \"Button1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. start: A :class: LazyCall object to be evaluated when dragging begins. (Optional) warp_pointer: A :class: bool indicating if the pointer should be warped to the bottom right of the window at the start of dragging. (Default: False ) Source code in libqtile/config.py 177 178 179 180 181 182 183 184 185 186 187 def __init__ ( self , modifiers : list [ str ], button : str , * commands : LazyCall , start : LazyCall | None = None , warp_pointer : bool = False , ) -> None : super () . __init__ ( modifiers , button , * commands ) self . start = start self . warp_pointer = warp_pointer DropDown ( name , cmd , ** config ) Bases: configurable . Configurable Configure a specified command and its associated window for the :class: ScratchPad . That window can be shown and hidden using a configurable keystroke or any other scripted trigger. Define a command to spawn a process for the first time the class: DropDown is shown. Parameters name: The name of the dropdown. cmd: Command to spawn a window to be captured by the dropdown. Source code in libqtile/config.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 def __init__ ( self , name : str , cmd : str , ** config : dict [ str , Any ]) -> None : \"\"\" Initialize :class:`DropDown` window wrapper. Define a command to spawn a process for the first time the class:`DropDown` is shown. Parameters ========== name: The name of the dropdown. cmd: Command to spawn a window to be captured by the dropdown. \"\"\" configurable . Configurable . __init__ ( self , ** config ) self . name = name self . command = cmd self . add_defaults ( self . defaults ) EzClick ( btndef , * commands ) Bases: EzConfig , Click Bind commands to a clicking action using the Emacs-like format. Parameters btndef: The Emacs-like button specification, e.g. \"M-1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. Source code in libqtile/config.py 299 300 301 302 def __init__ ( self , btndef : str , * commands : LazyCall ) -> None : modkeys , button = self . parse ( btndef ) button = \"Button %s \" % button super () . __init__ ( modkeys , button , * commands ) EzConfig Helper class for defining key and button bindings in an Emacs-like format. Inspired by Xmonad's XMonad.Util.EZConfig. Splits an emacs keydef into modifiers and keys. For example: \"m-s-a\" -> ['mod4', 'shift'], 'a' \"a-<minus>\" -> ['mod1'], 'minus' \"C-<Tab>\" -> ['control'], 'Tab' EzDrag ( btndef , * commands , start = None ) Bases: EzConfig , Drag Bind commands to a dragging action using the Emacs-like format. Parameters btndef: The Emacs-like button specification, e.g. \"M-1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. start: A :class: LazyCall object to be evaluated when dragging begins. (Optional) Source code in libqtile/config.py 320 321 322 323 def __init__ ( self , btndef : str , * commands : LazyCall , start : LazyCall | None = None ) -> None : modkeys , button = self . parse ( btndef ) button = \"Button %s \" % button super () . __init__ ( modkeys , button , * commands , start = start ) EzKey ( keydef , * commands , desc = '' ) Bases: EzConfig , Key Defines a keybinding using the Emacs-like format. Parameters keydef: The Emacs-like key specification, e.g. \"M-S-a\" . commands: A list :class: LazyCall objects to evaluate in sequence upon keypress. desc: Description to be added to the key binding. (Optional) Source code in libqtile/config.py 281 282 283 def __init__ ( self , keydef : str , * commands : LazyCall , desc : str = \"\" ) -> None : modkeys , key = self . parse ( keydef ) super () . __init__ ( modkeys , key , * commands , desc = desc ) Group ( name , matches = None , exclusive = False , spawn = None , layout = None , layouts = None , persist = True , init = True , layout_opts = None , screen_affinity = None , position = sys . maxsize , label = None ) Represents a \"dynamic\" group These groups can spawn apps, only allow certain Matched windows to be on them, hide when they're not in use, etc. Groups are identified by their name. Parameters name: The name of this group. matches: List of :class: Match objects whose matched windows will be assigned to this group. exclusive: When other apps are started in this group, should we allow them here or not? spawn: This will be exec() d when the group is created. Tou can pass either a program name or a list of programs to exec() layout: The name of default layout for this group (e.g. \"max\" ). This is the name specified for a particular layout in config.py or if not defined it defaults in general to the class name in all lower case. layouts: The group layouts list overriding global layouts. Use this to define a separate list of layouts for this particular group. persist: Should this group stay alive when it has no member windows? init: Should this group be alive when Qtile starts? layout_opts: Options to pass to a layout. screen_affinity: Make a dynamic group prefer to start on a specific screen. position: The position of this group. label: The display name of the group. Use this to define a display name other than name of the group. If set to None , the display name is set to the name. Source code in libqtile/config.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def __init__ ( self , name : str , matches : list [ Match ] | None = None , exclusive : bool = False , spawn : str | list [ str ] | None = None , layout : str | None = None , layouts : list [ Layout ] | None = None , persist : bool = True , init : bool = True , layout_opts : dict [ str , Any ] | None = None , screen_affinity : int | None = None , position : int = sys . maxsize , label : str | None = None , ) -> None : self . name = name self . label = label self . exclusive = exclusive self . spawn = spawn self . layout = layout self . layouts = layouts or [] self . persist = persist self . init = init self . matches = matches or [] self . layout_opts = layout_opts or {} self . screen_affinity = screen_affinity self . position = position Key ( modifiers , key , * commands , desc = '' ) Defines a keybinding. Parameters modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . key: A key specification, e.g. \"a\" , \"Tab\" , \"Return\" , \"space\" . commands: One or more :class: LazyCall objects to evaluate in sequence upon keypress. Multiple commands should be separated by commas. desc: Description to be added to the key binding. (Optional) Source code in libqtile/config.py 72 73 74 75 76 77 78 def __init__ ( self , modifiers : list [ str ], key : str , * commands : LazyCall , desc : str = \"\" ) -> None : self . modifiers = modifiers self . key = key self . commands = commands self . desc = desc KeyChord ( modifiers , key , submappings , mode = False , name = '' , desc = '' ) Define a key chord aka Vim-like mode. Parameters modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . key: A key specification, e.g. \"a\" , \"Tab\" , \"Return\" , \"space\" . submappings: A list of :class: Key or :class: KeyChord declarations to bind in this chord. mode: Boolean. Setting to True will result in the chord persisting until Escape is pressed. Setting to False (default) will exit the chord once the sequence has ended. name: A string to name the chord. The name will be displayed in the Chord widget. desc: A string to describe the chord. This attribute is not directly used by Qtile but users may want to access this when creating scripts to show configured keybindings. Source code in libqtile/config.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def __init__ ( self , modifiers : list [ str ], key : str , submappings : list [ Key | KeyChord ], mode : bool | str = False , name : str = \"\" , desc : str = \"\" , ): self . modifiers = modifiers self . key = key submappings . append ( Key ([], \"Escape\" )) self . submappings = submappings self . mode = mode self . name = name self . desc = desc if isinstance ( mode , str ): logger . warning ( \"The use of `mode` to set the KeyChord name is deprecated. \" \"Please use `name=' %s '` instead. \" \"'mode' should be a boolean value to set whether the chord is persistent (True) or not.\" , mode , ) self . name = mode self . mode = True Match ( title = None , wm_class = None , role = None , wm_type = None , wm_instance_class = None , net_wm_pid = None , func = None , wid = None ) Match for dynamic groups or auto-floating windows. For some properties, :class: Match supports both regular expression objects (i.e. the result of re.compile() ) or strings (match as an \"include\"-match). If a window matches all specified values, it is considered a match. Parameters title: Match against the WM_NAME atom (X11) or title (Wayland). wm_class: Match against the second string in WM_CLASS atom (X11) or app ID (Wayland). role: Match against the WM_ROLE atom (X11 only). wm_type: Match against the WM_TYPE atom (X11 only). wm_instance_class: Match against the first string in WM_CLASS atom (X11) or app ID (Wayland). net_wm_pid: Match against the _NET_WM_PID atom (X11) or PID (Wayland). func: Delegate the match to the given function, which receives the tested client as an argument and must return True if it matches, False otherwise. wid: Match against the window ID. Source code in libqtile/config.py 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 def __init__ ( self , title : str | re . Pattern | None = None , wm_class : str | re . Pattern | None = None , role : str | re . Pattern | None = None , wm_type : str | re . Pattern | None = None , wm_instance_class : str | re . Pattern | None = None , net_wm_pid : int | None = None , func : Callable [[ base . Window ], bool ] | None = None , wid : int | None = None , ) -> None : self . _rules : dict [ str , Any ] = {} if title is not None : self . _rules [ \"title\" ] = title if wm_class is not None : self . _rules [ \"wm_class\" ] = wm_class if wm_instance_class is not None : self . _rules [ \"wm_instance_class\" ] = wm_instance_class if wid is not None : self . _rules [ \"wid\" ] = wid if net_wm_pid is not None : try : self . _rules [ \"net_wm_pid\" ] = int ( net_wm_pid ) except ValueError : error = 'Invalid rule for net_wm_pid: \" %s \" only int allowed' % str ( net_wm_pid ) raise utils . QtileError ( error ) if func is not None : self . _rules [ \"func\" ] = func if role is not None : self . _rules [ \"role\" ] = role if wm_type is not None : self . _rules [ \"wm_type\" ] = wm_type map ( callback , clients ) Apply callback to each client that matches this Match Source code in libqtile/config.py 887 888 889 890 891 def map ( self , callback : Callable [[ base . Window ], Any ], clients : list [ base . Window ]) -> None : \"\"\"Apply callback to each client that matches this Match\"\"\" for c in clients : if self . compare ( c ): callback ( c ) Rule ( match , group = None , float = False , intrusive = False , break_on_match = True ) How to act on a match. A :class: Rule contains a list of :class: Match objects, and a specification about what to do when any of them is matched. Parameters match: :class: Match object or a list of such associated with this rule. float: Should we auto float this window? intrusive: Should we override the group's exclusive setting? break_on_match: Should we stop applying rules if this rule is matched? Source code in libqtile/config.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 def __init__ ( self , match : Match | list [ Match ], group : _Group | None = None , float : bool = False , intrusive : bool = False , break_on_match : bool = True , ) -> None : if isinstance ( match , Match ): self . matchlist = [ match ] else : self . matchlist = match self . group = group self . float = float self . intrusive = intrusive self . break_on_match = break_on_match ScratchPad ( name , dropdowns = None , position = sys . maxsize , label = '' , single = False ) Bases: Group Represents a \"ScratchPad\" group ScratchPad adds a (by default) invisible group to Qtile. That group is used as a place for currently not visible windows spawned by a :class: DropDown configuration. Parameters name: The name of this group. dropdowns: :class: DropDown s available on the scratchpad. position: The position of this group. label: The display name of the :class: ScratchPad group. Defaults to the empty string such that the group is hidden in :class: ~libqtile.widget.GroupBox widget. single: If True , only one of the dropdowns will be visible at a time. Source code in libqtile/config.py 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 def __init__ ( self , name : str , dropdowns : list [ DropDown ] | None = None , position : int = sys . maxsize , label : str = \"\" , single : bool = False , ) -> None : Group . __init__ ( self , name , layout = \"floating\" , init = False , position = position , label = label , ) self . dropdowns = dropdowns if dropdowns is not None else [] self . single = single Screen ( top = None , bottom = None , left = None , right = None , wallpaper = None , wallpaper_mode = None , x = None , y = None , width = None , height = None ) Bases: CommandObject A physical screen, and its associated paraphernalia. Define a screen with a given set of :class: Bar s of a specific geometry. Also, x , y , width , and height aren't specified usually unless you are using 'fake screens'. The wallpaper parameter, if given, should be a path to an image file. How this image is painted to the screen is specified by the wallpaper_mode parameter. By default, the image will be placed at the screens origin and retain its own dimensions. If the mode is \"fill\" , the image will be centred on the screen and resized to fill it. If the mode is \"stretch\" , the image is stretched to fit all of it into the screen. Source code in libqtile/config.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def __init__ ( self , top : BarType | None = None , bottom : BarType | None = None , left : BarType | None = None , right : BarType | None = None , wallpaper : str | None = None , wallpaper_mode : str | None = None , x : int | None = None , y : int | None = None , width : int | None = None , height : int | None = None , ) -> None : self . top = top self . bottom = bottom self . left = left self . right = right self . wallpaper = wallpaper self . wallpaper_mode = wallpaper_mode self . qtile : Qtile | None = None # x position of upper left corner can be > 0 # if one screen is \"right\" of the other self . x = x if x is not None else 0 self . y = y if y is not None else 0 self . width = width if width is not None else 0 self . height = height if height is not None else 0 self . previous_group : _Group | None = None info () Returns a dictionary of info for this screen. Source code in libqtile/config.py 592 593 594 595 @expose_command () def info ( self ) -> dict [ str , int ]: \"\"\"Returns a dictionary of info for this screen.\"\"\" return dict ( index = self . index , width = self . width , height = self . height , x = self . x , y = self . y ) next_group ( skip_empty = False , skip_managed = False ) Switch to the next group Source code in libqtile/config.py 597 598 599 600 601 602 @expose_command () def next_group ( self , skip_empty : bool = False , skip_managed : bool = False ) -> None : \"\"\"Switch to the next group\"\"\" n = self . group . get_next_group ( skip_empty , skip_managed ) self . set_group ( n ) return n . name prev_group ( skip_empty = False , skip_managed = False , warp = True ) Switch to the previous group Source code in libqtile/config.py 604 605 606 607 608 609 610 611 @expose_command () def prev_group ( self , skip_empty : bool = False , skip_managed : bool = False , warp : bool = True ) -> None : \"\"\"Switch to the previous group\"\"\" n = self . group . get_previous_group ( skip_empty , skip_managed ) self . set_group ( n , warp = warp ) return n . name set_group ( new_group , save_prev = True , warp = True ) Put group on this screen Source code in libqtile/config.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def set_group ( self , new_group : _Group | None , save_prev : bool = True , warp : bool = True ) -> None : \"\"\"Put group on this screen\"\"\" if new_group is None : return if new_group . screen == self : return if save_prev and new_group is not self . group : # new_group can be self.group only if the screen is getting configured for # the first time self . previous_group = self . group if new_group . screen : # g1 <-> s1 (self) # g2 (new_group) <-> s2 to # g1 <-> s2 # g2 <-> s1 g1 = self . group s1 = self g2 = new_group s2 = new_group . screen s2 . group = g1 g1 . set_screen ( s2 , warp ) s1 . group = g2 g2 . set_screen ( s1 , warp ) else : assert self . qtile is not None old_group = self . group self . group = new_group with self . qtile . core . masked (): # display clients of the new group and then hide from old group # to remove the screen flickering new_group . set_screen ( self , warp ) # Can be the same group only if the screen just got configured for the # first time - see `Qtile._process_screens`. if old_group is not new_group : old_group . set_screen ( None , warp ) hook . fire ( \"setgroup\" ) hook . fire ( \"focus_change\" ) hook . fire ( \"layout_change\" , self . group . layouts [ self . group . current_layout ], self . group ) set_wallpaper ( path , mode = None ) Set the wallpaper to the given file. Source code in libqtile/config.py 620 621 622 623 @expose_command () def set_wallpaper ( self , path : str , mode : str | None = None ) -> None : \"\"\"Set the wallpaper to the given file.\"\"\" self . paint ( path , mode ) toggle_group ( group_name = None , warp = True ) Switch to the selected group or to the previously active one Source code in libqtile/config.py 613 614 615 616 617 618 @expose_command () def toggle_group ( self , group_name : str | None = None , warp : bool = True ) -> None : \"\"\"Switch to the selected group or to the previously active one\"\"\" assert self . qtile is not None group = self . qtile . groups_map . get ( group_name if group_name else \"\" ) self . _toggle_group ( group , warp = warp )","title":"config"},{"location":"reference/libqtile/config/#libqtile.config.Click","text":"Bases: Mouse Bind commands to a clicking action.","title":"Click"},{"location":"reference/libqtile/config/#libqtile.config.Click--parameters","text":"modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . button: The button used to start dragging e.g. \"Button1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag.","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.Drag","text":"Bases: Mouse Bind commands to a dragging action. On each motion event the bound commands are executed with two additional parameters specifying the x and y offset from the previous position.","title":"Drag"},{"location":"reference/libqtile/config/#libqtile.config.Drag--parameters","text":"modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . button: The button used to start dragging e.g. \"Button1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. start: A :class: LazyCall object to be evaluated when dragging begins. (Optional) warp_pointer: A :class: bool indicating if the pointer should be warped to the bottom right of the window at the start of dragging. (Default: False ) Source code in libqtile/config.py 177 178 179 180 181 182 183 184 185 186 187 def __init__ ( self , modifiers : list [ str ], button : str , * commands : LazyCall , start : LazyCall | None = None , warp_pointer : bool = False , ) -> None : super () . __init__ ( modifiers , button , * commands ) self . start = start self . warp_pointer = warp_pointer","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.DropDown","text":"Bases: configurable . Configurable Configure a specified command and its associated window for the :class: ScratchPad . That window can be shown and hidden using a configurable keystroke or any other scripted trigger. Define a command to spawn a process for the first time the class: DropDown is shown.","title":"DropDown"},{"location":"reference/libqtile/config/#libqtile.config.DropDown--parameters","text":"name: The name of the dropdown. cmd: Command to spawn a window to be captured by the dropdown. Source code in libqtile/config.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 def __init__ ( self , name : str , cmd : str , ** config : dict [ str , Any ]) -> None : \"\"\" Initialize :class:`DropDown` window wrapper. Define a command to spawn a process for the first time the class:`DropDown` is shown. Parameters ========== name: The name of the dropdown. cmd: Command to spawn a window to be captured by the dropdown. \"\"\" configurable . Configurable . __init__ ( self , ** config ) self . name = name self . command = cmd self . add_defaults ( self . defaults )","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.EzClick","text":"Bases: EzConfig , Click Bind commands to a clicking action using the Emacs-like format.","title":"EzClick"},{"location":"reference/libqtile/config/#libqtile.config.EzClick--parameters","text":"btndef: The Emacs-like button specification, e.g. \"M-1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. Source code in libqtile/config.py 299 300 301 302 def __init__ ( self , btndef : str , * commands : LazyCall ) -> None : modkeys , button = self . parse ( btndef ) button = \"Button %s \" % button super () . __init__ ( modkeys , button , * commands )","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.EzConfig","text":"Helper class for defining key and button bindings in an Emacs-like format. Inspired by Xmonad's XMonad.Util.EZConfig. Splits an emacs keydef into modifiers and keys. For example: \"m-s-a\" -> ['mod4', 'shift'], 'a' \"a-<minus>\" -> ['mod1'], 'minus' \"C-<Tab>\" -> ['control'], 'Tab'","title":"EzConfig"},{"location":"reference/libqtile/config/#libqtile.config.EzDrag","text":"Bases: EzConfig , Drag Bind commands to a dragging action using the Emacs-like format.","title":"EzDrag"},{"location":"reference/libqtile/config/#libqtile.config.EzDrag--parameters","text":"btndef: The Emacs-like button specification, e.g. \"M-1\" . commands: A list :class: LazyCall objects to evaluate in sequence upon drag. start: A :class: LazyCall object to be evaluated when dragging begins. (Optional) Source code in libqtile/config.py 320 321 322 323 def __init__ ( self , btndef : str , * commands : LazyCall , start : LazyCall | None = None ) -> None : modkeys , button = self . parse ( btndef ) button = \"Button %s \" % button super () . __init__ ( modkeys , button , * commands , start = start )","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.EzKey","text":"Bases: EzConfig , Key Defines a keybinding using the Emacs-like format.","title":"EzKey"},{"location":"reference/libqtile/config/#libqtile.config.EzKey--parameters","text":"keydef: The Emacs-like key specification, e.g. \"M-S-a\" . commands: A list :class: LazyCall objects to evaluate in sequence upon keypress. desc: Description to be added to the key binding. (Optional) Source code in libqtile/config.py 281 282 283 def __init__ ( self , keydef : str , * commands : LazyCall , desc : str = \"\" ) -> None : modkeys , key = self . parse ( keydef ) super () . __init__ ( modkeys , key , * commands , desc = desc )","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.Group","text":"Represents a \"dynamic\" group These groups can spawn apps, only allow certain Matched windows to be on them, hide when they're not in use, etc. Groups are identified by their name.","title":"Group"},{"location":"reference/libqtile/config/#libqtile.config.Group--parameters","text":"name: The name of this group. matches: List of :class: Match objects whose matched windows will be assigned to this group. exclusive: When other apps are started in this group, should we allow them here or not? spawn: This will be exec() d when the group is created. Tou can pass either a program name or a list of programs to exec() layout: The name of default layout for this group (e.g. \"max\" ). This is the name specified for a particular layout in config.py or if not defined it defaults in general to the class name in all lower case. layouts: The group layouts list overriding global layouts. Use this to define a separate list of layouts for this particular group. persist: Should this group stay alive when it has no member windows? init: Should this group be alive when Qtile starts? layout_opts: Options to pass to a layout. screen_affinity: Make a dynamic group prefer to start on a specific screen. position: The position of this group. label: The display name of the group. Use this to define a display name other than name of the group. If set to None , the display name is set to the name. Source code in libqtile/config.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def __init__ ( self , name : str , matches : list [ Match ] | None = None , exclusive : bool = False , spawn : str | list [ str ] | None = None , layout : str | None = None , layouts : list [ Layout ] | None = None , persist : bool = True , init : bool = True , layout_opts : dict [ str , Any ] | None = None , screen_affinity : int | None = None , position : int = sys . maxsize , label : str | None = None , ) -> None : self . name = name self . label = label self . exclusive = exclusive self . spawn = spawn self . layout = layout self . layouts = layouts or [] self . persist = persist self . init = init self . matches = matches or [] self . layout_opts = layout_opts or {} self . screen_affinity = screen_affinity self . position = position","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.Key","text":"Defines a keybinding.","title":"Key"},{"location":"reference/libqtile/config/#libqtile.config.Key--parameters","text":"modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . key: A key specification, e.g. \"a\" , \"Tab\" , \"Return\" , \"space\" . commands: One or more :class: LazyCall objects to evaluate in sequence upon keypress. Multiple commands should be separated by commas. desc: Description to be added to the key binding. (Optional) Source code in libqtile/config.py 72 73 74 75 76 77 78 def __init__ ( self , modifiers : list [ str ], key : str , * commands : LazyCall , desc : str = \"\" ) -> None : self . modifiers = modifiers self . key = key self . commands = commands self . desc = desc","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.KeyChord","text":"Define a key chord aka Vim-like mode.","title":"KeyChord"},{"location":"reference/libqtile/config/#libqtile.config.KeyChord--parameters","text":"modifiers: A list of modifier specifications. Modifier specifications are one of: \"shift\" , \"lock\" , \"control\" , \"mod1\" , \"mod2\" , \"mod3\" , \"mod4\" , \"mod5\" . key: A key specification, e.g. \"a\" , \"Tab\" , \"Return\" , \"space\" . submappings: A list of :class: Key or :class: KeyChord declarations to bind in this chord. mode: Boolean. Setting to True will result in the chord persisting until Escape is pressed. Setting to False (default) will exit the chord once the sequence has ended. name: A string to name the chord. The name will be displayed in the Chord widget. desc: A string to describe the chord. This attribute is not directly used by Qtile but users may want to access this when creating scripts to show configured keybindings. Source code in libqtile/config.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def __init__ ( self , modifiers : list [ str ], key : str , submappings : list [ Key | KeyChord ], mode : bool | str = False , name : str = \"\" , desc : str = \"\" , ): self . modifiers = modifiers self . key = key submappings . append ( Key ([], \"Escape\" )) self . submappings = submappings self . mode = mode self . name = name self . desc = desc if isinstance ( mode , str ): logger . warning ( \"The use of `mode` to set the KeyChord name is deprecated. \" \"Please use `name=' %s '` instead. \" \"'mode' should be a boolean value to set whether the chord is persistent (True) or not.\" , mode , ) self . name = mode self . mode = True","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.Match","text":"Match for dynamic groups or auto-floating windows. For some properties, :class: Match supports both regular expression objects (i.e. the result of re.compile() ) or strings (match as an \"include\"-match). If a window matches all specified values, it is considered a match.","title":"Match"},{"location":"reference/libqtile/config/#libqtile.config.Match--parameters","text":"title: Match against the WM_NAME atom (X11) or title (Wayland). wm_class: Match against the second string in WM_CLASS atom (X11) or app ID (Wayland). role: Match against the WM_ROLE atom (X11 only). wm_type: Match against the WM_TYPE atom (X11 only). wm_instance_class: Match against the first string in WM_CLASS atom (X11) or app ID (Wayland). net_wm_pid: Match against the _NET_WM_PID atom (X11) or PID (Wayland). func: Delegate the match to the given function, which receives the tested client as an argument and must return True if it matches, False otherwise. wid: Match against the window ID. Source code in libqtile/config.py 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 def __init__ ( self , title : str | re . Pattern | None = None , wm_class : str | re . Pattern | None = None , role : str | re . Pattern | None = None , wm_type : str | re . Pattern | None = None , wm_instance_class : str | re . Pattern | None = None , net_wm_pid : int | None = None , func : Callable [[ base . Window ], bool ] | None = None , wid : int | None = None , ) -> None : self . _rules : dict [ str , Any ] = {} if title is not None : self . _rules [ \"title\" ] = title if wm_class is not None : self . _rules [ \"wm_class\" ] = wm_class if wm_instance_class is not None : self . _rules [ \"wm_instance_class\" ] = wm_instance_class if wid is not None : self . _rules [ \"wid\" ] = wid if net_wm_pid is not None : try : self . _rules [ \"net_wm_pid\" ] = int ( net_wm_pid ) except ValueError : error = 'Invalid rule for net_wm_pid: \" %s \" only int allowed' % str ( net_wm_pid ) raise utils . QtileError ( error ) if func is not None : self . _rules [ \"func\" ] = func if role is not None : self . _rules [ \"role\" ] = role if wm_type is not None : self . _rules [ \"wm_type\" ] = wm_type","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.Match.map","text":"Apply callback to each client that matches this Match Source code in libqtile/config.py 887 888 889 890 891 def map ( self , callback : Callable [[ base . Window ], Any ], clients : list [ base . Window ]) -> None : \"\"\"Apply callback to each client that matches this Match\"\"\" for c in clients : if self . compare ( c ): callback ( c )","title":"map()"},{"location":"reference/libqtile/config/#libqtile.config.Rule","text":"How to act on a match. A :class: Rule contains a list of :class: Match objects, and a specification about what to do when any of them is matched.","title":"Rule"},{"location":"reference/libqtile/config/#libqtile.config.Rule--parameters","text":"match: :class: Match object or a list of such associated with this rule. float: Should we auto float this window? intrusive: Should we override the group's exclusive setting? break_on_match: Should we stop applying rules if this rule is matched? Source code in libqtile/config.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 def __init__ ( self , match : Match | list [ Match ], group : _Group | None = None , float : bool = False , intrusive : bool = False , break_on_match : bool = True , ) -> None : if isinstance ( match , Match ): self . matchlist = [ match ] else : self . matchlist = match self . group = group self . float = float self . intrusive = intrusive self . break_on_match = break_on_match","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.ScratchPad","text":"Bases: Group Represents a \"ScratchPad\" group ScratchPad adds a (by default) invisible group to Qtile. That group is used as a place for currently not visible windows spawned by a :class: DropDown configuration.","title":"ScratchPad"},{"location":"reference/libqtile/config/#libqtile.config.ScratchPad--parameters","text":"name: The name of this group. dropdowns: :class: DropDown s available on the scratchpad. position: The position of this group. label: The display name of the :class: ScratchPad group. Defaults to the empty string such that the group is hidden in :class: ~libqtile.widget.GroupBox widget. single: If True , only one of the dropdowns will be visible at a time. Source code in libqtile/config.py 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 def __init__ ( self , name : str , dropdowns : list [ DropDown ] | None = None , position : int = sys . maxsize , label : str = \"\" , single : bool = False , ) -> None : Group . __init__ ( self , name , layout = \"floating\" , init = False , position = position , label = label , ) self . dropdowns = dropdowns if dropdowns is not None else [] self . single = single","title":"Parameters"},{"location":"reference/libqtile/config/#libqtile.config.Screen","text":"Bases: CommandObject A physical screen, and its associated paraphernalia. Define a screen with a given set of :class: Bar s of a specific geometry. Also, x , y , width , and height aren't specified usually unless you are using 'fake screens'. The wallpaper parameter, if given, should be a path to an image file. How this image is painted to the screen is specified by the wallpaper_mode parameter. By default, the image will be placed at the screens origin and retain its own dimensions. If the mode is \"fill\" , the image will be centred on the screen and resized to fill it. If the mode is \"stretch\" , the image is stretched to fit all of it into the screen. Source code in libqtile/config.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def __init__ ( self , top : BarType | None = None , bottom : BarType | None = None , left : BarType | None = None , right : BarType | None = None , wallpaper : str | None = None , wallpaper_mode : str | None = None , x : int | None = None , y : int | None = None , width : int | None = None , height : int | None = None , ) -> None : self . top = top self . bottom = bottom self . left = left self . right = right self . wallpaper = wallpaper self . wallpaper_mode = wallpaper_mode self . qtile : Qtile | None = None # x position of upper left corner can be > 0 # if one screen is \"right\" of the other self . x = x if x is not None else 0 self . y = y if y is not None else 0 self . width = width if width is not None else 0 self . height = height if height is not None else 0 self . previous_group : _Group | None = None","title":"Screen"},{"location":"reference/libqtile/config/#libqtile.config.Screen.info","text":"Returns a dictionary of info for this screen. Source code in libqtile/config.py 592 593 594 595 @expose_command () def info ( self ) -> dict [ str , int ]: \"\"\"Returns a dictionary of info for this screen.\"\"\" return dict ( index = self . index , width = self . width , height = self . height , x = self . x , y = self . y )","title":"info()"},{"location":"reference/libqtile/config/#libqtile.config.Screen.next_group","text":"Switch to the next group Source code in libqtile/config.py 597 598 599 600 601 602 @expose_command () def next_group ( self , skip_empty : bool = False , skip_managed : bool = False ) -> None : \"\"\"Switch to the next group\"\"\" n = self . group . get_next_group ( skip_empty , skip_managed ) self . set_group ( n ) return n . name","title":"next_group()"},{"location":"reference/libqtile/config/#libqtile.config.Screen.prev_group","text":"Switch to the previous group Source code in libqtile/config.py 604 605 606 607 608 609 610 611 @expose_command () def prev_group ( self , skip_empty : bool = False , skip_managed : bool = False , warp : bool = True ) -> None : \"\"\"Switch to the previous group\"\"\" n = self . group . get_previous_group ( skip_empty , skip_managed ) self . set_group ( n , warp = warp ) return n . name","title":"prev_group()"},{"location":"reference/libqtile/config/#libqtile.config.Screen.set_group","text":"Put group on this screen Source code in libqtile/config.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def set_group ( self , new_group : _Group | None , save_prev : bool = True , warp : bool = True ) -> None : \"\"\"Put group on this screen\"\"\" if new_group is None : return if new_group . screen == self : return if save_prev and new_group is not self . group : # new_group can be self.group only if the screen is getting configured for # the first time self . previous_group = self . group if new_group . screen : # g1 <-> s1 (self) # g2 (new_group) <-> s2 to # g1 <-> s2 # g2 <-> s1 g1 = self . group s1 = self g2 = new_group s2 = new_group . screen s2 . group = g1 g1 . set_screen ( s2 , warp ) s1 . group = g2 g2 . set_screen ( s1 , warp ) else : assert self . qtile is not None old_group = self . group self . group = new_group with self . qtile . core . masked (): # display clients of the new group and then hide from old group # to remove the screen flickering new_group . set_screen ( self , warp ) # Can be the same group only if the screen just got configured for the # first time - see `Qtile._process_screens`. if old_group is not new_group : old_group . set_screen ( None , warp ) hook . fire ( \"setgroup\" ) hook . fire ( \"focus_change\" ) hook . fire ( \"layout_change\" , self . group . layouts [ self . group . current_layout ], self . group )","title":"set_group()"},{"location":"reference/libqtile/config/#libqtile.config.Screen.set_wallpaper","text":"Set the wallpaper to the given file. Source code in libqtile/config.py 620 621 622 623 @expose_command () def set_wallpaper ( self , path : str , mode : str | None = None ) -> None : \"\"\"Set the wallpaper to the given file.\"\"\" self . paint ( path , mode )","title":"set_wallpaper()"},{"location":"reference/libqtile/config/#libqtile.config.Screen.toggle_group","text":"Switch to the selected group or to the previously active one Source code in libqtile/config.py 613 614 615 616 617 618 @expose_command () def toggle_group ( self , group_name : str | None = None , warp : bool = True ) -> None : \"\"\"Switch to the selected group or to the previously active one\"\"\" assert self . qtile is not None group = self . qtile . groups_map . get ( group_name if group_name else \"\" ) self . _toggle_group ( group , warp = warp )","title":"toggle_group()"},{"location":"reference/libqtile/configurable/","text":"Configurable ( ** config ) Source code in libqtile/configurable.py 27 28 29 def __init__ ( self , ** config ): self . _variable_defaults = {} self . _user_config = config add_defaults ( defaults ) Add defaults to this object, overwriting any which already exist Source code in libqtile/configurable.py 31 32 33 34 35 36 37 def add_defaults ( self , defaults ): \"\"\"Add defaults to this object, overwriting any which already exist\"\"\" # Since we can't check for immutability reliably, shallow copy the # value. If a mutable value were set and it were changed in one place # it would affect all other instances, since this is typically called # on __init__ self . _variable_defaults . update (( d [ 0 ], copy . copy ( d [ 1 ])) for d in defaults ) ExtraFallback ( name , fallback ) Adds another layer of fallback to attributes Used to look up a different attribute name Source code in libqtile/configurable.py 67 68 69 70 def __init__ ( self , name , fallback ): self . name = name self . hidden_attribute = \"_\" + name self . fallback = fallback __set__ ( instance , value ) Set own value to a hidden attribute of the object Source code in libqtile/configurable.py 83 84 85 def __set__ ( self , instance , value ): \"\"\"Set own value to a hidden attribute of the object\"\"\" setattr ( instance , self . hidden_attribute , value )","title":"configurable"},{"location":"reference/libqtile/configurable/#libqtile.configurable.Configurable","text":"Source code in libqtile/configurable.py 27 28 29 def __init__ ( self , ** config ): self . _variable_defaults = {} self . _user_config = config","title":"Configurable"},{"location":"reference/libqtile/configurable/#libqtile.configurable.Configurable.add_defaults","text":"Add defaults to this object, overwriting any which already exist Source code in libqtile/configurable.py 31 32 33 34 35 36 37 def add_defaults ( self , defaults ): \"\"\"Add defaults to this object, overwriting any which already exist\"\"\" # Since we can't check for immutability reliably, shallow copy the # value. If a mutable value were set and it were changed in one place # it would affect all other instances, since this is typically called # on __init__ self . _variable_defaults . update (( d [ 0 ], copy . copy ( d [ 1 ])) for d in defaults )","title":"add_defaults()"},{"location":"reference/libqtile/configurable/#libqtile.configurable.ExtraFallback","text":"Adds another layer of fallback to attributes Used to look up a different attribute name Source code in libqtile/configurable.py 67 68 69 70 def __init__ ( self , name , fallback ): self . name = name self . hidden_attribute = \"_\" + name self . fallback = fallback","title":"ExtraFallback"},{"location":"reference/libqtile/configurable/#libqtile.configurable.ExtraFallback.__set__","text":"Set own value to a hidden attribute of the object Source code in libqtile/configurable.py 83 84 85 def __set__ ( self , instance , value ): \"\"\"Set own value to a hidden attribute of the object\"\"\" setattr ( instance , self . hidden_attribute , value )","title":"__set__()"},{"location":"reference/libqtile/confreader/","text":"Config ( file_path = None , ** settings ) Only attributes found in Config. annotations will be added to object. config attribute precedence is 1.) **settings 2.) self 3.) default_config Source code in libqtile/confreader.py 79 80 81 82 83 84 85 86 def __init__ ( self , file_path = None , ** settings ): \"\"\"Create a Config() object from settings Only attributes found in Config.__annotations__ will be added to object. config attribute precedence is 1.) **settings 2.) self 3.) default_config \"\"\" self . file_path = file_path self . update ( ** settings ) validate () Validate the configuration against the core. Source code in libqtile/confreader.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def validate ( self ) -> None : \"\"\" Validate the configuration against the core. \"\"\" valid_keys = core . get_keys () valid_mods = core . get_modifiers () # we explicitly do not want to set self.keys and self.mouse above, # because they are dynamically resolved from the default_config. so we # need to ignore the errors here about missing attributes. for k in self . keys : if k . key . lower () not in valid_keys : raise ConfigError ( \"No such key: %s \" % k . key ) for m in k . modifiers : if m . lower () not in valid_mods : raise ConfigError ( \"No such modifier: %s \" % m ) for ms in self . mouse : for m in ms . modifiers : if m . lower () not in valid_mods : raise ConfigError ( \"No such modifier: %s \" % m )","title":"confreader"},{"location":"reference/libqtile/confreader/#libqtile.confreader.Config","text":"Only attributes found in Config. annotations will be added to object. config attribute precedence is 1.) **settings 2.) self 3.) default_config Source code in libqtile/confreader.py 79 80 81 82 83 84 85 86 def __init__ ( self , file_path = None , ** settings ): \"\"\"Create a Config() object from settings Only attributes found in Config.__annotations__ will be added to object. config attribute precedence is 1.) **settings 2.) self 3.) default_config \"\"\" self . file_path = file_path self . update ( ** settings )","title":"Config"},{"location":"reference/libqtile/confreader/#libqtile.confreader.Config.validate","text":"Validate the configuration against the core. Source code in libqtile/confreader.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def validate ( self ) -> None : \"\"\" Validate the configuration against the core. \"\"\" valid_keys = core . get_keys () valid_mods = core . get_modifiers () # we explicitly do not want to set self.keys and self.mouse above, # because they are dynamically resolved from the default_config. so we # need to ignore the errors here about missing attributes. for k in self . keys : if k . key . lower () not in valid_keys : raise ConfigError ( \"No such key: %s \" % k . key ) for m in k . modifiers : if m . lower () not in valid_mods : raise ConfigError ( \"No such modifier: %s \" % m ) for ms in self . mouse : for m in ms . modifiers : if m . lower () not in valid_mods : raise ConfigError ( \"No such modifier: %s \" % m )","title":"validate()"},{"location":"reference/libqtile/dgroups/","text":"DGroups ( qtile , dgroups , key_binder = None , delay = 1 ) Dynamic Groups Source code in libqtile/dgroups.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __init__ ( self , qtile , dgroups , key_binder = None , delay = 1 ): self . qtile = qtile self . groups = dgroups self . groups_map = {} self . rules = [] self . rules_map = {} self . last_rule_id = 0 for rule in getattr ( qtile . config , \"dgroups_app_rules\" , []): self . add_rule ( rule ) self . keys = [] self . key_binder = key_binder self . _setup_hooks () self . _setup_groups () self . delay = delay self . timeout = {} simple_key_binder ( mod , keynames = None ) Bind keys to mod+group position or to the keys specified as second argument Source code in libqtile/dgroups.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def simple_key_binder ( mod , keynames = None ): \"\"\"Bind keys to mod+group position or to the keys specified as second argument\"\"\" def func ( dgroup ): # unbind all for key in dgroup . keys [:]: dgroup . qtile . ungrab_key ( key ) dgroup . keys . remove ( key ) if keynames : keys = keynames else : # keys 1 to 9 and 0 keys = list ( map ( str , list ( range ( 1 , 10 )) + [ 0 ])) # bind all keys for keyname , group in zip ( keys , dgroup . qtile . groups ): name = group . name key = Key ([ mod ], keyname , lazy . group [ name ] . toscreen ()) key_s = Key ([ mod , \"shift\" ], keyname , lazy . window . togroup ( name )) key_c = Key ([ mod , \"control\" ], keyname , lazy . group . switch_groups ( name )) dgroup . keys . append ( key ) dgroup . keys . append ( key_s ) dgroup . keys . append ( key_c ) dgroup . qtile . grab_key ( key ) dgroup . qtile . grab_key ( key_s ) dgroup . qtile . grab_key ( key_c ) return func","title":"dgroups"},{"location":"reference/libqtile/dgroups/#libqtile.dgroups.DGroups","text":"Dynamic Groups Source code in libqtile/dgroups.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __init__ ( self , qtile , dgroups , key_binder = None , delay = 1 ): self . qtile = qtile self . groups = dgroups self . groups_map = {} self . rules = [] self . rules_map = {} self . last_rule_id = 0 for rule in getattr ( qtile . config , \"dgroups_app_rules\" , []): self . add_rule ( rule ) self . keys = [] self . key_binder = key_binder self . _setup_hooks () self . _setup_groups () self . delay = delay self . timeout = {}","title":"DGroups"},{"location":"reference/libqtile/dgroups/#libqtile.dgroups.simple_key_binder","text":"Bind keys to mod+group position or to the keys specified as second argument Source code in libqtile/dgroups.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def simple_key_binder ( mod , keynames = None ): \"\"\"Bind keys to mod+group position or to the keys specified as second argument\"\"\" def func ( dgroup ): # unbind all for key in dgroup . keys [:]: dgroup . qtile . ungrab_key ( key ) dgroup . keys . remove ( key ) if keynames : keys = keynames else : # keys 1 to 9 and 0 keys = list ( map ( str , list ( range ( 1 , 10 )) + [ 0 ])) # bind all keys for keyname , group in zip ( keys , dgroup . qtile . groups ): name = group . name key = Key ([ mod ], keyname , lazy . group [ name ] . toscreen ()) key_s = Key ([ mod , \"shift\" ], keyname , lazy . window . togroup ( name )) key_c = Key ([ mod , \"control\" ], keyname , lazy . group . switch_groups ( name )) dgroup . keys . append ( key ) dgroup . keys . append ( key_s ) dgroup . keys . append ( key_c ) dgroup . qtile . grab_key ( key ) dgroup . qtile . grab_key ( key_s ) dgroup . qtile . grab_key ( key_c ) return func","title":"simple_key_binder()"},{"location":"reference/libqtile/drawer/","text":"","title":"drawer"},{"location":"reference/libqtile/group/","text":"","title":"group"},{"location":"reference/libqtile/hook/","text":"Subscribe () Source code in libqtile/hook.py 48 49 50 51 52 53 def __init__ ( self ): hooks = set ([]) for i in dir ( self ): if not i . startswith ( \"_\" ): hooks . add ( i ) self . hooks = hooks addgroup ( func ) Called when group is added Arguments * name of new group Source code in libqtile/hook.py 118 119 120 121 122 123 124 125 def addgroup ( self , func ): \"\"\"Called when group is added **Arguments** * name of new group \"\"\" return self . _subscribe ( \"addgroup\" , func ) changegroup ( func ) Called whenever a group change occurs Arguments None Source code in libqtile/hook.py 136 137 138 139 140 141 142 143 def changegroup ( self , func ): \"\"\"Called whenever a group change occurs **Arguments** None \"\"\" return self . _subscribe ( \"changegroup\" , func ) client_focus ( func ) Called whenever focus moves to a client window Arguments * ``Window`` object of the new focus. Source code in libqtile/hook.py 219 220 221 222 223 224 225 226 def client_focus ( self , func ): \"\"\"Called whenever focus moves to a client window **Arguments** * ``Window`` object of the new focus. \"\"\" return self . _subscribe ( \"client_focus\" , func ) client_killed ( func ) Called after a client has been unmanaged Arguments * ``Window`` object of the killed window. Source code in libqtile/hook.py 210 211 212 213 214 215 216 217 def client_killed ( self , func ): \"\"\"Called after a client has been unmanaged **Arguments** * ``Window`` object of the killed window. \"\"\" return self . _subscribe ( \"client_killed\" , func ) client_managed ( func ) Called after Qtile starts managing a new client Called after a window is assigned to a group, or when a window is made static. This hook is not called for internal windows. Arguments * ``Window`` object of the managed window Source code in libqtile/hook.py 198 199 200 201 202 203 204 205 206 207 208 def client_managed ( self , func ): \"\"\"Called after Qtile starts managing a new client Called after a window is assigned to a group, or when a window is made static. This hook is not called for internal windows. **Arguments** * ``Window`` object of the managed window \"\"\" return self . _subscribe ( \"client_managed\" , func ) client_mouse_enter ( func ) Called when the mouse enters a client Arguments * ``Window`` of window entered Source code in libqtile/hook.py 228 229 230 231 232 233 234 235 def client_mouse_enter ( self , func ): \"\"\"Called when the mouse enters a client **Arguments** * ``Window`` of window entered \"\"\" return self . _subscribe ( \"client_mouse_enter\" , func ) client_name_updated ( func ) Called when the client name changes Arguments * ``Window`` of client with updated name Source code in libqtile/hook.py 237 238 239 240 241 242 243 244 def client_name_updated ( self , func ): \"\"\"Called when the client name changes **Arguments** * ``Window`` of client with updated name \"\"\" return self . _subscribe ( \"client_name_updated\" , func ) client_new ( func ) Called before Qtile starts managing a new client Use this hook to declare windows static, or add them to a group on startup. This hook is not called for internal windows. Arguments * ``Window`` object Examples: :: @libqtile.hook.subscribe.client_new def func(c): if c.name == \"xterm\": c.togroup(\"a\") elif c.name == \"dzen\": c.static(0) Source code in libqtile/hook.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def client_new ( self , func ): \"\"\"Called before Qtile starts managing a new client Use this hook to declare windows static, or add them to a group on startup. This hook is not called for internal windows. **Arguments** * ``Window`` object Examples -------- :: @libqtile.hook.subscribe.client_new def func(c): if c.name == \"xterm\": c.togroup(\"a\") elif c.name == \"dzen\": c.static(0) \"\"\" return self . _subscribe ( \"client_new\" , func ) client_urgent_hint_changed ( func ) Called when the client urgent hint changes Arguments * ``Window`` of client with hint change Source code in libqtile/hook.py 246 247 248 249 250 251 252 253 def client_urgent_hint_changed ( self , func ): \"\"\"Called when the client urgent hint changes **Arguments** * ``Window`` of client with hint change \"\"\" return self . _subscribe ( \"client_urgent_hint_changed\" , func ) current_screen_change ( func ) Called when the current screen (i.e. the screen with focus) changes Arguments None Source code in libqtile/hook.py 316 317 318 319 320 321 322 323 def current_screen_change ( self , func ): \"\"\"Called when the current screen (i.e. the screen with focus) changes **Arguments** None \"\"\" return self . _subscribe ( \"current_screen_change\" , func ) delgroup ( func ) Called when group is deleted Arguments * name of deleted group Source code in libqtile/hook.py 127 128 129 130 131 132 133 134 def delgroup ( self , func ): \"\"\"Called when group is deleted **Arguments** * name of deleted group \"\"\" return self . _subscribe ( \"delgroup\" , func ) enter_chord ( func ) Called when key chord begins Arguments * name of chord(mode) Source code in libqtile/hook.py 325 326 327 328 329 330 331 332 def enter_chord ( self , func ): \"\"\"Called when key chord begins **Arguments** * name of chord(mode) \"\"\" return self . _subscribe ( \"enter_chord\" , func ) float_change ( func ) Called when a change in float state is made Arguments None Source code in libqtile/hook.py 155 156 157 158 159 160 161 162 def float_change ( self , func ): \"\"\"Called when a change in float state is made **Arguments** None \"\"\" return self . _subscribe ( \"float_change\" , func ) focus_change ( func ) Called when focus is changed, including moving focus between groups or when focus is lost completely Arguments None Source code in libqtile/hook.py 145 146 147 148 149 150 151 152 153 def focus_change ( self , func ): \"\"\"Called when focus is changed, including moving focus between groups or when focus is lost completely **Arguments** None \"\"\" return self . _subscribe ( \"focus_change\" , func ) group_window_add ( func ) Called when a new window is added to a group Arguments * ``Group`` receiving the new window * ``Window`` added to the group Source code in libqtile/hook.py 164 165 166 167 168 169 170 171 172 def group_window_add ( self , func ): \"\"\"Called when a new window is added to a group **Arguments** * ``Group`` receiving the new window * ``Window`` added to the group \"\"\" return self . _subscribe ( \"group_window_add\" , func ) layout_change ( func ) Called on layout change Arguments * layout object for new layout * group object on which layout is changed Source code in libqtile/hook.py 255 256 257 258 259 260 261 262 263 def layout_change ( self , func ): \"\"\"Called on layout change **Arguments** * layout object for new layout * group object on which layout is changed \"\"\" return self . _subscribe ( \"layout_change\" , func ) leave_chord ( func ) Called when key chord ends Arguments None Source code in libqtile/hook.py 334 335 336 337 338 339 340 341 def leave_chord ( self , func ): \"\"\"Called when key chord ends **Arguments** None \"\"\" return self . _subscribe ( \"leave_chord\" , func ) net_wm_icon_change ( func ) Called on _NET_WM_ICON chance Arguments * ``Window`` of client with changed icon Source code in libqtile/hook.py 265 266 267 268 269 270 271 272 def net_wm_icon_change ( self , func ): \"\"\"Called on `_NET_WM_ICON` chance **Arguments** * ``Window`` of client with changed icon \"\"\" return self . _subscribe ( \"net_wm_icon_change\" , func ) restart ( func ) Called before qtile is restarted Arguments None Source code in libqtile/hook.py 100 101 102 103 104 105 106 107 def restart ( self , func ): \"\"\"Called before qtile is restarted **Arguments** None \"\"\" return self . _subscribe ( \"restart\" , func ) resume ( func ) Called when system wakes up from sleep, suspend or hibernate. Relies on systemd's inhibitor dbus interface, via the dbus-next package. Note: the hook is not fired when resuming from shutdown/reboot events. Use the \"startup\" hooks for those scenarios. Arguments None Source code in libqtile/hook.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def resume ( self , func ): \"\"\" Called when system wakes up from sleep, suspend or hibernate. Relies on systemd's inhibitor dbus interface, via the dbus-next package. Note: the hook is not fired when resuming from shutdown/reboot events. Use the \"startup\" hooks for those scenarios. **Arguments** None \"\"\" return self . _subscribe ( \"resume\" , func ) screen_change ( func ) Called when the output configuration is changed (e.g. via randr in X11). Arguments * ``xproto.randr.ScreenChangeNotify`` event (X11) or None (Wayland). Source code in libqtile/hook.py 296 297 298 299 300 301 302 303 304 def screen_change ( self , func ): \"\"\"Called when the output configuration is changed (e.g. via randr in X11). **Arguments** * ``xproto.randr.ScreenChangeNotify`` event (X11) or None (Wayland). \"\"\" return self . _subscribe ( \"screen_change\" , func ) screens_reconfigured ( func ) Called once qtile.reconfigure_screens has completed (e.g. if reconfigure_screens is set to True in your config). Arguments None Source code in libqtile/hook.py 306 307 308 309 310 311 312 313 314 def screens_reconfigured ( self , func ): \"\"\"Called once ``qtile.reconfigure_screens`` has completed (e.g. if ``reconfigure_screens`` is set to ``True`` in your config). **Arguments** None \"\"\" return self . _subscribe ( \"screens_reconfigured\" , func ) selection_change ( func ) Called on selection change Arguments * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys Source code in libqtile/hook.py 285 286 287 288 289 290 291 292 293 294 def selection_change ( self , func ): \"\"\"Called on selection change **Arguments** * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys \"\"\" return self . _subscribe ( \"selection_change\" , func ) selection_notify ( func ) Called on selection notify Arguments * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys Source code in libqtile/hook.py 274 275 276 277 278 279 280 281 282 283 def selection_notify ( self , func ): \"\"\"Called on selection notify **Arguments** * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys \"\"\" return self . _subscribe ( \"selection_notify\" , func ) setgroup ( func ) Called when group is changed Arguments None Source code in libqtile/hook.py 109 110 111 112 113 114 115 116 def setgroup ( self , func ): \"\"\"Called when group is changed **Arguments** None \"\"\" return self . _subscribe ( \"setgroup\" , func ) shutdown ( func ) Called before qtile is shutdown Arguments None Source code in libqtile/hook.py 91 92 93 94 95 96 97 98 def shutdown ( self , func ): \"\"\"Called before qtile is shutdown **Arguments** None \"\"\" return self . _subscribe ( \"shutdown\" , func ) startup ( func ) Called when qtile is started Arguments None Source code in libqtile/hook.py 73 74 75 76 77 78 79 80 def startup ( self , func ): \"\"\"Called when qtile is started **Arguments** None \"\"\" return self . _subscribe ( \"startup\" , func ) startup_complete ( func ) Called when qtile is started after all resources initialized Arguments None Source code in libqtile/hook.py 82 83 84 85 86 87 88 89 def startup_complete ( self , func ): \"\"\"Called when qtile is started after all resources initialized **Arguments** None \"\"\" return self . _subscribe ( \"startup_complete\" , func ) startup_once ( func ) Called when Qtile has started on first start This hook is called exactly once per session (i.e. not on each lazy.restart() ). Arguments None Source code in libqtile/hook.py 61 62 63 64 65 66 67 68 69 70 71 def startup_once ( self , func ): \"\"\"Called when Qtile has started on first start This hook is called exactly once per session (i.e. not on each ``lazy.restart()``). **Arguments** None \"\"\" return self . _subscribe ( \"startup_once\" , func ) Unsubscribe Bases: Subscribe This class mirrors subscribe, except the _subscribe member has been overridden to removed calls from hooks.","title":"hook"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe","text":"Source code in libqtile/hook.py 48 49 50 51 52 53 def __init__ ( self ): hooks = set ([]) for i in dir ( self ): if not i . startswith ( \"_\" ): hooks . add ( i ) self . hooks = hooks","title":"Subscribe"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.addgroup","text":"Called when group is added Arguments * name of new group Source code in libqtile/hook.py 118 119 120 121 122 123 124 125 def addgroup ( self , func ): \"\"\"Called when group is added **Arguments** * name of new group \"\"\" return self . _subscribe ( \"addgroup\" , func )","title":"addgroup()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.changegroup","text":"Called whenever a group change occurs Arguments None Source code in libqtile/hook.py 136 137 138 139 140 141 142 143 def changegroup ( self , func ): \"\"\"Called whenever a group change occurs **Arguments** None \"\"\" return self . _subscribe ( \"changegroup\" , func )","title":"changegroup()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_focus","text":"Called whenever focus moves to a client window Arguments * ``Window`` object of the new focus. Source code in libqtile/hook.py 219 220 221 222 223 224 225 226 def client_focus ( self , func ): \"\"\"Called whenever focus moves to a client window **Arguments** * ``Window`` object of the new focus. \"\"\" return self . _subscribe ( \"client_focus\" , func )","title":"client_focus()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_killed","text":"Called after a client has been unmanaged Arguments * ``Window`` object of the killed window. Source code in libqtile/hook.py 210 211 212 213 214 215 216 217 def client_killed ( self , func ): \"\"\"Called after a client has been unmanaged **Arguments** * ``Window`` object of the killed window. \"\"\" return self . _subscribe ( \"client_killed\" , func )","title":"client_killed()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_managed","text":"Called after Qtile starts managing a new client Called after a window is assigned to a group, or when a window is made static. This hook is not called for internal windows. Arguments * ``Window`` object of the managed window Source code in libqtile/hook.py 198 199 200 201 202 203 204 205 206 207 208 def client_managed ( self , func ): \"\"\"Called after Qtile starts managing a new client Called after a window is assigned to a group, or when a window is made static. This hook is not called for internal windows. **Arguments** * ``Window`` object of the managed window \"\"\" return self . _subscribe ( \"client_managed\" , func )","title":"client_managed()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_mouse_enter","text":"Called when the mouse enters a client Arguments * ``Window`` of window entered Source code in libqtile/hook.py 228 229 230 231 232 233 234 235 def client_mouse_enter ( self , func ): \"\"\"Called when the mouse enters a client **Arguments** * ``Window`` of window entered \"\"\" return self . _subscribe ( \"client_mouse_enter\" , func )","title":"client_mouse_enter()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_name_updated","text":"Called when the client name changes Arguments * ``Window`` of client with updated name Source code in libqtile/hook.py 237 238 239 240 241 242 243 244 def client_name_updated ( self , func ): \"\"\"Called when the client name changes **Arguments** * ``Window`` of client with updated name \"\"\" return self . _subscribe ( \"client_name_updated\" , func )","title":"client_name_updated()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_new","text":"Called before Qtile starts managing a new client Use this hook to declare windows static, or add them to a group on startup. This hook is not called for internal windows. Arguments * ``Window`` object Examples: :: @libqtile.hook.subscribe.client_new def func(c): if c.name == \"xterm\": c.togroup(\"a\") elif c.name == \"dzen\": c.static(0) Source code in libqtile/hook.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def client_new ( self , func ): \"\"\"Called before Qtile starts managing a new client Use this hook to declare windows static, or add them to a group on startup. This hook is not called for internal windows. **Arguments** * ``Window`` object Examples -------- :: @libqtile.hook.subscribe.client_new def func(c): if c.name == \"xterm\": c.togroup(\"a\") elif c.name == \"dzen\": c.static(0) \"\"\" return self . _subscribe ( \"client_new\" , func )","title":"client_new()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.client_urgent_hint_changed","text":"Called when the client urgent hint changes Arguments * ``Window`` of client with hint change Source code in libqtile/hook.py 246 247 248 249 250 251 252 253 def client_urgent_hint_changed ( self , func ): \"\"\"Called when the client urgent hint changes **Arguments** * ``Window`` of client with hint change \"\"\" return self . _subscribe ( \"client_urgent_hint_changed\" , func )","title":"client_urgent_hint_changed()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.current_screen_change","text":"Called when the current screen (i.e. the screen with focus) changes Arguments None Source code in libqtile/hook.py 316 317 318 319 320 321 322 323 def current_screen_change ( self , func ): \"\"\"Called when the current screen (i.e. the screen with focus) changes **Arguments** None \"\"\" return self . _subscribe ( \"current_screen_change\" , func )","title":"current_screen_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.delgroup","text":"Called when group is deleted Arguments * name of deleted group Source code in libqtile/hook.py 127 128 129 130 131 132 133 134 def delgroup ( self , func ): \"\"\"Called when group is deleted **Arguments** * name of deleted group \"\"\" return self . _subscribe ( \"delgroup\" , func )","title":"delgroup()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.enter_chord","text":"Called when key chord begins Arguments * name of chord(mode) Source code in libqtile/hook.py 325 326 327 328 329 330 331 332 def enter_chord ( self , func ): \"\"\"Called when key chord begins **Arguments** * name of chord(mode) \"\"\" return self . _subscribe ( \"enter_chord\" , func )","title":"enter_chord()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.float_change","text":"Called when a change in float state is made Arguments None Source code in libqtile/hook.py 155 156 157 158 159 160 161 162 def float_change ( self , func ): \"\"\"Called when a change in float state is made **Arguments** None \"\"\" return self . _subscribe ( \"float_change\" , func )","title":"float_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.focus_change","text":"Called when focus is changed, including moving focus between groups or when focus is lost completely Arguments None Source code in libqtile/hook.py 145 146 147 148 149 150 151 152 153 def focus_change ( self , func ): \"\"\"Called when focus is changed, including moving focus between groups or when focus is lost completely **Arguments** None \"\"\" return self . _subscribe ( \"focus_change\" , func )","title":"focus_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.group_window_add","text":"Called when a new window is added to a group Arguments * ``Group`` receiving the new window * ``Window`` added to the group Source code in libqtile/hook.py 164 165 166 167 168 169 170 171 172 def group_window_add ( self , func ): \"\"\"Called when a new window is added to a group **Arguments** * ``Group`` receiving the new window * ``Window`` added to the group \"\"\" return self . _subscribe ( \"group_window_add\" , func )","title":"group_window_add()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.layout_change","text":"Called on layout change Arguments * layout object for new layout * group object on which layout is changed Source code in libqtile/hook.py 255 256 257 258 259 260 261 262 263 def layout_change ( self , func ): \"\"\"Called on layout change **Arguments** * layout object for new layout * group object on which layout is changed \"\"\" return self . _subscribe ( \"layout_change\" , func )","title":"layout_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.leave_chord","text":"Called when key chord ends Arguments None Source code in libqtile/hook.py 334 335 336 337 338 339 340 341 def leave_chord ( self , func ): \"\"\"Called when key chord ends **Arguments** None \"\"\" return self . _subscribe ( \"leave_chord\" , func )","title":"leave_chord()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.net_wm_icon_change","text":"Called on _NET_WM_ICON chance Arguments * ``Window`` of client with changed icon Source code in libqtile/hook.py 265 266 267 268 269 270 271 272 def net_wm_icon_change ( self , func ): \"\"\"Called on `_NET_WM_ICON` chance **Arguments** * ``Window`` of client with changed icon \"\"\" return self . _subscribe ( \"net_wm_icon_change\" , func )","title":"net_wm_icon_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.restart","text":"Called before qtile is restarted Arguments None Source code in libqtile/hook.py 100 101 102 103 104 105 106 107 def restart ( self , func ): \"\"\"Called before qtile is restarted **Arguments** None \"\"\" return self . _subscribe ( \"restart\" , func )","title":"restart()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.resume","text":"Called when system wakes up from sleep, suspend or hibernate. Relies on systemd's inhibitor dbus interface, via the dbus-next package. Note: the hook is not fired when resuming from shutdown/reboot events. Use the \"startup\" hooks for those scenarios. Arguments None Source code in libqtile/hook.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def resume ( self , func ): \"\"\" Called when system wakes up from sleep, suspend or hibernate. Relies on systemd's inhibitor dbus interface, via the dbus-next package. Note: the hook is not fired when resuming from shutdown/reboot events. Use the \"startup\" hooks for those scenarios. **Arguments** None \"\"\" return self . _subscribe ( \"resume\" , func )","title":"resume()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.screen_change","text":"Called when the output configuration is changed (e.g. via randr in X11). Arguments * ``xproto.randr.ScreenChangeNotify`` event (X11) or None (Wayland). Source code in libqtile/hook.py 296 297 298 299 300 301 302 303 304 def screen_change ( self , func ): \"\"\"Called when the output configuration is changed (e.g. via randr in X11). **Arguments** * ``xproto.randr.ScreenChangeNotify`` event (X11) or None (Wayland). \"\"\" return self . _subscribe ( \"screen_change\" , func )","title":"screen_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.screens_reconfigured","text":"Called once qtile.reconfigure_screens has completed (e.g. if reconfigure_screens is set to True in your config). Arguments None Source code in libqtile/hook.py 306 307 308 309 310 311 312 313 314 def screens_reconfigured ( self , func ): \"\"\"Called once ``qtile.reconfigure_screens`` has completed (e.g. if ``reconfigure_screens`` is set to ``True`` in your config). **Arguments** None \"\"\" return self . _subscribe ( \"screens_reconfigured\" , func )","title":"screens_reconfigured()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.selection_change","text":"Called on selection change Arguments * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys Source code in libqtile/hook.py 285 286 287 288 289 290 291 292 293 294 def selection_change ( self , func ): \"\"\"Called on selection change **Arguments** * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys \"\"\" return self . _subscribe ( \"selection_change\" , func )","title":"selection_change()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.selection_notify","text":"Called on selection notify Arguments * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys Source code in libqtile/hook.py 274 275 276 277 278 279 280 281 282 283 def selection_notify ( self , func ): \"\"\"Called on selection notify **Arguments** * name of the selection * dictionary describing selection, containing ``owner`` and ``selection`` as keys \"\"\" return self . _subscribe ( \"selection_notify\" , func )","title":"selection_notify()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.setgroup","text":"Called when group is changed Arguments None Source code in libqtile/hook.py 109 110 111 112 113 114 115 116 def setgroup ( self , func ): \"\"\"Called when group is changed **Arguments** None \"\"\" return self . _subscribe ( \"setgroup\" , func )","title":"setgroup()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.shutdown","text":"Called before qtile is shutdown Arguments None Source code in libqtile/hook.py 91 92 93 94 95 96 97 98 def shutdown ( self , func ): \"\"\"Called before qtile is shutdown **Arguments** None \"\"\" return self . _subscribe ( \"shutdown\" , func )","title":"shutdown()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.startup","text":"Called when qtile is started Arguments None Source code in libqtile/hook.py 73 74 75 76 77 78 79 80 def startup ( self , func ): \"\"\"Called when qtile is started **Arguments** None \"\"\" return self . _subscribe ( \"startup\" , func )","title":"startup()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.startup_complete","text":"Called when qtile is started after all resources initialized Arguments None Source code in libqtile/hook.py 82 83 84 85 86 87 88 89 def startup_complete ( self , func ): \"\"\"Called when qtile is started after all resources initialized **Arguments** None \"\"\" return self . _subscribe ( \"startup_complete\" , func )","title":"startup_complete()"},{"location":"reference/libqtile/hook/#libqtile.hook.Subscribe.startup_once","text":"Called when Qtile has started on first start This hook is called exactly once per session (i.e. not on each lazy.restart() ). Arguments None Source code in libqtile/hook.py 61 62 63 64 65 66 67 68 69 70 71 def startup_once ( self , func ): \"\"\"Called when Qtile has started on first start This hook is called exactly once per session (i.e. not on each ``lazy.restart()``). **Arguments** None \"\"\" return self . _subscribe ( \"startup_once\" , func )","title":"startup_once()"},{"location":"reference/libqtile/hook/#libqtile.hook.Unsubscribe","text":"Bases: Subscribe This class mirrors subscribe, except the _subscribe member has been overridden to removed calls from hooks.","title":"Unsubscribe"},{"location":"reference/libqtile/images/","text":"Img ( bytes_img , name = '' , path = '' ) Img is a class which creates & manipulates cairo SurfacePatterns from an image There are two constructors Img(...) and Img.from_path(...) The cairo surface pattern is at img.pattern. Changing any of the attributes width, height, or theta will update the pattern. width :: pattern width in pixels height :: pattern height in pixels theta :: rotation of pattern counter clockwise in degrees Pattern is first stretched, then rotated. Source code in libqtile/images.py 166 167 168 169 def __init__ ( self , bytes_img , name = \"\" , path = \"\" ): self . bytes_img = bytes_img self . name = name self . path = path from_path ( image_path ) classmethod Create an Img instance from image_path Source code in libqtile/images.py 179 180 181 182 183 184 185 186 @classmethod def from_path ( cls , image_path ): \"Create an Img instance from image_path\" with open ( image_path , \"rb\" ) as fobj : bytes_img = fobj . read () name = os . path . basename ( image_path ) name , file_type = os . path . splitext ( name ) return cls ( bytes_img , name = name , path = image_path ) Loader ( * directories , ** kwargs ) Loader - create Img() instances from image names load icons with Loader e.g., ldr = Loader('/usr/share/icons/Adwaita/24x24', '/usr/share/icons/Adwaita') d_loaded_images = ldr('audio-volume-muted', 'audio-volume-low') Source code in libqtile/images.py 316 317 318 319 def __init__ ( self , * directories , ** kwargs ): for k , v in kwargs . items (): setattr ( self , k , v ) self . directories = list ( directories ) get_cairo_pattern ( surface , width = None , height = None , theta = 0.0 ) Return a SurfacePattern from an ImageSurface. if width and height are not None scale the pattern to be size width and height. theta is in degrees ccw Source code in libqtile/images.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_cairo_pattern ( surface , width = None , height = None , theta = 0.0 ): \"\"\"Return a SurfacePattern from an ImageSurface. if width and height are not None scale the pattern to be size width and height. theta is in degrees ccw \"\"\" pattern = cairocffi . SurfacePattern ( surface ) pattern . set_filter ( cairocffi . FILTER_BEST ) matrix = cairocffi . Matrix () tr_width , tr_height = 1.0 , 1.0 surf_width , surf_height = surface . get_width (), surface . get_height () if ( width is not None ) and ( width != surf_width ): tr_width = surf_width / width if ( height is not None ) and ( height != surf_height ): tr_height = surf_height / height matrix . scale ( tr_width , tr_height ) epsilon = 1.0e-6 pi = 3.141592653589793 if abs ( theta ) > epsilon : theta_rad = pi / 180.0 * theta mat_rot = cairocffi . Matrix () # https://cairographics.org/cookbook/transform_about_point/ xt = surf_width * tr_width * 0.5 yt = surf_height * tr_height * 0.5 mat_rot . translate ( xt , yt ) mat_rot . rotate ( theta_rad ) mat_rot . translate ( - xt , - yt ) matrix = mat_rot . multiply ( matrix ) pattern . set_matrix ( matrix ) return pattern","title":"images"},{"location":"reference/libqtile/images/#libqtile.images.Img","text":"Img is a class which creates & manipulates cairo SurfacePatterns from an image There are two constructors Img(...) and Img.from_path(...) The cairo surface pattern is at img.pattern. Changing any of the attributes width, height, or theta will update the pattern. width :: pattern width in pixels height :: pattern height in pixels theta :: rotation of pattern counter clockwise in degrees Pattern is first stretched, then rotated. Source code in libqtile/images.py 166 167 168 169 def __init__ ( self , bytes_img , name = \"\" , path = \"\" ): self . bytes_img = bytes_img self . name = name self . path = path","title":"Img"},{"location":"reference/libqtile/images/#libqtile.images.Img.from_path","text":"Create an Img instance from image_path Source code in libqtile/images.py 179 180 181 182 183 184 185 186 @classmethod def from_path ( cls , image_path ): \"Create an Img instance from image_path\" with open ( image_path , \"rb\" ) as fobj : bytes_img = fobj . read () name = os . path . basename ( image_path ) name , file_type = os . path . splitext ( name ) return cls ( bytes_img , name = name , path = image_path )","title":"from_path()"},{"location":"reference/libqtile/images/#libqtile.images.Loader","text":"Loader - create Img() instances from image names load icons with Loader e.g., ldr = Loader('/usr/share/icons/Adwaita/24x24', '/usr/share/icons/Adwaita') d_loaded_images = ldr('audio-volume-muted', 'audio-volume-low') Source code in libqtile/images.py 316 317 318 319 def __init__ ( self , * directories , ** kwargs ): for k , v in kwargs . items (): setattr ( self , k , v ) self . directories = list ( directories )","title":"Loader"},{"location":"reference/libqtile/images/#libqtile.images.get_cairo_pattern","text":"Return a SurfacePattern from an ImageSurface. if width and height are not None scale the pattern to be size width and height. theta is in degrees ccw Source code in libqtile/images.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_cairo_pattern ( surface , width = None , height = None , theta = 0.0 ): \"\"\"Return a SurfacePattern from an ImageSurface. if width and height are not None scale the pattern to be size width and height. theta is in degrees ccw \"\"\" pattern = cairocffi . SurfacePattern ( surface ) pattern . set_filter ( cairocffi . FILTER_BEST ) matrix = cairocffi . Matrix () tr_width , tr_height = 1.0 , 1.0 surf_width , surf_height = surface . get_width (), surface . get_height () if ( width is not None ) and ( width != surf_width ): tr_width = surf_width / width if ( height is not None ) and ( height != surf_height ): tr_height = surf_height / height matrix . scale ( tr_width , tr_height ) epsilon = 1.0e-6 pi = 3.141592653589793 if abs ( theta ) > epsilon : theta_rad = pi / 180.0 * theta mat_rot = cairocffi . Matrix () # https://cairographics.org/cookbook/transform_about_point/ xt = surf_width * tr_width * 0.5 yt = surf_height * tr_height * 0.5 mat_rot . translate ( xt , yt ) mat_rot . rotate ( theta_rad ) mat_rot . translate ( - xt , - yt ) matrix = mat_rot . multiply ( matrix ) pattern . set_matrix ( matrix ) return pattern","title":"get_cairo_pattern()"},{"location":"reference/libqtile/ipc/","text":"A simple IPC mechanism for communicating between two local processes. We use marshal to serialize data - this means that both client and server must run the same Python version, and that clients must be trusted (as un-marshalling untrusted data can result in arbitrary code execution). Client ( socket_path , is_json = False ) Parameters: Name Type Description Default socket_path str The file path to the file that is used to open the connection to the running IPC server. required is_json Pack and unpack messages as json False Source code in libqtile/ipc.py 148 149 150 151 152 153 154 155 156 157 158 159 160 def __init__ ( self , socket_path : str , is_json = False ) -> None : \"\"\"Create a new IPC client Parameters ---------- socket_path: str The file path to the file that is used to open the connection to the running IPC server. is_json: bool Pack and unpack messages as json \"\"\" self . socket_path = socket_path self . is_json = is_json async_send ( msg ) async Send the message to the server Connect to the server, then pack and send the message to the server, then wait for and return the response from the server. Source code in libqtile/ipc.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 async def async_send ( self , msg : Any ) -> Any : \"\"\"Send the message to the server Connect to the server, then pack and send the message to the server, then wait for and return the response from the server. \"\"\" try : reader , writer = await asyncio . wait_for ( asyncio . open_unix_connection ( path = self . socket_path ), timeout = 3 ) except ( ConnectionRefusedError , FileNotFoundError ): raise IPCError ( \"Could not open {} \" . format ( self . socket_path )) try : send_data = _IPC . pack ( msg , is_json = self . is_json ) writer . write ( send_data ) writer . write_eof () read_data = await asyncio . wait_for ( reader . read (), timeout = 10 ) except asyncio . TimeoutError : raise IPCError ( \"Server not responding\" ) finally : # see the note in Server._server_callback() writer . close () await writer . wait_closed () data , _ = _IPC . unpack ( read_data , is_json = self . is_json ) return data send ( msg ) Send the message and return the response from the server If any exception is raised by the server, that will propogate out of this call. Source code in libqtile/ipc.py 165 166 167 168 169 170 171 def send ( self , msg : Any ) -> Any : \"\"\"Send the message and return the response from the server If any exception is raised by the server, that will propogate out of this call. \"\"\" return asyncio . run ( self . async_send ( msg )) Server ( socket_path , handler ) Source code in libqtile/ipc.py 205 206 207 208 209 210 211 212 213 214 215 216 def __init__ ( self , socket_path : str , handler ) -> None : self . socket_path = socket_path self . handler = handler self . server = None # type: asyncio.AbstractServer | None if os . path . exists ( socket_path ): os . unlink ( socket_path ) self . sock = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM , 0 ) flags = fcntl . fcntl ( self . sock . fileno (), fcntl . F_GETFD ) fcntl . fcntl ( self . sock . fileno (), fcntl . F_SETFD , flags | fcntl . FD_CLOEXEC ) self . sock . bind ( self . socket_path ) __aenter__ () async Start and return the server Source code in libqtile/ipc.py 247 248 249 250 async def __aenter__ ( self ) -> \"Server\" : \"\"\"Start and return the server\"\"\" await self . start () return self __aexit__ ( _exc_type , _exc_value , _tb ) async Close and shutdown the server Source code in libqtile/ipc.py 252 253 254 async def __aexit__ ( self , _exc_type , _exc_value , _tb ) -> None : \"\"\"Close and shutdown the server\"\"\" await self . close () close () async Close and shutdown the server Source code in libqtile/ipc.py 264 265 266 267 268 269 270 271 272 async def close ( self ) -> None : \"\"\"Close and shutdown the server\"\"\" assert self . server is not None logger . debug ( \"Stopping server on close\" ) self . server . close () await self . server . wait_closed () self . server = None start () async Start the server Source code in libqtile/ipc.py 256 257 258 259 260 261 262 async def start ( self ) -> None : \"\"\"Start the server\"\"\" assert self . server is None logger . debug ( \"Starting server\" ) server_coroutine = asyncio . start_unix_server ( self . _server_callback , sock = self . sock ) self . server = await server_coroutine find_sockfile ( display = None ) Finds the appropriate socket file for the given display. If unspecified, the socket file is determined as follows: - If WAYLAND_DISPLAY is set, use it. - else if DISPLAY is set, use that. - else check for the existence of a socket file for WAYLAND_DISPLAY=wayland-0 and if it exists, use it. - else check for the existence of a socket file for DISPLAY=:0 and if it exists, use it. - else raise an IPCError. Source code in libqtile/ipc.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def find_sockfile ( display : str | None = None ): \"\"\" Finds the appropriate socket file for the given display. If unspecified, the socket file is determined as follows: - If WAYLAND_DISPLAY is set, use it. - else if DISPLAY is set, use that. - else check for the existence of a socket file for WAYLAND_DISPLAY=wayland-0 and if it exists, use it. - else check for the existence of a socket file for DISPLAY=:0 and if it exists, use it. - else raise an IPCError. \"\"\" cache_directory = get_cache_dir () if display : return os . path . join ( cache_directory , SOCKBASE % display ) display = os . environ . get ( \"WAYLAND_DISPLAY\" ) if display : return os . path . join ( cache_directory , SOCKBASE % display ) display = os . environ . get ( \"DISPLAY\" ) if display : return os . path . join ( cache_directory , SOCKBASE % display ) sockfile = os . path . join ( cache_directory , SOCKBASE % \"wayland-0\" ) if os . path . exists ( sockfile ): return sockfile sockfile = os . path . join ( cache_directory , SOCKBASE % \":0\" ) if os . path . exists ( sockfile ): return sockfile raise IPCError ( \"Could not find socket file.\" )","title":"ipc"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Client","text":"Parameters: Name Type Description Default socket_path str The file path to the file that is used to open the connection to the running IPC server. required is_json Pack and unpack messages as json False Source code in libqtile/ipc.py 148 149 150 151 152 153 154 155 156 157 158 159 160 def __init__ ( self , socket_path : str , is_json = False ) -> None : \"\"\"Create a new IPC client Parameters ---------- socket_path: str The file path to the file that is used to open the connection to the running IPC server. is_json: bool Pack and unpack messages as json \"\"\" self . socket_path = socket_path self . is_json = is_json","title":"Client"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Client.async_send","text":"Send the message to the server Connect to the server, then pack and send the message to the server, then wait for and return the response from the server. Source code in libqtile/ipc.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 async def async_send ( self , msg : Any ) -> Any : \"\"\"Send the message to the server Connect to the server, then pack and send the message to the server, then wait for and return the response from the server. \"\"\" try : reader , writer = await asyncio . wait_for ( asyncio . open_unix_connection ( path = self . socket_path ), timeout = 3 ) except ( ConnectionRefusedError , FileNotFoundError ): raise IPCError ( \"Could not open {} \" . format ( self . socket_path )) try : send_data = _IPC . pack ( msg , is_json = self . is_json ) writer . write ( send_data ) writer . write_eof () read_data = await asyncio . wait_for ( reader . read (), timeout = 10 ) except asyncio . TimeoutError : raise IPCError ( \"Server not responding\" ) finally : # see the note in Server._server_callback() writer . close () await writer . wait_closed () data , _ = _IPC . unpack ( read_data , is_json = self . is_json ) return data","title":"async_send()"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Client.send","text":"Send the message and return the response from the server If any exception is raised by the server, that will propogate out of this call. Source code in libqtile/ipc.py 165 166 167 168 169 170 171 def send ( self , msg : Any ) -> Any : \"\"\"Send the message and return the response from the server If any exception is raised by the server, that will propogate out of this call. \"\"\" return asyncio . run ( self . async_send ( msg ))","title":"send()"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Server","text":"Source code in libqtile/ipc.py 205 206 207 208 209 210 211 212 213 214 215 216 def __init__ ( self , socket_path : str , handler ) -> None : self . socket_path = socket_path self . handler = handler self . server = None # type: asyncio.AbstractServer | None if os . path . exists ( socket_path ): os . unlink ( socket_path ) self . sock = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM , 0 ) flags = fcntl . fcntl ( self . sock . fileno (), fcntl . F_GETFD ) fcntl . fcntl ( self . sock . fileno (), fcntl . F_SETFD , flags | fcntl . FD_CLOEXEC ) self . sock . bind ( self . socket_path )","title":"Server"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Server.__aenter__","text":"Start and return the server Source code in libqtile/ipc.py 247 248 249 250 async def __aenter__ ( self ) -> \"Server\" : \"\"\"Start and return the server\"\"\" await self . start () return self","title":"__aenter__()"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Server.__aexit__","text":"Close and shutdown the server Source code in libqtile/ipc.py 252 253 254 async def __aexit__ ( self , _exc_type , _exc_value , _tb ) -> None : \"\"\"Close and shutdown the server\"\"\" await self . close ()","title":"__aexit__()"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Server.close","text":"Close and shutdown the server Source code in libqtile/ipc.py 264 265 266 267 268 269 270 271 272 async def close ( self ) -> None : \"\"\"Close and shutdown the server\"\"\" assert self . server is not None logger . debug ( \"Stopping server on close\" ) self . server . close () await self . server . wait_closed () self . server = None","title":"close()"},{"location":"reference/libqtile/ipc/#libqtile.ipc.Server.start","text":"Start the server Source code in libqtile/ipc.py 256 257 258 259 260 261 262 async def start ( self ) -> None : \"\"\"Start the server\"\"\" assert self . server is None logger . debug ( \"Starting server\" ) server_coroutine = asyncio . start_unix_server ( self . _server_callback , sock = self . sock ) self . server = await server_coroutine","title":"start()"},{"location":"reference/libqtile/ipc/#libqtile.ipc.find_sockfile","text":"Finds the appropriate socket file for the given display. If unspecified, the socket file is determined as follows: - If WAYLAND_DISPLAY is set, use it. - else if DISPLAY is set, use that. - else check for the existence of a socket file for WAYLAND_DISPLAY=wayland-0 and if it exists, use it. - else check for the existence of a socket file for DISPLAY=:0 and if it exists, use it. - else raise an IPCError. Source code in libqtile/ipc.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def find_sockfile ( display : str | None = None ): \"\"\" Finds the appropriate socket file for the given display. If unspecified, the socket file is determined as follows: - If WAYLAND_DISPLAY is set, use it. - else if DISPLAY is set, use that. - else check for the existence of a socket file for WAYLAND_DISPLAY=wayland-0 and if it exists, use it. - else check for the existence of a socket file for DISPLAY=:0 and if it exists, use it. - else raise an IPCError. \"\"\" cache_directory = get_cache_dir () if display : return os . path . join ( cache_directory , SOCKBASE % display ) display = os . environ . get ( \"WAYLAND_DISPLAY\" ) if display : return os . path . join ( cache_directory , SOCKBASE % display ) display = os . environ . get ( \"DISPLAY\" ) if display : return os . path . join ( cache_directory , SOCKBASE % display ) sockfile = os . path . join ( cache_directory , SOCKBASE % \"wayland-0\" ) if os . path . exists ( sockfile ): return sockfile sockfile = os . path . join ( cache_directory , SOCKBASE % \":0\" ) if os . path . exists ( sockfile ): return sockfile raise IPCError ( \"Could not find socket file.\" )","title":"find_sockfile()"},{"location":"reference/libqtile/lazy/","text":"LazyCall ( call , args , kwargs ) Parameters: Name Type Description Default call CommandGraphCall The call that is made required args tuple The args passed to the call when it is evaluated. required kwargs dict The kwargs passed to the call when it is evaluated. required Source code in libqtile/lazy.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> None : \"\"\"The lazily evaluated command graph call Parameters ---------- call: CommandGraphCall The call that is made args: tuple The args passed to the call when it is evaluated. kwargs: dict The kwargs passed to the call when it is evaluated. \"\"\" self . _call = call self . _args = args self . _kwargs = kwargs self . _focused : Match | None = None self . _if_no_focused : bool = False self . _layouts : set [ str ] = set () self . _when_floating = True __call__ ( * args , ** kwargs ) Convenience method to allow users to pass arguments to functions decorated with @lazy.function . @lazy.function def my_function(qtile, pos_arg, keyword_arg=False): pass ... Key(... my_function(\"Positional argument\", keyword_arg=True)) Source code in libqtile/lazy.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __call__ ( self , * args , ** kwargs ): \"\"\"Convenience method to allow users to pass arguments to functions decorated with `@lazy.function`. @lazy.function def my_function(qtile, pos_arg, keyword_arg=False): pass ... Key(... my_function(\"Positional argument\", keyword_arg=True)) \"\"\" # We need to return a new object so the arguments are not shared between # a single instance of the LazyCall object. return LazyCall ( self . _call , ( * self . _args , * args ), { ** self . _kwargs , ** kwargs }) args () property The args to the given call Source code in libqtile/lazy.py 84 85 86 87 @property def args ( self ) -> tuple : \"\"\"The args to the given call\"\"\" return self . _args kwargs () property The kwargs to the given call Source code in libqtile/lazy.py 89 90 91 92 @property def kwargs ( self ) -> dict : \"\"\"The kwargs to the given call\"\"\" return self . _kwargs name () property The name of the given call Source code in libqtile/lazy.py 79 80 81 82 @property def name ( self ) -> str : \"\"\"The name of the given call\"\"\" return self . _call . name selectors () property The selectors for the given call Source code in libqtile/lazy.py 74 75 76 77 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors for the given call\"\"\" return self . _call . selectors when ( focused = None , if_no_focused = False , layout = None , when_floating = True ) Enable call only for given layout(s) and floating state Parameters: Name Type Description Default focused Match | None Match criteria to enable call for the current window. None if_no_focused bool Whether or not the focused attribute should also match when there is no focused window. This is useful when the focused attribute is e.g. set to a regex that should also match when there is no focused window. By default this is set to False so that the focused attribute only matches when there is actually a focused window. False layout Iterable [ str ] | str | None Restrict call to one or more layouts. If None, enable the call for all layouts. None when_floating bool Enable call when the current window is floating. True Source code in libqtile/lazy.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def when ( self , focused : Match | None = None , if_no_focused : bool = False , layout : Iterable [ str ] | str | None = None , when_floating : bool = True , ) -> \"LazyCall\" : \"\"\"Enable call only for given layout(s) and floating state Parameters ---------- focused: Match or None Match criteria to enable call for the current window. if_no_focused: bool Whether or not the `focused` attribute should also match when there is no focused window. This is useful when the `focused` attribute is e.g. set to a regex that should also match when there is no focused window. By default this is set to `False` so that the focused attribute only matches when there is actually a focused window. layout: str, Iterable[str], or None Restrict call to one or more layouts. If None, enable the call for all layouts. when_floating: bool Enable call when the current window is floating. \"\"\" self . _focused = focused self . _if_no_focused = if_no_focused if layout is not None : self . _layouts = { layout } if isinstance ( layout , str ) else set ( layout ) self . _when_floating = when_floating return self LazyCommandInterface Bases: CommandInterface A lazy loading command object Allows all commands and items to be resolved at run time, and returns lazily evaluated commands. execute ( call , args , kwargs ) Lazily evaluate the given call Source code in libqtile/lazy.py 157 158 159 def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> LazyCall : \"\"\"Lazily evaluate the given call\"\"\" return LazyCall ( call , args , kwargs ) has_command ( node , command ) Lazily resolve the given command Source code in libqtile/lazy.py 161 162 163 def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Lazily resolve the given command\"\"\" return True has_item ( node , object_type , item ) Lazily resolve the given item Source code in libqtile/lazy.py 165 166 167 def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Lazily resolve the given item\"\"\" return True","title":"lazy"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall","text":"Parameters: Name Type Description Default call CommandGraphCall The call that is made required args tuple The args passed to the call when it is evaluated. required kwargs dict The kwargs passed to the call when it is evaluated. required Source code in libqtile/lazy.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> None : \"\"\"The lazily evaluated command graph call Parameters ---------- call: CommandGraphCall The call that is made args: tuple The args passed to the call when it is evaluated. kwargs: dict The kwargs passed to the call when it is evaluated. \"\"\" self . _call = call self . _args = args self . _kwargs = kwargs self . _focused : Match | None = None self . _if_no_focused : bool = False self . _layouts : set [ str ] = set () self . _when_floating = True","title":"LazyCall"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall.__call__","text":"Convenience method to allow users to pass arguments to functions decorated with @lazy.function . @lazy.function def my_function(qtile, pos_arg, keyword_arg=False): pass ... Key(... my_function(\"Positional argument\", keyword_arg=True)) Source code in libqtile/lazy.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __call__ ( self , * args , ** kwargs ): \"\"\"Convenience method to allow users to pass arguments to functions decorated with `@lazy.function`. @lazy.function def my_function(qtile, pos_arg, keyword_arg=False): pass ... Key(... my_function(\"Positional argument\", keyword_arg=True)) \"\"\" # We need to return a new object so the arguments are not shared between # a single instance of the LazyCall object. return LazyCall ( self . _call , ( * self . _args , * args ), { ** self . _kwargs , ** kwargs })","title":"__call__()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall.args","text":"The args to the given call Source code in libqtile/lazy.py 84 85 86 87 @property def args ( self ) -> tuple : \"\"\"The args to the given call\"\"\" return self . _args","title":"args()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall.kwargs","text":"The kwargs to the given call Source code in libqtile/lazy.py 89 90 91 92 @property def kwargs ( self ) -> dict : \"\"\"The kwargs to the given call\"\"\" return self . _kwargs","title":"kwargs()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall.name","text":"The name of the given call Source code in libqtile/lazy.py 79 80 81 82 @property def name ( self ) -> str : \"\"\"The name of the given call\"\"\" return self . _call . name","title":"name()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall.selectors","text":"The selectors for the given call Source code in libqtile/lazy.py 74 75 76 77 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors for the given call\"\"\" return self . _call . selectors","title":"selectors()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCall.when","text":"Enable call only for given layout(s) and floating state Parameters: Name Type Description Default focused Match | None Match criteria to enable call for the current window. None if_no_focused bool Whether or not the focused attribute should also match when there is no focused window. This is useful when the focused attribute is e.g. set to a regex that should also match when there is no focused window. By default this is set to False so that the focused attribute only matches when there is actually a focused window. False layout Iterable [ str ] | str | None Restrict call to one or more layouts. If None, enable the call for all layouts. None when_floating bool Enable call when the current window is floating. True Source code in libqtile/lazy.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def when ( self , focused : Match | None = None , if_no_focused : bool = False , layout : Iterable [ str ] | str | None = None , when_floating : bool = True , ) -> \"LazyCall\" : \"\"\"Enable call only for given layout(s) and floating state Parameters ---------- focused: Match or None Match criteria to enable call for the current window. if_no_focused: bool Whether or not the `focused` attribute should also match when there is no focused window. This is useful when the `focused` attribute is e.g. set to a regex that should also match when there is no focused window. By default this is set to `False` so that the focused attribute only matches when there is actually a focused window. layout: str, Iterable[str], or None Restrict call to one or more layouts. If None, enable the call for all layouts. when_floating: bool Enable call when the current window is floating. \"\"\" self . _focused = focused self . _if_no_focused = if_no_focused if layout is not None : self . _layouts = { layout } if isinstance ( layout , str ) else set ( layout ) self . _when_floating = when_floating return self","title":"when()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCommandInterface","text":"Bases: CommandInterface A lazy loading command object Allows all commands and items to be resolved at run time, and returns lazily evaluated commands.","title":"LazyCommandInterface"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCommandInterface.execute","text":"Lazily evaluate the given call Source code in libqtile/lazy.py 157 158 159 def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> LazyCall : \"\"\"Lazily evaluate the given call\"\"\" return LazyCall ( call , args , kwargs )","title":"execute()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCommandInterface.has_command","text":"Lazily resolve the given command Source code in libqtile/lazy.py 161 162 163 def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Lazily resolve the given command\"\"\" return True","title":"has_command()"},{"location":"reference/libqtile/lazy/#libqtile.lazy.LazyCommandInterface.has_item","text":"Lazily resolve the given item Source code in libqtile/lazy.py 165 166 167 def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Lazily resolve the given item\"\"\" return True","title":"has_item()"},{"location":"reference/libqtile/log_utils/","text":"ColorFormatter Bases: Formatter Logging formatter adding console colors to the output. format ( record ) Format the record with colors. Source code in libqtile/log_utils.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def format ( self , record : LogRecord ) -> str : \"\"\"Format the record with colors.\"\"\" color = self . color_seq % ( 30 + self . colors [ record . levelname ]) message = Formatter . format ( self , record ) message = ( message . replace ( \"$RESET\" , self . reset_seq ) . replace ( \"$BOLD\" , self . bold_seq ) . replace ( \"$COLOR\" , color ) ) for color , value in self . colors . items (): message = ( message . replace ( \"$\" + color , self . color_seq % ( value + 30 )) . replace ( \"$BG\" + color , self . color_seq % ( value + 40 )) . replace ( \"$BG-\" + color , self . color_seq % ( value + 40 )) ) return message + self . reset_seq","title":"log_utils"},{"location":"reference/libqtile/log_utils/#libqtile.log_utils.ColorFormatter","text":"Bases: Formatter Logging formatter adding console colors to the output.","title":"ColorFormatter"},{"location":"reference/libqtile/log_utils/#libqtile.log_utils.ColorFormatter.format","text":"Format the record with colors. Source code in libqtile/log_utils.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def format ( self , record : LogRecord ) -> str : \"\"\"Format the record with colors.\"\"\" color = self . color_seq % ( 30 + self . colors [ record . levelname ]) message = Formatter . format ( self , record ) message = ( message . replace ( \"$RESET\" , self . reset_seq ) . replace ( \"$BOLD\" , self . bold_seq ) . replace ( \"$COLOR\" , color ) ) for color , value in self . colors . items (): message = ( message . replace ( \"$\" + color , self . color_seq % ( value + 30 )) . replace ( \"$BG\" + color , self . color_seq % ( value + 40 )) . replace ( \"$BG-\" + color , self . color_seq % ( value + 40 )) ) return message + self . reset_seq","title":"format()"},{"location":"reference/libqtile/notify/","text":"NotificationManager () Source code in libqtile/notify.py 128 129 130 131 132 def __init__ ( self ): self . notifications = [] self . callbacks = [] self . close_callbacks = [] self . _service = None","title":"notify"},{"location":"reference/libqtile/notify/#libqtile.notify.NotificationManager","text":"Source code in libqtile/notify.py 128 129 130 131 132 def __init__ ( self ): self . notifications = [] self . callbacks = [] self . close_callbacks = [] self . _service = None","title":"NotificationManager"},{"location":"reference/libqtile/pango_ffi_build/","text":"","title":"pango_ffi_build"},{"location":"reference/libqtile/pangocffi/","text":"","title":"pangocffi"},{"location":"reference/libqtile/popup/","text":"Popup ( qtile , x = 50 , y = 50 , width = 256 , height = 64 , ** config ) Bases: configurable . Configurable This class can be used to create popup windows that display images and/or text. Source code in libqtile/popup.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , qtile : Qtile , x : int = 50 , y : int = 50 , width : int = 256 , height : int = 64 , ** config , ): configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( Popup . defaults ) self . qtile = qtile self . win : Any = qtile . core . create_internal ( x , y , width , height ) # TODO: better annotate Internal self . win . opacity = self . opacity self . win . process_button_click = self . process_button_click self . win . process_window_expose = self . draw self . drawer : Drawer = self . win . create_drawer ( width , height ) self . clear () self . layout = self . drawer . textlayout ( text = \"\" , colour = self . foreground , font_family = self . font , font_size = self . font_size , font_shadow = self . fontshadow , wrap = self . wrap , markup = True , ) self . layout . layout . set_alignment ( pangocffi . ALIGNMENTS [ self . text_alignment ]) if self . border_width and self . border : self . win . paint_borders ( self . border , self . border_width ) self . x = self . win . x self . y = self . win . y draw_image ( image , x , y ) Paint an image onto the window at point x, y. The image should be a surface e.g. loaded from libqtile.images.Img.from_path. Source code in libqtile/popup.py 159 160 161 162 163 164 165 def draw_image ( self , image : ImageSurface , x : int , y : int ) -> None : \"\"\" Paint an image onto the window at point x, y. The image should be a surface e.g. loaded from libqtile.images.Img.from_path. \"\"\" self . drawer . ctx . set_source_surface ( image , x , y ) self . drawer . ctx . paint ()","title":"popup"},{"location":"reference/libqtile/popup/#libqtile.popup.Popup","text":"Bases: configurable . Configurable This class can be used to create popup windows that display images and/or text. Source code in libqtile/popup.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , qtile : Qtile , x : int = 50 , y : int = 50 , width : int = 256 , height : int = 64 , ** config , ): configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( Popup . defaults ) self . qtile = qtile self . win : Any = qtile . core . create_internal ( x , y , width , height ) # TODO: better annotate Internal self . win . opacity = self . opacity self . win . process_button_click = self . process_button_click self . win . process_window_expose = self . draw self . drawer : Drawer = self . win . create_drawer ( width , height ) self . clear () self . layout = self . drawer . textlayout ( text = \"\" , colour = self . foreground , font_family = self . font , font_size = self . font_size , font_shadow = self . fontshadow , wrap = self . wrap , markup = True , ) self . layout . layout . set_alignment ( pangocffi . ALIGNMENTS [ self . text_alignment ]) if self . border_width and self . border : self . win . paint_borders ( self . border , self . border_width ) self . x = self . win . x self . y = self . win . y","title":"Popup"},{"location":"reference/libqtile/popup/#libqtile.popup.Popup.draw_image","text":"Paint an image onto the window at point x, y. The image should be a surface e.g. loaded from libqtile.images.Img.from_path. Source code in libqtile/popup.py 159 160 161 162 163 164 165 def draw_image ( self , image : ImageSurface , x : int , y : int ) -> None : \"\"\" Paint an image onto the window at point x, y. The image should be a surface e.g. loaded from libqtile.images.Img.from_path. \"\"\" self . drawer . ctx . set_source_surface ( image , x , y ) self . drawer . ctx . paint ()","title":"draw_image()"},{"location":"reference/libqtile/scratchpad/","text":"DropDownToggler ( window , scratchpad_name , ddconfig ) Bases: WindowVisibilityToggler Specialized WindowVisibilityToggler which places the associatd window each time it is shown at desired location. For example this can be used to create a quake-like terminal. Source code in libqtile/scratchpad.py 170 171 172 173 174 175 176 177 178 179 180 181 def __init__ ( self , window , scratchpad_name , ddconfig ): self . name = ddconfig . name self . x = ddconfig . x self . y = ddconfig . y self . width = ddconfig . width self . height = ddconfig . height # Let's add the window to the scratchpad group. window . togroup ( scratchpad_name ) window . opacity = ddconfig . opacity WindowVisibilityToggler . __init__ ( self , scratchpad_name , window , ddconfig . on_focus_lost_hide , ddconfig . warp_pointer ) show () Like WindowVisibilityToggler.show, but before showing the window, its floating x, y, width and height is set. Source code in libqtile/scratchpad.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def show ( self ): \"\"\" Like WindowVisibilityToggler.show, but before showing the window, its floating x, y, width and height is set. \"\"\" if ( not self . visible ) or ( not self . shown ): # SET GEOMETRY win = self . window screen = win . qtile . current_screen # calculate windows floating position and width/height # these may differ for screens, and thus always recalculated. x = int ( screen . dx + self . x * screen . dwidth ) y = int ( screen . dy + self . y * screen . dheight ) win . float_x = x win . float_y = y width = int ( screen . dwidth * self . width ) height = int ( screen . dheight * self . height ) win . place ( x , y , width , height , win . borderwidth , win . bordercolor , respect_hints = True ) # Toggle the dropdown WindowVisibilityToggler . show ( self ) ScratchPad ( name = 'scratchpad' , dropdowns = None , label = '' , single = False ) Bases: group . _Group Specialized group which is by default invisible and can be configured, to spawn windows and toggle its visibility (in the current group) by command. The ScratchPad group acts as a container for windows which are currently not visible but associated to a DropDownToggler and can toggle their group by command (of ScratchPad group). The ScratchPad, by default, has no label and thus is not shown in GroupBox widget. Source code in libqtile/scratchpad.py 224 225 226 227 228 229 230 231 232 233 234 235 236 def __init__ ( self , name = \"scratchpad\" , dropdowns : list [ config . DropDown ] | None = None , label = \"\" , single = False , ): group . _Group . __init__ ( self , name , label = label ) self . _dropdownconfig = { dd . name : dd for dd in dropdowns } if dropdowns is not None else {} self . dropdowns : dict [ str , DropDownToggler ] = {} self . _spawned : dict [ str , Match ] = {} self . _to_hide : list [ str ] = [] self . _single = single dropdown_info ( name = None ) Get information on configured or currently active DropDowns. If name is None, a list of all dropdown names is returned. Source code in libqtile/scratchpad.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 @expose_command () def dropdown_info ( self , name = None ): \"\"\" Get information on configured or currently active DropDowns. If name is None, a list of all dropdown names is returned. \"\"\" if name is None : return { \"dropdowns\" : [ ddname for ddname in self . _dropdownconfig ]} elif name in self . dropdowns : return self . dropdowns [ name ] . info () elif name in self . _dropdownconfig : return self . _dropdownconfig [ name ] . info () else : raise ValueError ( 'No DropDown named \" %s \".' % name ) dropdown_reconfigure ( name , ** kwargs ) reconfigure the named DropDown configuration. Note that changed attributes only have an effect on spawning the window. Source code in libqtile/scratchpad.py 338 339 340 341 342 343 344 345 346 347 348 349 @expose_command () def dropdown_reconfigure ( self , name , ** kwargs ): \"\"\" reconfigure the named DropDown configuration. Note that changed attributes only have an effect on spawning the window. \"\"\" if name not in self . _dropdownconfig : return dd = self . _dropdownconfig [ name ] for attr , value in kwargs . items (): if hasattr ( dd , attr ): setattr ( dd , attr , value ) dropdown_toggle ( name ) Toggle visibility of named DropDown. Source code in libqtile/scratchpad.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @expose_command () def dropdown_toggle ( self , name ): \"\"\" Toggle visibility of named DropDown. \"\"\" if self . _single : for n , d in self . dropdowns . items (): if n != name : d . hide () if name in self . dropdowns : self . dropdowns [ name ] . toggle () else : if name in self . _dropdownconfig : self . _spawn ( self . _dropdownconfig [ name ]) get_state () Get the state of existing dropdown windows. Used for restoring state across Qtile restarts ( restart == True) or config reloads ( restart == False). Source code in libqtile/scratchpad.py 366 367 368 369 370 371 372 373 374 375 def get_state ( self ): \"\"\" Get the state of existing dropdown windows. Used for restoring state across Qtile restarts (`restart` == True) or config reloads (`restart` == False). \"\"\" state = [] for name , dd in self . dropdowns . items (): client_wid = dd . window . wid state . append (( name , client_wid , dd . visible )) return state hide_all () Hide all scratchpads. Source code in libqtile/scratchpad.py 330 331 332 333 334 335 336 @expose_command () def hide_all ( self ): \"\"\" Hide all scratchpads. \"\"\" for d in self . dropdowns . values (): d . hide () on_client_killed ( client , * args , ** kwargs ) hook method which is called if a client is killed. If the associated window is killed, reset internal state. Source code in libqtile/scratchpad.py 286 287 288 289 290 291 292 293 294 295 296 297 def on_client_killed ( self , client , * args , ** kwargs ): \"\"\" hook method which is called if a client is killed. If the associated window is killed, reset internal state. \"\"\" name = None for name , dd in self . dropdowns . items (): if dd . window is client : dd . unsubscribe () del self . dropdowns [ name ] break self . _check_unsubscribe () on_client_new ( client , * args , ** kwargs ) hook method which is called on new windows. This method is subscribed if the given command is spawned and unsubscribed immediately if the associated window is detected. Source code in libqtile/scratchpad.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def on_client_new ( self , client , * args , ** kwargs ): \"\"\" hook method which is called on new windows. This method is subscribed if the given command is spawned and unsubscribed immediately if the associated window is detected. \"\"\" name = None for n , match in self . _spawned . items (): if match . compare ( client ): name = n break if name is not None : self . _spawned . pop ( name ) if not self . _spawned : hook . unsubscribe . client_new ( self . on_client_new ) self . dropdowns [ name ] = DropDownToggler ( client , self . name , self . _dropdownconfig [ name ]) if self . _single : for n , d in self . dropdowns . items (): if n != name : d . hide () if name in self . _to_hide : self . dropdowns [ name ] . hide () self . _to_hide . remove ( name ) if len ( self . dropdowns ) == 1 : hook . subscribe . client_killed ( self . on_client_killed ) hook . subscribe . float_change ( self . on_float_change ) on_float_change ( * args , ** kwargs ) hook method which is called if window float state is changed. If the current associated window is not floated (any more) the window and process is detached from DRopDown, thus the next call to Show will spawn a new process. Source code in libqtile/scratchpad.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def on_float_change ( self , * args , ** kwargs ): \"\"\" hook method which is called if window float state is changed. If the current associated window is not floated (any more) the window and process is detached from DRopDown, thus the next call to Show will spawn a new process. \"\"\" name = None for name , dd in self . dropdowns . items (): if not dd . window . floating : if dd . window . group is not self : dd . unsubscribe () del self . dropdowns [ name ] break self . _check_unsubscribe () restore_state ( state , restart ) Restore the state of existing dropdown windows. Used for restoring state across Qtile restarts ( restart == True) or config reloads ( restart == False). Source code in libqtile/scratchpad.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 def restore_state ( self , state , restart : bool ) -> list [ int ]: \"\"\" Restore the state of existing dropdown windows. Used for restoring state across Qtile restarts (`restart` == True) or config reloads (`restart` == False). \"\"\" orphans = [] for name , wid , visible in state : if name in self . _dropdownconfig : if restart : self . _spawned [ name ] = Match ( wid = wid ) if not visible : self . _to_hide . append ( name ) else : # We are reloading the config; manage the clients now self . dropdowns [ name ] = DropDownToggler ( self . qtile . windows_map [ wid ], self . name , self . _dropdownconfig [ name ], ) if not visible : self . dropdowns [ name ] . hide () else : orphans . append ( wid ) if self . _spawned : # Handle re-managed clients after restarting assert restart hook . subscribe . client_new ( self . on_client_new ) if not restart and self . dropdowns : # We're only reloading so don't have these hooked via self.on_client_new hook . subscribe . client_killed ( self . on_client_killed ) hook . subscribe . float_change ( self . on_float_change ) return orphans WindowVisibilityToggler ( scratchpad_name , window , on_focus_lost_hide , warp_pointer ) WindowVisibilityToggler is a wrapper for a window, used in ScratchPad group to toggle visibility of a window by toggling the group it belongs to. The window is either sent to the named ScratchPad, which is by default invisble, or the current group on the current screen. With this functionality the window can be shown and hidden by a single keystroke (bound to command of ScratchPad group). By default, the window is also hidden if it loses focus. Parameters: scratchpad_name: string The name (not label) of the ScratchPad group used to hide the window window: window The window to toggle on_focus_lost_hide: bool if True the associated window is hidden if it loses focus warp_pointer: bool if True the mouse pointer is warped to center of associated window if shown. Only used if on_focus_lost_hide is True Source code in libqtile/scratchpad.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , scratchpad_name , window : Window , on_focus_lost_hide , warp_pointer ): \"\"\" Initiliaze the WindowVisibilityToggler. Parameters: =========== scratchpad_name: string The name (not label) of the ScratchPad group used to hide the window window: window The window to toggle on_focus_lost_hide: bool if True the associated window is hidden if it loses focus warp_pointer: bool if True the mouse pointer is warped to center of associated window if shown. Only used if on_focus_lost_hide is True \"\"\" self . scratchpad_name = scratchpad_name self . window = window self . on_focus_lost_hide = on_focus_lost_hide self . warp_pointer = warp_pointer # determine current status based on visibility self . shown = False self . show () hide () Hide the associated window. That is, send it to the scratchpad group. Source code in libqtile/scratchpad.py 129 130 131 132 133 134 135 136 137 138 139 def hide ( self ): \"\"\" Hide the associated window. That is, send it to the scratchpad group. \"\"\" if self . visible or self . shown : # unsubscribe the hook methods, since the window is not shown if self . on_focus_lost_hide : hook . unsubscribe . client_focus ( self . on_focus_change ) hook . unsubscribe . setgroup ( self . on_focus_change ) self . window . togroup ( self . scratchpad_name ) self . shown = False on_focus_change ( * args , ** kwargs ) hook method which is called on window focus change and group change. Depending on 'on_focus_lost_xxx' arguments, the associated window may get hidden (by call to hide) or even killed. Source code in libqtile/scratchpad.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def on_focus_change ( self , * args , ** kwargs ): \"\"\" hook method which is called on window focus change and group change. Depending on 'on_focus_lost_xxx' arguments, the associated window may get hidden (by call to hide) or even killed. \"\"\" if self . shown : current_group = self . window . qtile . current_group if ( self . window . group is not current_group or self . window is not current_group . current_window ): if self . on_focus_lost_hide : self . hide () show () Show the associated window on top of current screen. The window is moved to the current group as floating window. If 'warp_pointer' is True the mouse pointer is warped to center of the window if 'on_focus_lost_hide' is True. Otherwise, if pointer is moved manually to window by the user the window might be hidden again before actually reaching it. Source code in libqtile/scratchpad.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def show ( self ): \"\"\" Show the associated window on top of current screen. The window is moved to the current group as floating window. If 'warp_pointer' is True the mouse pointer is warped to center of the window if 'on_focus_lost_hide' is True. Otherwise, if pointer is moved manually to window by the user the window might be hidden again before actually reaching it. \"\"\" if ( not self . visible ) or ( not self . shown ): win = self . window # always set the floating state before changing group # to avoid disturbance of tiling layout win . _float_state = FloatStates . TOP # add to group and bring it to front. win . togroup () win . bring_to_front () # toggle internal flag of visibility self . shown = True # add hooks to determine if focus get lost if self . on_focus_lost_hide : if self . warp_pointer : win . focus ( warp = True ) hook . subscribe . client_focus ( self . on_focus_change ) hook . subscribe . setgroup ( self . on_focus_change ) toggle () Toggle the visibility of associated window. Either show() or hide(). Source code in libqtile/scratchpad.py 92 93 94 95 96 97 98 99 def toggle ( self ): \"\"\" Toggle the visibility of associated window. Either show() or hide(). \"\"\" if not self . visible or not self . shown : self . show () else : self . hide () unsubscribe () unsubscribe all hooks Source code in libqtile/scratchpad.py 141 142 143 144 145 def unsubscribe ( self ): \"\"\"unsubscribe all hooks\"\"\" if self . on_focus_lost_hide and ( self . visible or self . shown ): hook . unsubscribe . client_focus ( self . on_focus_change ) hook . unsubscribe . setgroup ( self . on_focus_change ) visible () property Determine if associated window is currently visible. That is the window is on a group different from the scratchpad and that group is the current visible group. Source code in libqtile/scratchpad.py 78 79 80 81 82 83 84 85 86 87 88 89 90 @property def visible ( self ): \"\"\" Determine if associated window is currently visible. That is the window is on a group different from the scratchpad and that group is the current visible group. \"\"\" if self . window . group is None : return False return ( self . window . group . name != self . scratchpad_name and self . window . group is self . window . qtile . current_group )","title":"scratchpad"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.DropDownToggler","text":"Bases: WindowVisibilityToggler Specialized WindowVisibilityToggler which places the associatd window each time it is shown at desired location. For example this can be used to create a quake-like terminal. Source code in libqtile/scratchpad.py 170 171 172 173 174 175 176 177 178 179 180 181 def __init__ ( self , window , scratchpad_name , ddconfig ): self . name = ddconfig . name self . x = ddconfig . x self . y = ddconfig . y self . width = ddconfig . width self . height = ddconfig . height # Let's add the window to the scratchpad group. window . togroup ( scratchpad_name ) window . opacity = ddconfig . opacity WindowVisibilityToggler . __init__ ( self , scratchpad_name , window , ddconfig . on_focus_lost_hide , ddconfig . warp_pointer )","title":"DropDownToggler"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.DropDownToggler.show","text":"Like WindowVisibilityToggler.show, but before showing the window, its floating x, y, width and height is set. Source code in libqtile/scratchpad.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def show ( self ): \"\"\" Like WindowVisibilityToggler.show, but before showing the window, its floating x, y, width and height is set. \"\"\" if ( not self . visible ) or ( not self . shown ): # SET GEOMETRY win = self . window screen = win . qtile . current_screen # calculate windows floating position and width/height # these may differ for screens, and thus always recalculated. x = int ( screen . dx + self . x * screen . dwidth ) y = int ( screen . dy + self . y * screen . dheight ) win . float_x = x win . float_y = y width = int ( screen . dwidth * self . width ) height = int ( screen . dheight * self . height ) win . place ( x , y , width , height , win . borderwidth , win . bordercolor , respect_hints = True ) # Toggle the dropdown WindowVisibilityToggler . show ( self )","title":"show()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad","text":"Bases: group . _Group Specialized group which is by default invisible and can be configured, to spawn windows and toggle its visibility (in the current group) by command. The ScratchPad group acts as a container for windows which are currently not visible but associated to a DropDownToggler and can toggle their group by command (of ScratchPad group). The ScratchPad, by default, has no label and thus is not shown in GroupBox widget. Source code in libqtile/scratchpad.py 224 225 226 227 228 229 230 231 232 233 234 235 236 def __init__ ( self , name = \"scratchpad\" , dropdowns : list [ config . DropDown ] | None = None , label = \"\" , single = False , ): group . _Group . __init__ ( self , name , label = label ) self . _dropdownconfig = { dd . name : dd for dd in dropdowns } if dropdowns is not None else {} self . dropdowns : dict [ str , DropDownToggler ] = {} self . _spawned : dict [ str , Match ] = {} self . _to_hide : list [ str ] = [] self . _single = single","title":"ScratchPad"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.dropdown_info","text":"Get information on configured or currently active DropDowns. If name is None, a list of all dropdown names is returned. Source code in libqtile/scratchpad.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 @expose_command () def dropdown_info ( self , name = None ): \"\"\" Get information on configured or currently active DropDowns. If name is None, a list of all dropdown names is returned. \"\"\" if name is None : return { \"dropdowns\" : [ ddname for ddname in self . _dropdownconfig ]} elif name in self . dropdowns : return self . dropdowns [ name ] . info () elif name in self . _dropdownconfig : return self . _dropdownconfig [ name ] . info () else : raise ValueError ( 'No DropDown named \" %s \".' % name )","title":"dropdown_info()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.dropdown_reconfigure","text":"reconfigure the named DropDown configuration. Note that changed attributes only have an effect on spawning the window. Source code in libqtile/scratchpad.py 338 339 340 341 342 343 344 345 346 347 348 349 @expose_command () def dropdown_reconfigure ( self , name , ** kwargs ): \"\"\" reconfigure the named DropDown configuration. Note that changed attributes only have an effect on spawning the window. \"\"\" if name not in self . _dropdownconfig : return dd = self . _dropdownconfig [ name ] for attr , value in kwargs . items (): if hasattr ( dd , attr ): setattr ( dd , attr , value )","title":"dropdown_reconfigure()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.dropdown_toggle","text":"Toggle visibility of named DropDown. Source code in libqtile/scratchpad.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @expose_command () def dropdown_toggle ( self , name ): \"\"\" Toggle visibility of named DropDown. \"\"\" if self . _single : for n , d in self . dropdowns . items (): if n != name : d . hide () if name in self . dropdowns : self . dropdowns [ name ] . toggle () else : if name in self . _dropdownconfig : self . _spawn ( self . _dropdownconfig [ name ])","title":"dropdown_toggle()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.get_state","text":"Get the state of existing dropdown windows. Used for restoring state across Qtile restarts ( restart == True) or config reloads ( restart == False). Source code in libqtile/scratchpad.py 366 367 368 369 370 371 372 373 374 375 def get_state ( self ): \"\"\" Get the state of existing dropdown windows. Used for restoring state across Qtile restarts (`restart` == True) or config reloads (`restart` == False). \"\"\" state = [] for name , dd in self . dropdowns . items (): client_wid = dd . window . wid state . append (( name , client_wid , dd . visible )) return state","title":"get_state()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.hide_all","text":"Hide all scratchpads. Source code in libqtile/scratchpad.py 330 331 332 333 334 335 336 @expose_command () def hide_all ( self ): \"\"\" Hide all scratchpads. \"\"\" for d in self . dropdowns . values (): d . hide ()","title":"hide_all()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.on_client_killed","text":"hook method which is called if a client is killed. If the associated window is killed, reset internal state. Source code in libqtile/scratchpad.py 286 287 288 289 290 291 292 293 294 295 296 297 def on_client_killed ( self , client , * args , ** kwargs ): \"\"\" hook method which is called if a client is killed. If the associated window is killed, reset internal state. \"\"\" name = None for name , dd in self . dropdowns . items (): if dd . window is client : dd . unsubscribe () del self . dropdowns [ name ] break self . _check_unsubscribe ()","title":"on_client_killed()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.on_client_new","text":"hook method which is called on new windows. This method is subscribed if the given command is spawned and unsubscribed immediately if the associated window is detected. Source code in libqtile/scratchpad.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def on_client_new ( self , client , * args , ** kwargs ): \"\"\" hook method which is called on new windows. This method is subscribed if the given command is spawned and unsubscribed immediately if the associated window is detected. \"\"\" name = None for n , match in self . _spawned . items (): if match . compare ( client ): name = n break if name is not None : self . _spawned . pop ( name ) if not self . _spawned : hook . unsubscribe . client_new ( self . on_client_new ) self . dropdowns [ name ] = DropDownToggler ( client , self . name , self . _dropdownconfig [ name ]) if self . _single : for n , d in self . dropdowns . items (): if n != name : d . hide () if name in self . _to_hide : self . dropdowns [ name ] . hide () self . _to_hide . remove ( name ) if len ( self . dropdowns ) == 1 : hook . subscribe . client_killed ( self . on_client_killed ) hook . subscribe . float_change ( self . on_float_change )","title":"on_client_new()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.on_float_change","text":"hook method which is called if window float state is changed. If the current associated window is not floated (any more) the window and process is detached from DRopDown, thus the next call to Show will spawn a new process. Source code in libqtile/scratchpad.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def on_float_change ( self , * args , ** kwargs ): \"\"\" hook method which is called if window float state is changed. If the current associated window is not floated (any more) the window and process is detached from DRopDown, thus the next call to Show will spawn a new process. \"\"\" name = None for name , dd in self . dropdowns . items (): if not dd . window . floating : if dd . window . group is not self : dd . unsubscribe () del self . dropdowns [ name ] break self . _check_unsubscribe ()","title":"on_float_change()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.ScratchPad.restore_state","text":"Restore the state of existing dropdown windows. Used for restoring state across Qtile restarts ( restart == True) or config reloads ( restart == False). Source code in libqtile/scratchpad.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 def restore_state ( self , state , restart : bool ) -> list [ int ]: \"\"\" Restore the state of existing dropdown windows. Used for restoring state across Qtile restarts (`restart` == True) or config reloads (`restart` == False). \"\"\" orphans = [] for name , wid , visible in state : if name in self . _dropdownconfig : if restart : self . _spawned [ name ] = Match ( wid = wid ) if not visible : self . _to_hide . append ( name ) else : # We are reloading the config; manage the clients now self . dropdowns [ name ] = DropDownToggler ( self . qtile . windows_map [ wid ], self . name , self . _dropdownconfig [ name ], ) if not visible : self . dropdowns [ name ] . hide () else : orphans . append ( wid ) if self . _spawned : # Handle re-managed clients after restarting assert restart hook . subscribe . client_new ( self . on_client_new ) if not restart and self . dropdowns : # We're only reloading so don't have these hooked via self.on_client_new hook . subscribe . client_killed ( self . on_client_killed ) hook . subscribe . float_change ( self . on_float_change ) return orphans","title":"restore_state()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler","text":"WindowVisibilityToggler is a wrapper for a window, used in ScratchPad group to toggle visibility of a window by toggling the group it belongs to. The window is either sent to the named ScratchPad, which is by default invisble, or the current group on the current screen. With this functionality the window can be shown and hidden by a single keystroke (bound to command of ScratchPad group). By default, the window is also hidden if it loses focus.","title":"WindowVisibilityToggler"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler--parameters","text":"scratchpad_name: string The name (not label) of the ScratchPad group used to hide the window window: window The window to toggle on_focus_lost_hide: bool if True the associated window is hidden if it loses focus warp_pointer: bool if True the mouse pointer is warped to center of associated window if shown. Only used if on_focus_lost_hide is True Source code in libqtile/scratchpad.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , scratchpad_name , window : Window , on_focus_lost_hide , warp_pointer ): \"\"\" Initiliaze the WindowVisibilityToggler. Parameters: =========== scratchpad_name: string The name (not label) of the ScratchPad group used to hide the window window: window The window to toggle on_focus_lost_hide: bool if True the associated window is hidden if it loses focus warp_pointer: bool if True the mouse pointer is warped to center of associated window if shown. Only used if on_focus_lost_hide is True \"\"\" self . scratchpad_name = scratchpad_name self . window = window self . on_focus_lost_hide = on_focus_lost_hide self . warp_pointer = warp_pointer # determine current status based on visibility self . shown = False self . show ()","title":"Parameters:"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler.hide","text":"Hide the associated window. That is, send it to the scratchpad group. Source code in libqtile/scratchpad.py 129 130 131 132 133 134 135 136 137 138 139 def hide ( self ): \"\"\" Hide the associated window. That is, send it to the scratchpad group. \"\"\" if self . visible or self . shown : # unsubscribe the hook methods, since the window is not shown if self . on_focus_lost_hide : hook . unsubscribe . client_focus ( self . on_focus_change ) hook . unsubscribe . setgroup ( self . on_focus_change ) self . window . togroup ( self . scratchpad_name ) self . shown = False","title":"hide()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler.on_focus_change","text":"hook method which is called on window focus change and group change. Depending on 'on_focus_lost_xxx' arguments, the associated window may get hidden (by call to hide) or even killed. Source code in libqtile/scratchpad.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def on_focus_change ( self , * args , ** kwargs ): \"\"\" hook method which is called on window focus change and group change. Depending on 'on_focus_lost_xxx' arguments, the associated window may get hidden (by call to hide) or even killed. \"\"\" if self . shown : current_group = self . window . qtile . current_group if ( self . window . group is not current_group or self . window is not current_group . current_window ): if self . on_focus_lost_hide : self . hide ()","title":"on_focus_change()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler.show","text":"Show the associated window on top of current screen. The window is moved to the current group as floating window. If 'warp_pointer' is True the mouse pointer is warped to center of the window if 'on_focus_lost_hide' is True. Otherwise, if pointer is moved manually to window by the user the window might be hidden again before actually reaching it. Source code in libqtile/scratchpad.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def show ( self ): \"\"\" Show the associated window on top of current screen. The window is moved to the current group as floating window. If 'warp_pointer' is True the mouse pointer is warped to center of the window if 'on_focus_lost_hide' is True. Otherwise, if pointer is moved manually to window by the user the window might be hidden again before actually reaching it. \"\"\" if ( not self . visible ) or ( not self . shown ): win = self . window # always set the floating state before changing group # to avoid disturbance of tiling layout win . _float_state = FloatStates . TOP # add to group and bring it to front. win . togroup () win . bring_to_front () # toggle internal flag of visibility self . shown = True # add hooks to determine if focus get lost if self . on_focus_lost_hide : if self . warp_pointer : win . focus ( warp = True ) hook . subscribe . client_focus ( self . on_focus_change ) hook . subscribe . setgroup ( self . on_focus_change )","title":"show()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler.toggle","text":"Toggle the visibility of associated window. Either show() or hide(). Source code in libqtile/scratchpad.py 92 93 94 95 96 97 98 99 def toggle ( self ): \"\"\" Toggle the visibility of associated window. Either show() or hide(). \"\"\" if not self . visible or not self . shown : self . show () else : self . hide ()","title":"toggle()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler.unsubscribe","text":"unsubscribe all hooks Source code in libqtile/scratchpad.py 141 142 143 144 145 def unsubscribe ( self ): \"\"\"unsubscribe all hooks\"\"\" if self . on_focus_lost_hide and ( self . visible or self . shown ): hook . unsubscribe . client_focus ( self . on_focus_change ) hook . unsubscribe . setgroup ( self . on_focus_change )","title":"unsubscribe()"},{"location":"reference/libqtile/scratchpad/#libqtile.scratchpad.WindowVisibilityToggler.visible","text":"Determine if associated window is currently visible. That is the window is on a group different from the scratchpad and that group is the current visible group. Source code in libqtile/scratchpad.py 78 79 80 81 82 83 84 85 86 87 88 89 90 @property def visible ( self ): \"\"\" Determine if associated window is currently visible. That is the window is on a group different from the scratchpad and that group is the current visible group. \"\"\" if self . window . group is None : return False return ( self . window . group . name != self . scratchpad_name and self . window . group is self . window . qtile . current_group )","title":"visible()"},{"location":"reference/libqtile/sh/","text":"A command shell for Qtile. QSh ( client , completekey = 'tab' ) Qtile shell instance Source code in libqtile/sh.py 61 62 63 64 65 66 67 68 def __init__ ( self , client : CommandInterface , completekey = \"tab\" ) -> None : # Readline is imported here to prevent issues with terminal resizing # which would result from readline being imported when qtile is first # started self . readline = import_module ( \"readline\" ) self . _command_client = CommandClient ( client ) self . _completekey = completekey self . _builtins = [ i [ 3 :] for i in dir ( self ) if i . startswith ( \"do_\" )] do_cd ( arg ) Change to another path. Examples cd layout/0 cd ../layout Source code in libqtile/sh.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def do_cd ( self , arg : str | None ) -> str : \"\"\"Change to another path. Examples ======== cd layout/0 cd ../layout \"\"\" if arg is None : self . _command_client = self . _command_client . root return \"/\" next_node , rest_path = self . _find_path ( arg ) if next_node is None : return \"No such path.\" if rest_path is None : self . _command_client = next_node else : allow_root , _ = next_node . items ( rest_path ) if not allow_root : return \"Item required for {} \" . format ( rest_path ) self . _command_client = next_node . navigate ( rest_path , None ) return format_selectors ( self . _command_client . selectors ) or \"/\" do_exit ( args ) Exit qshell Source code in libqtile/sh.py 303 304 305 def do_exit ( self , args ) -> None : \"\"\"Exit qshell\"\"\" sys . exit ( 0 ) do_help ( arg ) Give help on commands and builtins When invoked without arguments, provides an overview of all commands. When passed as an argument, also provides a detailed help on a specific command or builtin. Examples > help > help command Source code in libqtile/sh.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def do_help ( self , arg : str | None ) -> str : \"\"\"Give help on commands and builtins When invoked without arguments, provides an overview of all commands. When passed as an argument, also provides a detailed help on a specific command or builtin. Examples ======== > help > help command \"\"\" if not arg : lst = [ \"help command -- Help for a specific command.\" , \"\" , \"Builtins\" , \"========\" , self . columnize ( self . _builtins ), ] cmds = self . _command_client . commands if cmds : lst . extend ( [ \"\" , \"Commands for this object\" , \"========================\" , self . columnize ( cmds ), ] ) return \" \\n \" . join ( lst ) elif arg in self . _command_client . commands : return self . _command_client . call ( \"doc\" , arg ) elif arg in self . _builtins : c = getattr ( self , \"do_\" + arg ) ret = inspect . getdoc ( c ) assert ret is not None return ret else : return \"No such command: %s \" % arg do_ls ( arg ) List contained items on a node. Examples > ls > ls ../layout Source code in libqtile/sh.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def do_ls ( self , arg : str | None ) -> str : \"\"\"List contained items on a node. Examples ======== > ls > ls ../layout \"\"\" if arg : node , rest_path = self . _find_path ( arg ) if not node : return \"No such path.\" base_path = arg . rstrip ( \"/\" ) + \"/\" else : node = self . _command_client rest_path = None base_path = \"\" assert node is not None objects , items = self . _ls ( node , rest_path ) formatted_ls = [ \" {}{} /\" . format ( base_path , i ) for i in objects ] + [ \" {} [ {} ]/\" . format ( base_path [: - 1 ], i ) for i in items ] return self . columnize ( formatted_ls ) do_pwd ( arg ) Returns the current working location This is the same information as presented in the qshell prompt, but is very useful when running iqshell. Examples > pwd / > cd bar/top bar['top']> pwd bar['top'] Source code in libqtile/sh.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def do_pwd ( self , arg ) -> str : \"\"\"Returns the current working location This is the same information as presented in the qshell prompt, but is very useful when running iqshell. Examples ======== > pwd / > cd bar/top bar['top']> pwd bar['top'] \"\"\" return format_selectors ( self . _command_client . selectors ) or \"/\"","title":"sh"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh","text":"Qtile shell instance Source code in libqtile/sh.py 61 62 63 64 65 66 67 68 def __init__ ( self , client : CommandInterface , completekey = \"tab\" ) -> None : # Readline is imported here to prevent issues with terminal resizing # which would result from readline being imported when qtile is first # started self . readline = import_module ( \"readline\" ) self . _command_client = CommandClient ( client ) self . _completekey = completekey self . _builtins = [ i [ 3 :] for i in dir ( self ) if i . startswith ( \"do_\" )]","title":"QSh"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_cd","text":"Change to another path.","title":"do_cd()"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_cd--examples","text":"cd layout/0 cd ../layout Source code in libqtile/sh.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def do_cd ( self , arg : str | None ) -> str : \"\"\"Change to another path. Examples ======== cd layout/0 cd ../layout \"\"\" if arg is None : self . _command_client = self . _command_client . root return \"/\" next_node , rest_path = self . _find_path ( arg ) if next_node is None : return \"No such path.\" if rest_path is None : self . _command_client = next_node else : allow_root , _ = next_node . items ( rest_path ) if not allow_root : return \"Item required for {} \" . format ( rest_path ) self . _command_client = next_node . navigate ( rest_path , None ) return format_selectors ( self . _command_client . selectors ) or \"/\"","title":"Examples"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_exit","text":"Exit qshell Source code in libqtile/sh.py 303 304 305 def do_exit ( self , args ) -> None : \"\"\"Exit qshell\"\"\" sys . exit ( 0 )","title":"do_exit()"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_help","text":"Give help on commands and builtins When invoked without arguments, provides an overview of all commands. When passed as an argument, also provides a detailed help on a specific command or builtin.","title":"do_help()"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_help--examples","text":"> help > help command Source code in libqtile/sh.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def do_help ( self , arg : str | None ) -> str : \"\"\"Give help on commands and builtins When invoked without arguments, provides an overview of all commands. When passed as an argument, also provides a detailed help on a specific command or builtin. Examples ======== > help > help command \"\"\" if not arg : lst = [ \"help command -- Help for a specific command.\" , \"\" , \"Builtins\" , \"========\" , self . columnize ( self . _builtins ), ] cmds = self . _command_client . commands if cmds : lst . extend ( [ \"\" , \"Commands for this object\" , \"========================\" , self . columnize ( cmds ), ] ) return \" \\n \" . join ( lst ) elif arg in self . _command_client . commands : return self . _command_client . call ( \"doc\" , arg ) elif arg in self . _builtins : c = getattr ( self , \"do_\" + arg ) ret = inspect . getdoc ( c ) assert ret is not None return ret else : return \"No such command: %s \" % arg","title":"Examples"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_ls","text":"List contained items on a node.","title":"do_ls()"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_ls--examples","text":"> ls > ls ../layout Source code in libqtile/sh.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def do_ls ( self , arg : str | None ) -> str : \"\"\"List contained items on a node. Examples ======== > ls > ls ../layout \"\"\" if arg : node , rest_path = self . _find_path ( arg ) if not node : return \"No such path.\" base_path = arg . rstrip ( \"/\" ) + \"/\" else : node = self . _command_client rest_path = None base_path = \"\" assert node is not None objects , items = self . _ls ( node , rest_path ) formatted_ls = [ \" {}{} /\" . format ( base_path , i ) for i in objects ] + [ \" {} [ {} ]/\" . format ( base_path [: - 1 ], i ) for i in items ] return self . columnize ( formatted_ls )","title":"Examples"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_pwd","text":"Returns the current working location This is the same information as presented in the qshell prompt, but is very useful when running iqshell.","title":"do_pwd()"},{"location":"reference/libqtile/sh/#libqtile.sh.QSh.do_pwd--examples","text":"> pwd / > cd bar/top bar['top']> pwd bar['top'] Source code in libqtile/sh.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def do_pwd ( self , arg ) -> str : \"\"\"Returns the current working location This is the same information as presented in the qshell prompt, but is very useful when running iqshell. Examples ======== > pwd / > cd bar/top bar['top']> pwd bar['top'] \"\"\" return format_selectors ( self . _command_client . selectors ) or \"/\"","title":"Examples"},{"location":"reference/libqtile/utils/","text":"add_signal_receiver ( callback , session_bus = False , signal_name = None , dbus_interface = None , bus_name = None , path = None , check_service = False ) async Helper function which aims to recreate python-dbus's add_signal_receiver method in dbus_next with asyncio calls. If check_service is True the method will raise a wanrning and return False if the service is not visible on the bus. If the bus_name is None, no check will be performed. Returns True if subscription is successful. Source code in libqtile/utils.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 async def add_signal_receiver ( callback : Callable , session_bus : bool = False , signal_name : str | None = None , dbus_interface : str | None = None , bus_name : str | None = None , path : str | None = None , check_service : bool = False , ) -> bool : \"\"\" Helper function which aims to recreate python-dbus's add_signal_receiver method in dbus_next with asyncio calls. If check_service is `True` the method will raise a wanrning and return False if the service is not visible on the bus. If the `bus_name` is None, no check will be performed. Returns True if subscription is successful. \"\"\" if not has_dbus : logger . warning ( \"dbus-next is not installed. Unable to subscribe to signals\" ) return False if bus_name and check_service : found = await find_dbus_service ( bus_name , session_bus ) if not found : logger . warning ( \"The %s name was not found on the bus. No callback will be attached.\" , bus_name ) return False match_args = { \"type\" : \"signal\" , \"sender\" : bus_name , \"member\" : signal_name , \"path\" : path , \"interface\" : dbus_interface , } rule = \",\" . join ( \" {} =' {} '\" . format ( k , v ) for k , v in match_args . items () if v ) bus , msg = await _send_dbus_message ( session_bus , MessageType . METHOD_CALL , \"org.freedesktop.DBus\" , \"org.freedesktop.DBus\" , \"/org/freedesktop/DBus\" , \"AddMatch\" , \"s\" , rule , ) # Check if message sent successfully if bus and msg and msg . message_type == MessageType . METHOD_RETURN : bus . add_message_handler ( callback ) return True else : return False describe_attributes ( obj , attrs , func = lambda x : x ) Helper for repr functions to list attributes with truthy values only (or values that return a truthy value by func) Source code in libqtile/utils.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def describe_attributes ( obj : Any , attrs : list [ str ], func : Callable = lambda x : x ) -> str : \"\"\" Helper for __repr__ functions to list attributes with truthy values only (or values that return a truthy value by func) \"\"\" pairs = [] for attr in attrs : value = getattr ( obj , attr , None ) if func ( value ): pairs . append ( \" %s = %s \" % ( attr , value )) return \", \" . join ( pairs ) find_dbus_service ( service , session_bus ) async Looks up service name to see if it is currently available on dbus. Source code in libqtile/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 async def find_dbus_service ( service : str , session_bus : bool ) -> bool : \"\"\"Looks up service name to see if it is currently available on dbus.\"\"\" # We're using low level interface here to reduce unnecessary calls for # introspection etc. bus , msg = await _send_dbus_message ( session_bus , MessageType . METHOD_CALL , \"org.freedesktop.DBus\" , \"org.freedesktop.DBus\" , \"/org/freedesktop/DBus\" , \"ListNames\" , \"\" , [], ) if bus is None or msg is None or ( msg and msg . message_type != MessageType . METHOD_RETURN ): logger . warning ( \"Unable to send lookup call to dbus.\" ) return False bus . disconnect () names = msg . body [ 0 ] return service in names get_cache_dir () Returns the cache directory and create if it doesn't exists Source code in libqtile/utils.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def get_cache_dir () -> str : \"\"\" Returns the cache directory and create if it doesn't exists \"\"\" cache_directory = os . path . expandvars ( \"$XDG_CACHE_HOME\" ) if cache_directory == \"$XDG_CACHE_HOME\" : # if variable wasn't set cache_directory = os . path . expanduser ( \"~/.cache\" ) cache_directory = os . path . join ( cache_directory , \"qtile\" ) if not os . path . exists ( cache_directory ): os . makedirs ( cache_directory ) return cache_directory guess_terminal ( preference = None ) Try to guess terminal. Source code in libqtile/utils.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def guess_terminal ( preference : str | Sequence | None = None ) -> str | None : \"\"\"Try to guess terminal.\"\"\" test_terminals = [] if isinstance ( preference , str ): test_terminals += [ preference ] elif isinstance ( preference , Sequence ): test_terminals += list ( preference ) test_terminals += [ \"roxterm\" , \"sakura\" , \"hyper\" , \"alacritty\" , \"terminator\" , \"termite\" , \"gnome-terminal\" , \"konsole\" , \"xfce4-terminal\" , \"lxterminal\" , \"mate-terminal\" , \"kitty\" , \"yakuake\" , \"tilda\" , \"guake\" , \"eterm\" , \"st\" , \"urxvt\" , \"wezterm\" , \"xterm\" , \"x-terminal-emulator\" , ] for terminal in test_terminals : logger . debug ( \"Guessing terminal: %s \" , terminal ) if not which ( terminal , os . X_OK ): continue logger . info ( \"Terminal found: %s \" , terminal ) return terminal logger . error ( \"Default terminal has not been found.\" ) return None has_transparency ( colour ) Returns True if the colour is not fully opaque. Where a list of colours is passed, returns True if any colour is not fully opaque. Source code in libqtile/utils.py 114 115 116 117 118 119 120 121 122 123 def has_transparency ( colour : ColorsType ) -> bool : \"\"\" Returns True if the colour is not fully opaque. Where a list of colours is passed, returns True if any colour is not fully opaque. \"\"\" if isinstance ( colour , ( str , tuple )): return rgb ( colour )[ 3 ] < 1 return any ( has_transparency ( c ) for c in colour ) import_class ( module_path , class_name , fallback = None ) Import a class safely Try to import the class module, and if it fails because of an ImporError it logs on WARNING, and logs the traceback on DEBUG level Source code in libqtile/utils.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def import_class ( module_path : str , class_name : str , fallback : Callable | None = None , ) -> Any : \"\"\"Import a class safely Try to import the class module, and if it fails because of an ImporError it logs on WARNING, and logs the traceback on DEBUG level \"\"\" try : module = importlib . import_module ( module_path , __package__ ) return getattr ( module , class_name ) except ImportError : logger . exception ( \"Unmet dependencies for ' %s . %s ':\" , module_path , class_name ) if fallback : logger . debug ( \" %s \" , traceback . format_exc ()) return fallback ( module_path , class_name ) raise lazify_imports ( registry , package , fallback = None ) Leverage PEP 562 to make imports lazy in an init .py The registry must be a dictionary with the items to import as keys and the modules they belong to as a value. Source code in libqtile/utils.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def lazify_imports ( registry : dict [ str , str ], package : str , fallback : Callable | None = None , ) -> tuple [ tuple [ str , ... ], Callable , Callable ]: \"\"\"Leverage PEP 562 to make imports lazy in an __init__.py The registry must be a dictionary with the items to import as keys and the modules they belong to as a value. \"\"\" __all__ = tuple ( registry . keys ()) def __dir__ () -> tuple [ str , ... ]: return __all__ def __getattr__ ( name : str ) -> Any : if name not in registry : raise AttributeError module_path = \" {} . {} \" . format ( package , registry [ name ]) return import_class ( module_path , name , fallback = fallback ) return __all__ , __dir__ , __getattr__ remove_transparency ( colour ) Returns a tuple of (r, g, b) with no alpha. Source code in libqtile/utils.py 126 127 128 129 130 131 132 def remove_transparency ( colour : ColorsType ): # type: ignore \"\"\" Returns a tuple of (r, g, b) with no alpha. \"\"\" if isinstance ( colour , ( str , tuple )): return tuple ( x * 255.0 for x in rgb ( colour )[: 3 ]) return [ remove_transparency ( c ) for c in colour ] rgb ( x ) Returns a valid RGBA tuple. Here are some valid specifications: #ff0000 with alpha: #ff000080 ff0000 with alpha: ff0000.5 (255, 0, 0) with alpha: (255, 0, 0, 0.5) Which is returned as (1.0, 0.0, 0.0, 0.5). Source code in libqtile/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def rgb ( x : ColorType ) -> tuple [ float , float , float , float ]: \"\"\" Returns a valid RGBA tuple. Here are some valid specifications: #ff0000 with alpha: #ff000080 ff0000 with alpha: ff0000.5 (255, 0, 0) with alpha: (255, 0, 0, 0.5) Which is returned as (1.0, 0.0, 0.0, 0.5). \"\"\" if isinstance ( x , ( tuple , list )): if len ( x ) == 4 : alpha = x [ - 1 ] else : alpha = 1.0 return ( x [ 0 ] / 255.0 , x [ 1 ] / 255.0 , x [ 2 ] / 255.0 , alpha ) elif isinstance ( x , str ): if x . startswith ( \"#\" ): x = x [ 1 :] if \".\" in x : x , alpha_str = x . split ( \".\" ) alpha = float ( \"0.\" + alpha_str ) else : alpha = 1.0 if len ( x ) not in ( 3 , 6 , 8 ): raise ValueError ( \"RGB specifier must be 3, 6 or 8 characters long.\" ) if len ( x ) == 3 : # Multiplying by 17: 0xA * 17 = 0xAA etc. vals = tuple ( int ( i , 16 ) * 17 for i in x ) else : vals = tuple ( int ( i , 16 ) for i in ( x [ 0 : 2 ], x [ 2 : 4 ], x [ 4 : 6 ])) if len ( x ) == 8 : alpha = int ( x [ 6 : 8 ], 16 ) / 255.0 vals += ( alpha ,) # type: ignore return rgb ( vals ) # type: ignore raise ValueError ( \"Invalid RGB specifier.\" ) scan_files ( dirpath , * names ) Search a folder recursively for files matching those passed as arguments, with globbing. Returns a dict with keys equal to entries in names, and values a list of matching paths. E.g.: scan_files('/wallpapers', ' .png', ' .jpg') defaultdict( , {' .png': ['/wallpapers/w1.png'], ' .jpg': ['/wallpapers/w2.jpg', '/wallpapers/w3.jpg']}) Source code in libqtile/utils.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def scan_files ( dirpath : str , * names : str ) -> defaultdict [ str , list [ str ]]: \"\"\" Search a folder recursively for files matching those passed as arguments, with globbing. Returns a dict with keys equal to entries in names, and values a list of matching paths. E.g.: >>> scan_files('/wallpapers', '*.png', '*.jpg') defaultdict(<class 'list'>, {'*.png': ['/wallpapers/w1.png'], '*.jpg': ['/wallpapers/w2.jpg', '/wallpapers/w3.jpg']}) \"\"\" dirpath = os . path . expanduser ( dirpath ) files = defaultdict ( list ) for name in names : found = glob . glob ( os . path . join ( dirpath , \"**\" , name ), recursive = True ) files [ name ] . extend ( found ) return files send_notification ( title , message , urgent = False , timeout = 10000 , id_ = None ) Send a notification. The id_ argument, if passed, requests the notification server to replace a visible notification with the same ID. An ID is returned for each call; this would then be passed when calling this function again to replace that notification. See: https://developer.gnome.org/notification-spec/ Source code in libqtile/utils.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def send_notification ( title : str , message : str , urgent : bool = False , timeout : int = 10000 , id_ : int | None = None , ) -> int : \"\"\" Send a notification. The id_ argument, if passed, requests the notification server to replace a visible notification with the same ID. An ID is returned for each call; this would then be passed when calling this function again to replace that notification. See: https://developer.gnome.org/notification-spec/ \"\"\" if not has_dbus : logger . warning ( \"dbus-next is not installed. Unable to send notifications.\" ) return - 1 id_ = randint ( 10 , 1000 ) if id_ is None else id_ urgency = 2 if urgent else 1 try : loop = asyncio . get_event_loop () except RuntimeError : logger . warning ( \"Eventloop has not started. Cannot send notification.\" ) else : loop . create_task ( _notify ( title , message , urgency , timeout , id_ )) return id_","title":"utils"},{"location":"reference/libqtile/utils/#libqtile.utils.add_signal_receiver","text":"Helper function which aims to recreate python-dbus's add_signal_receiver method in dbus_next with asyncio calls. If check_service is True the method will raise a wanrning and return False if the service is not visible on the bus. If the bus_name is None, no check will be performed. Returns True if subscription is successful. Source code in libqtile/utils.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 async def add_signal_receiver ( callback : Callable , session_bus : bool = False , signal_name : str | None = None , dbus_interface : str | None = None , bus_name : str | None = None , path : str | None = None , check_service : bool = False , ) -> bool : \"\"\" Helper function which aims to recreate python-dbus's add_signal_receiver method in dbus_next with asyncio calls. If check_service is `True` the method will raise a wanrning and return False if the service is not visible on the bus. If the `bus_name` is None, no check will be performed. Returns True if subscription is successful. \"\"\" if not has_dbus : logger . warning ( \"dbus-next is not installed. Unable to subscribe to signals\" ) return False if bus_name and check_service : found = await find_dbus_service ( bus_name , session_bus ) if not found : logger . warning ( \"The %s name was not found on the bus. No callback will be attached.\" , bus_name ) return False match_args = { \"type\" : \"signal\" , \"sender\" : bus_name , \"member\" : signal_name , \"path\" : path , \"interface\" : dbus_interface , } rule = \",\" . join ( \" {} =' {} '\" . format ( k , v ) for k , v in match_args . items () if v ) bus , msg = await _send_dbus_message ( session_bus , MessageType . METHOD_CALL , \"org.freedesktop.DBus\" , \"org.freedesktop.DBus\" , \"/org/freedesktop/DBus\" , \"AddMatch\" , \"s\" , rule , ) # Check if message sent successfully if bus and msg and msg . message_type == MessageType . METHOD_RETURN : bus . add_message_handler ( callback ) return True else : return False","title":"add_signal_receiver()"},{"location":"reference/libqtile/utils/#libqtile.utils.describe_attributes","text":"Helper for repr functions to list attributes with truthy values only (or values that return a truthy value by func) Source code in libqtile/utils.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def describe_attributes ( obj : Any , attrs : list [ str ], func : Callable = lambda x : x ) -> str : \"\"\" Helper for __repr__ functions to list attributes with truthy values only (or values that return a truthy value by func) \"\"\" pairs = [] for attr in attrs : value = getattr ( obj , attr , None ) if func ( value ): pairs . append ( \" %s = %s \" % ( attr , value )) return \", \" . join ( pairs )","title":"describe_attributes()"},{"location":"reference/libqtile/utils/#libqtile.utils.find_dbus_service","text":"Looks up service name to see if it is currently available on dbus. Source code in libqtile/utils.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 async def find_dbus_service ( service : str , session_bus : bool ) -> bool : \"\"\"Looks up service name to see if it is currently available on dbus.\"\"\" # We're using low level interface here to reduce unnecessary calls for # introspection etc. bus , msg = await _send_dbus_message ( session_bus , MessageType . METHOD_CALL , \"org.freedesktop.DBus\" , \"org.freedesktop.DBus\" , \"/org/freedesktop/DBus\" , \"ListNames\" , \"\" , [], ) if bus is None or msg is None or ( msg and msg . message_type != MessageType . METHOD_RETURN ): logger . warning ( \"Unable to send lookup call to dbus.\" ) return False bus . disconnect () names = msg . body [ 0 ] return service in names","title":"find_dbus_service()"},{"location":"reference/libqtile/utils/#libqtile.utils.get_cache_dir","text":"Returns the cache directory and create if it doesn't exists Source code in libqtile/utils.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def get_cache_dir () -> str : \"\"\" Returns the cache directory and create if it doesn't exists \"\"\" cache_directory = os . path . expandvars ( \"$XDG_CACHE_HOME\" ) if cache_directory == \"$XDG_CACHE_HOME\" : # if variable wasn't set cache_directory = os . path . expanduser ( \"~/.cache\" ) cache_directory = os . path . join ( cache_directory , \"qtile\" ) if not os . path . exists ( cache_directory ): os . makedirs ( cache_directory ) return cache_directory","title":"get_cache_dir()"},{"location":"reference/libqtile/utils/#libqtile.utils.guess_terminal","text":"Try to guess terminal. Source code in libqtile/utils.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def guess_terminal ( preference : str | Sequence | None = None ) -> str | None : \"\"\"Try to guess terminal.\"\"\" test_terminals = [] if isinstance ( preference , str ): test_terminals += [ preference ] elif isinstance ( preference , Sequence ): test_terminals += list ( preference ) test_terminals += [ \"roxterm\" , \"sakura\" , \"hyper\" , \"alacritty\" , \"terminator\" , \"termite\" , \"gnome-terminal\" , \"konsole\" , \"xfce4-terminal\" , \"lxterminal\" , \"mate-terminal\" , \"kitty\" , \"yakuake\" , \"tilda\" , \"guake\" , \"eterm\" , \"st\" , \"urxvt\" , \"wezterm\" , \"xterm\" , \"x-terminal-emulator\" , ] for terminal in test_terminals : logger . debug ( \"Guessing terminal: %s \" , terminal ) if not which ( terminal , os . X_OK ): continue logger . info ( \"Terminal found: %s \" , terminal ) return terminal logger . error ( \"Default terminal has not been found.\" ) return None","title":"guess_terminal()"},{"location":"reference/libqtile/utils/#libqtile.utils.has_transparency","text":"Returns True if the colour is not fully opaque. Where a list of colours is passed, returns True if any colour is not fully opaque. Source code in libqtile/utils.py 114 115 116 117 118 119 120 121 122 123 def has_transparency ( colour : ColorsType ) -> bool : \"\"\" Returns True if the colour is not fully opaque. Where a list of colours is passed, returns True if any colour is not fully opaque. \"\"\" if isinstance ( colour , ( str , tuple )): return rgb ( colour )[ 3 ] < 1 return any ( has_transparency ( c ) for c in colour )","title":"has_transparency()"},{"location":"reference/libqtile/utils/#libqtile.utils.import_class","text":"Import a class safely Try to import the class module, and if it fails because of an ImporError it logs on WARNING, and logs the traceback on DEBUG level Source code in libqtile/utils.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def import_class ( module_path : str , class_name : str , fallback : Callable | None = None , ) -> Any : \"\"\"Import a class safely Try to import the class module, and if it fails because of an ImporError it logs on WARNING, and logs the traceback on DEBUG level \"\"\" try : module = importlib . import_module ( module_path , __package__ ) return getattr ( module , class_name ) except ImportError : logger . exception ( \"Unmet dependencies for ' %s . %s ':\" , module_path , class_name ) if fallback : logger . debug ( \" %s \" , traceback . format_exc ()) return fallback ( module_path , class_name ) raise","title":"import_class()"},{"location":"reference/libqtile/utils/#libqtile.utils.lazify_imports","text":"Leverage PEP 562 to make imports lazy in an init .py The registry must be a dictionary with the items to import as keys and the modules they belong to as a value. Source code in libqtile/utils.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def lazify_imports ( registry : dict [ str , str ], package : str , fallback : Callable | None = None , ) -> tuple [ tuple [ str , ... ], Callable , Callable ]: \"\"\"Leverage PEP 562 to make imports lazy in an __init__.py The registry must be a dictionary with the items to import as keys and the modules they belong to as a value. \"\"\" __all__ = tuple ( registry . keys ()) def __dir__ () -> tuple [ str , ... ]: return __all__ def __getattr__ ( name : str ) -> Any : if name not in registry : raise AttributeError module_path = \" {} . {} \" . format ( package , registry [ name ]) return import_class ( module_path , name , fallback = fallback ) return __all__ , __dir__ , __getattr__","title":"lazify_imports()"},{"location":"reference/libqtile/utils/#libqtile.utils.remove_transparency","text":"Returns a tuple of (r, g, b) with no alpha. Source code in libqtile/utils.py 126 127 128 129 130 131 132 def remove_transparency ( colour : ColorsType ): # type: ignore \"\"\" Returns a tuple of (r, g, b) with no alpha. \"\"\" if isinstance ( colour , ( str , tuple )): return tuple ( x * 255.0 for x in rgb ( colour )[: 3 ]) return [ remove_transparency ( c ) for c in colour ]","title":"remove_transparency()"},{"location":"reference/libqtile/utils/#libqtile.utils.rgb","text":"Returns a valid RGBA tuple. Here are some valid specifications: #ff0000 with alpha: #ff000080 ff0000 with alpha: ff0000.5 (255, 0, 0) with alpha: (255, 0, 0, 0.5) Which is returned as (1.0, 0.0, 0.0, 0.5). Source code in libqtile/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def rgb ( x : ColorType ) -> tuple [ float , float , float , float ]: \"\"\" Returns a valid RGBA tuple. Here are some valid specifications: #ff0000 with alpha: #ff000080 ff0000 with alpha: ff0000.5 (255, 0, 0) with alpha: (255, 0, 0, 0.5) Which is returned as (1.0, 0.0, 0.0, 0.5). \"\"\" if isinstance ( x , ( tuple , list )): if len ( x ) == 4 : alpha = x [ - 1 ] else : alpha = 1.0 return ( x [ 0 ] / 255.0 , x [ 1 ] / 255.0 , x [ 2 ] / 255.0 , alpha ) elif isinstance ( x , str ): if x . startswith ( \"#\" ): x = x [ 1 :] if \".\" in x : x , alpha_str = x . split ( \".\" ) alpha = float ( \"0.\" + alpha_str ) else : alpha = 1.0 if len ( x ) not in ( 3 , 6 , 8 ): raise ValueError ( \"RGB specifier must be 3, 6 or 8 characters long.\" ) if len ( x ) == 3 : # Multiplying by 17: 0xA * 17 = 0xAA etc. vals = tuple ( int ( i , 16 ) * 17 for i in x ) else : vals = tuple ( int ( i , 16 ) for i in ( x [ 0 : 2 ], x [ 2 : 4 ], x [ 4 : 6 ])) if len ( x ) == 8 : alpha = int ( x [ 6 : 8 ], 16 ) / 255.0 vals += ( alpha ,) # type: ignore return rgb ( vals ) # type: ignore raise ValueError ( \"Invalid RGB specifier.\" )","title":"rgb()"},{"location":"reference/libqtile/utils/#libqtile.utils.scan_files","text":"Search a folder recursively for files matching those passed as arguments, with globbing. Returns a dict with keys equal to entries in names, and values a list of matching paths. E.g.: scan_files('/wallpapers', ' .png', ' .jpg') defaultdict( , {' .png': ['/wallpapers/w1.png'], ' .jpg': ['/wallpapers/w2.jpg', '/wallpapers/w3.jpg']}) Source code in libqtile/utils.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def scan_files ( dirpath : str , * names : str ) -> defaultdict [ str , list [ str ]]: \"\"\" Search a folder recursively for files matching those passed as arguments, with globbing. Returns a dict with keys equal to entries in names, and values a list of matching paths. E.g.: >>> scan_files('/wallpapers', '*.png', '*.jpg') defaultdict(<class 'list'>, {'*.png': ['/wallpapers/w1.png'], '*.jpg': ['/wallpapers/w2.jpg', '/wallpapers/w3.jpg']}) \"\"\" dirpath = os . path . expanduser ( dirpath ) files = defaultdict ( list ) for name in names : found = glob . glob ( os . path . join ( dirpath , \"**\" , name ), recursive = True ) files [ name ] . extend ( found ) return files","title":"scan_files()"},{"location":"reference/libqtile/utils/#libqtile.utils.send_notification","text":"Send a notification. The id_ argument, if passed, requests the notification server to replace a visible notification with the same ID. An ID is returned for each call; this would then be passed when calling this function again to replace that notification. See: https://developer.gnome.org/notification-spec/ Source code in libqtile/utils.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def send_notification ( title : str , message : str , urgent : bool = False , timeout : int = 10000 , id_ : int | None = None , ) -> int : \"\"\" Send a notification. The id_ argument, if passed, requests the notification server to replace a visible notification with the same ID. An ID is returned for each call; this would then be passed when calling this function again to replace that notification. See: https://developer.gnome.org/notification-spec/ \"\"\" if not has_dbus : logger . warning ( \"dbus-next is not installed. Unable to send notifications.\" ) return - 1 id_ = randint ( 10 , 1000 ) if id_ is None else id_ urgency = 2 if urgent else 1 try : loop = asyncio . get_event_loop () except RuntimeError : logger . warning ( \"Eventloop has not started. Cannot send notification.\" ) else : loop . create_task ( _notify ( title , message , urgency , timeout , id_ )) return id_","title":"send_notification()"},{"location":"reference/libqtile/backend/","text":"","title":"backend"},{"location":"reference/libqtile/backend/base/","text":"Core Bases: CommandObject create_internal ( x , y , width , height ) Create an internal window controlled by Qtile. Source code in libqtile/backend/base.py 109 110 111 def create_internal ( self , x : int , y : int , width : int , height : int ) -> Internal : \"\"\"Create an internal window controlled by Qtile.\"\"\" raise NotImplementedError # Only error when called, not when instantiating class finalize () abstractmethod Destructor/Clean up resources Source code in libqtile/backend/base.py 41 42 43 @abstractmethod def finalize ( self ): \"\"\"Destructor/Clean up resources\"\"\" flush () If needed, flush the backend's event queue. Source code in libqtile/backend/base.py 113 114 def flush ( self ) -> None : \"\"\"If needed, flush the backend's event queue.\"\"\" get_screen_info () abstractmethod Get the screen information Source code in libqtile/backend/base.py 61 62 63 @abstractmethod def get_screen_info ( self ) -> list [ tuple [ int , int , int , int ]]: \"\"\"Get the screen information\"\"\" grab_button ( mouse ) abstractmethod Configure the backend to grab the mouse event Source code in libqtile/backend/base.py 77 78 79 @abstractmethod def grab_button ( self , mouse : config . Mouse ) -> int : \"\"\"Configure the backend to grab the mouse event\"\"\" grab_key ( key ) abstractmethod Configure the backend to grab the key event Source code in libqtile/backend/base.py 65 66 67 @abstractmethod def grab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Configure the backend to grab the key event\"\"\" grab_pointer () abstractmethod Configure the backend to grab mouse events Source code in libqtile/backend/base.py 85 86 87 @abstractmethod def grab_pointer ( self ) -> None : \"\"\"Configure the backend to grab mouse events\"\"\" graceful_shutdown () Try to close windows gracefully before exiting Source code in libqtile/backend/base.py 116 117 def graceful_shutdown ( self ): \"\"\"Try to close windows gracefully before exiting\"\"\" info () Get basic information about the running backend. Source code in libqtile/backend/base.py 126 127 128 129 @expose_command () def info ( self ) -> dict [ str , Any ]: \"\"\"Get basic information about the running backend.\"\"\" return { \"backend\" : self . name , \"display_name\" : self . display_name } keysym_from_name ( name ) Get the keysym for a key from its name Source code in libqtile/backend/base.py 122 123 124 def keysym_from_name ( self , name : str ) -> int : \"\"\"Get the keysym for a key from its name\"\"\" raise NotImplementedError masked () A context manager to suppress window events while operating on many windows. Source code in libqtile/backend/base.py 104 105 106 107 @contextlib . contextmanager def masked ( self ): \"\"\"A context manager to suppress window events while operating on many windows.\"\"\" yield name () abstractmethod property The name of the backend Source code in libqtile/backend/base.py 29 30 31 32 33 @property @abstractmethod def name ( self ) -> str : \"\"\"The name of the backend\"\"\" pass on_config_load ( initial ) Respond to config loading. initial will be True if Qtile just started. Source code in libqtile/backend/base.py 93 94 95 96 def on_config_load ( self , initial : bool ) -> None : \"\"\" Respond to config loading. `initial` will be `True` if Qtile just started. \"\"\" remove_listener () abstractmethod Setup a listener for the given qtile instance Source code in libqtile/backend/base.py 54 55 56 @abstractmethod def remove_listener ( self ) -> None : \"\"\"Setup a listener for the given qtile instance\"\"\" setup_listener ( qtile ) abstractmethod Setup a listener for the given qtile instance Source code in libqtile/backend/base.py 50 51 52 @abstractmethod def setup_listener ( self , qtile : Qtile ) -> None : \"\"\"Setup a listener for the given qtile instance\"\"\" simulate_keypress ( modifiers , key ) Simulate a keypress with given modifiers Source code in libqtile/backend/base.py 119 120 def simulate_keypress ( self , modifiers : list [ str ], key : str ) -> None : \"\"\"Simulate a keypress with given modifiers\"\"\" ungrab_buttons () abstractmethod Release the grabbed button events Source code in libqtile/backend/base.py 81 82 83 @abstractmethod def ungrab_buttons ( self ) -> None : \"\"\"Release the grabbed button events\"\"\" ungrab_key ( key ) abstractmethod Release the given key event Source code in libqtile/backend/base.py 69 70 71 @abstractmethod def ungrab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Release the given key event\"\"\" ungrab_keys () abstractmethod Release the grabbed key events Source code in libqtile/backend/base.py 73 74 75 @abstractmethod def ungrab_keys ( self ) -> None : \"\"\"Release the grabbed key events\"\"\" ungrab_pointer () abstractmethod Release grabbed pointer events Source code in libqtile/backend/base.py 89 90 91 @abstractmethod def ungrab_pointer ( self ) -> None : \"\"\"Release grabbed pointer events\"\"\" update_client_list ( windows_map ) Update the list of windows being managed Source code in libqtile/backend/base.py 101 102 def update_client_list ( self , windows_map : dict [ int , WindowType ]) -> None : \"\"\"Update the list of windows being managed\"\"\" update_desktops ( groups , index ) Set the current desktops of the window manager Source code in libqtile/backend/base.py 58 59 def update_desktops ( self , groups : list [ _Group ], index : int ) -> None : \"\"\"Set the current desktops of the window manager\"\"\" warp_pointer ( x , y ) Warp the pointer to the given coordinates relative. Source code in libqtile/backend/base.py 98 99 def warp_pointer ( self , x : int , y : int ) -> None : \"\"\"Warp the pointer to the given coordinates relative.\"\"\" Drawer ( qtile , win , width , height ) A helper class for drawing to Internal windows. We stage drawing operations locally in memory using a cairo RecordingSurface before finally drawing all operations to a backend-specific target. Source code in libqtile/backend/base.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def __init__ ( self , qtile : Qtile , win : Internal , width : int , height : int ): self . qtile = qtile self . _win = win self . _width = width self . _height = height self . surface : cairocffi . RecordingSurface self . last_surface : cairocffi . RecordingSurface self . ctx : cairocffi . Context self . _reset_surface () self . _has_mirrors = False self . current_rect = ( 0 , 0 , 0 , 0 ) self . previous_rect = ( - 1 , - 1 , - 1 , - 1 ) self . _enabled = True disable () Disable drawing of surface to Internal window. Source code in libqtile/backend/base.py 756 757 758 def disable ( self ): \"\"\"Disable drawing of surface to Internal window.\"\"\" self . _enabled = False draw ( offsetx = 0 , offsety = 0 , width = None , height = None ) A wrapper for the draw operation. This draws our cached operations to the Internal window. If Drawer has been disabled then the RecordingSurface will be cleared if no mirrors are waiting to copy its contents. Parameters offsetx : the X offset to start drawing at. offsety : the Y offset to start drawing at. width : the X portion of the canvas to draw at the starting point. height : the Y portion of the canvas to draw at the starting point. Source code in libqtile/backend/base.py 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 def draw ( self , offsetx : int = 0 , offsety : int = 0 , width : int | None = None , height : int | None = None , ): \"\"\" A wrapper for the draw operation. This draws our cached operations to the Internal window. If Drawer has been disabled then the RecordingSurface will be cleared if no mirrors are waiting to copy its contents. Parameters ========== offsetx : the X offset to start drawing at. offsety : the Y offset to start drawing at. width : the X portion of the canvas to draw at the starting point. height : the Y portion of the canvas to draw at the starting point. \"\"\" if self . _enabled : self . _draw ( offsetx , offsety , width , height ) if self . has_mirrors : self . _create_last_surface () ctx = cairocffi . Context ( self . last_surface ) ctx . set_source_surface ( self . surface ) ctx . paint () self . _reset_surface () enable () Enable drawing of surface to Internal window. Source code in libqtile/backend/base.py 752 753 754 def enable ( self ): \"\"\"Enable drawing of surface to Internal window.\"\"\" self . _enabled = True finalize () Destructor/Clean up resources Source code in libqtile/backend/base.py 656 657 658 659 def finalize ( self ): \"\"\"Destructor/Clean up resources\"\"\" self . surface = None self . ctx = None fit_fontsize ( heightlimit ) Try to find a maximum font size that fits any strings within the height Source code in libqtile/backend/base.py 872 873 874 875 876 877 def fit_fontsize ( self , heightlimit ): \"\"\"Try to find a maximum font size that fits any strings within the height\"\"\" self . ctx . set_font_size ( heightlimit ) asc , desc , height , _ , _ = self . font_extents () self . ctx . set_font_size ( int ( heightlimit * heightlimit / height )) return self . font_extents () fit_text ( strings , heightlimit ) Try to find a maximum font size that fits all strings within the height Source code in libqtile/backend/base.py 879 880 881 882 883 884 885 886 887 888 889 890 891 def fit_text ( self , strings , heightlimit ): \"\"\"Try to find a maximum font size that fits all strings within the height\"\"\" self . ctx . set_font_size ( heightlimit ) _ , _ , _ , maxheight , _ , _ = self . ctx . text_extents ( \"\" . join ( strings )) if not maxheight : return 0 , 0 self . ctx . set_font_size ( int ( heightlimit * heightlimit / maxheight )) maxwidth , maxheight = 0 , 0 for i in strings : _ , _ , x , y , _ , _ = self . ctx . text_extents ( i ) maxwidth = max ( maxwidth , x ) maxheight = max ( maxheight , y ) return maxwidth , maxheight textlayout ( text , colour , font_family , font_size , font_shadow , markup = False , ** kw ) Get a text layout Source code in libqtile/backend/base.py 850 851 852 853 854 855 def textlayout ( self , text , colour , font_family , font_size , font_shadow , markup = False , ** kw ): \"\"\"Get a text layout\"\"\" textlayout = drawer . TextLayout ( self , text , colour , font_family , font_size , font_shadow , markup = markup , ** kw ) return textlayout Internal Bases: _Window An Internal window belonging to Qtile. create_drawer ( width , height ) abstractmethod Create a Drawer that draws to this window. Source code in libqtile/backend/base.py 568 569 570 @abstractmethod def create_drawer ( self , width : int , height : int ) -> Drawer : \"\"\"Create a Drawer that draws to this window.\"\"\" process_button_click ( x , y , button ) Handle a pointer button click. Source code in libqtile/backend/base.py 575 576 def process_button_click ( self , x : int , y : int , button : int ) -> None : \"\"\"Handle a pointer button click.\"\"\" process_button_release ( x , y , button ) Handle a pointer button release. Source code in libqtile/backend/base.py 578 579 def process_button_release ( self , x : int , y : int , button : int ) -> None : \"\"\"Handle a pointer button release.\"\"\" process_key_press ( keycode ) Handle a key press. Source code in libqtile/backend/base.py 590 591 def process_key_press ( self , keycode : int ) -> None : \"\"\"Handle a key press.\"\"\" process_pointer_enter ( x , y ) Handle the pointer entering the window. Source code in libqtile/backend/base.py 581 582 def process_pointer_enter ( self , x : int , y : int ) -> None : \"\"\"Handle the pointer entering the window.\"\"\" process_pointer_leave ( x , y ) Handle the pointer leaving the window. Source code in libqtile/backend/base.py 584 585 def process_pointer_leave ( self , x : int , y : int ) -> None : \"\"\"Handle the pointer leaving the window.\"\"\" process_pointer_motion ( x , y ) Handle pointer motion within the window. Source code in libqtile/backend/base.py 587 588 def process_pointer_motion ( self , x : int , y : int ) -> None : \"\"\"Handle pointer motion within the window.\"\"\" process_window_expose () Respond to the window being exposed. Required by X11 backend. Source code in libqtile/backend/base.py 572 573 def process_window_expose ( self ) -> None : \"\"\"Respond to the window being exposed. Required by X11 backend.\"\"\" Static Bases: _Window A window bound to a screen rather than a group. bring_to_front () abstractmethod Bring the window to the front Source code in libqtile/backend/base.py 619 620 621 622 @abstractmethod @expose_command () def bring_to_front ( self ) -> None : \"\"\"Bring the window to the front\"\"\" info () Return a dictionary of info. Source code in libqtile/backend/base.py 606 607 608 609 610 611 612 613 614 615 616 617 @expose_command () def info ( self ) -> dict : \"\"\"Return a dictionary of info.\"\"\" return dict ( name = self . name , wm_class = self . get_wm_class (), x = self . x , y = self . y , width = self . width , height = self . height , id = self . wid , ) Window Bases: _Window A regular Window belonging to a client. Abstract methods are required to be defined as part of a specific backend's implementation. Non-abstract methods have default implementations here to be shared across backends. bring_to_front () abstractmethod Bring the window to the front Source code in libqtile/backend/base.py 430 431 432 433 @abstractmethod @expose_command () def bring_to_front ( self ) -> None : \"\"\"Bring the window to the front\"\"\" center () Centers a floating window on the screen. Source code in libqtile/backend/base.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 @expose_command () def center ( self ) -> None : \"\"\"Centers a floating window on the screen.\"\"\" if not self . floating : return if not ( self . group and self . group . screen ): return screen = self . group . screen x = screen . x + ( screen . width - self . width ) // 2 y = screen . y + ( screen . height - self . height ) // 2 self . place ( x , y , self . width , self . height , self . borderwidth , self . bordercolor , above = True , respect_hints = True , ) disable_floating () abstractmethod Tile the window. Source code in libqtile/backend/base.py 400 401 402 403 @abstractmethod @expose_command () def disable_floating ( self ) -> None : \"\"\"Tile the window.\"\"\" disable_fullscreen () abstractmethod Un-fullscreen the window Source code in libqtile/backend/base.py 425 426 427 428 @abstractmethod @expose_command () def disable_fullscreen ( self ) -> None : \"\"\"Un-fullscreen the window\"\"\" down_opacity () Decrease the window's opacity by 10%. Source code in libqtile/backend/base.py 510 511 512 513 @expose_command () def down_opacity ( self ) -> None : \"\"\"Decrease the window's opacity by 10%.\"\"\" self . set_opacity ( self . opacity - 0.1 ) enable_floating () abstractmethod Float the window. Source code in libqtile/backend/base.py 395 396 397 398 @abstractmethod @expose_command () def enable_floating ( self ) -> None : \"\"\"Float the window.\"\"\" enable_fullscreen () abstractmethod Fullscreen the window Source code in libqtile/backend/base.py 420 421 422 423 @abstractmethod @expose_command () def enable_fullscreen ( self ) -> None : \"\"\"Fullscreen the window\"\"\" floating () property writable Whether this window is floating. Source code in libqtile/backend/base.py 283 284 285 286 @property def floating ( self ) -> bool : \"\"\"Whether this window is floating.\"\"\" return False focus ( warp = True ) abstractmethod Focus this window and optional warp the pointer to it. Source code in libqtile/backend/base.py 328 329 330 331 @abstractmethod @expose_command () def focus ( self , warp : bool = True ) -> None : \"\"\"Focus this window and optional warp the pointer to it.\"\"\" fullscreen () property writable Whether this window is fullscreened. Source code in libqtile/backend/base.py 310 311 312 313 @property def fullscreen ( self ) -> bool : \"\"\"Whether this window is fullscreened.\"\"\" return False get_pid () abstractmethod Return the PID that owns the window. Source code in libqtile/backend/base.py 345 346 347 @abstractmethod def get_pid ( self ) -> int : \"\"\"Return the PID that owns the window.\"\"\" get_position () abstractmethod Get the (x, y) of the window Source code in libqtile/backend/base.py 352 353 354 355 @abstractmethod @expose_command () def get_position ( self ) -> tuple [ int , int ]: \"\"\"Get the (x, y) of the window\"\"\" get_size () abstractmethod Get the (width, height) of the window Source code in libqtile/backend/base.py 357 358 359 360 @abstractmethod @expose_command () def get_size ( self ) -> tuple [ int , int ]: \"\"\"Get the (width, height) of the window\"\"\" group () abstractmethod property writable The group to which this window belongs. Source code in libqtile/backend/base.py 274 275 276 277 @property @abstractmethod def group ( self ) -> _Group | None : \"\"\"The group to which this window belongs.\"\"\" has_user_set_position () Whether this window has user-defined geometry Source code in libqtile/backend/base.py 337 338 339 def has_user_set_position ( self ) -> bool : \"\"\"Whether this window has user-defined geometry\"\"\" return False is_transient_for () What window is this window a transient window for? Source code in libqtile/backend/base.py 341 342 343 def is_transient_for ( self ) -> WindowType | None : \"\"\"What window is this window a transient window for?\"\"\" return None match ( match ) Compare this window against a Match instance. Source code in libqtile/backend/base.py 324 325 326 def match ( self , match : config . Match ) -> bool : \"\"\"Compare this window against a Match instance.\"\"\" return match . compare ( self ) maximized () property writable Whether this window is maximized. Source code in libqtile/backend/base.py 292 293 294 295 @property def maximized ( self ) -> bool : \"\"\"Whether this window is maximized.\"\"\" return False minimized () property writable Whether this window is minimized. Source code in libqtile/backend/base.py 301 302 303 304 @property def minimized ( self ) -> bool : \"\"\"Whether this window is minimized.\"\"\" return False move_floating ( dx , dy ) abstractmethod Move window by dx and dy Source code in libqtile/backend/base.py 362 363 364 365 @abstractmethod @expose_command () def move_floating ( self , dx : int , dy : int ) -> None : \"\"\"Move window by dx and dy\"\"\" paint_borders ( color , width ) Paint the window borders with the given color(s) and width Source code in libqtile/backend/base.py 349 350 def paint_borders ( self , color : ColorsType , width : int ) -> None : \"\"\"Paint the window borders with the given color(s) and width\"\"\" resize_floating ( dw , dh ) abstractmethod Add dw and dh to size of window Source code in libqtile/backend/base.py 367 368 369 370 @abstractmethod @expose_command () def resize_floating ( self , dw : int , dh : int ) -> None : \"\"\"Add dw and dh to size of window\"\"\" set_opacity ( opacity ) Set the window's opacity Source code in libqtile/backend/base.py 500 501 502 503 504 505 506 507 508 @expose_command () def set_opacity ( self , opacity : float ) -> None : \"\"\"Set the window's opacity\"\"\" if opacity < 0.1 : self . opacity = 0.1 elif opacity > 1 : self . opacity = 1 else : self . opacity = opacity set_position ( x , y ) abstractmethod Move floating window to x and y; swap tiling window with the window under the pointer. Source code in libqtile/backend/base.py 377 378 379 380 381 382 383 @abstractmethod @expose_command () def set_position ( self , x : int , y : int ) -> None : \"\"\" Move floating window to x and y; swap tiling window with the window under the pointer. \"\"\" set_position_floating ( x , y ) abstractmethod Move window to x and y Source code in libqtile/backend/base.py 372 373 374 375 @abstractmethod @expose_command () def set_position_floating ( self , x : int , y : int ) -> None : \"\"\"Move window to x and y\"\"\" set_size_floating ( w , h ) abstractmethod Set window dimensions to w and h Source code in libqtile/backend/base.py 385 386 387 388 @abstractmethod @expose_command () def set_size_floating ( self , w : int , h : int ) -> None : \"\"\"Set window dimensions to w and h\"\"\" static ( screen = None , x = None , y = None , width = None , height = None ) abstractmethod Makes this window a static window, attached to a Screen. Values left unspecified are taken from the existing window state. Source code in libqtile/backend/base.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 @abstractmethod @expose_command () def static ( self , screen : int | None = None , x : int | None = None , y : int | None = None , width : int | None = None , height : int | None = None , ) -> None : \"\"\"Makes this window a static window, attached to a Screen. Values left unspecified are taken from the existing window state. \"\"\" self . defunct = True toggle_floating () abstractmethod Toggle the floating state of the window. Source code in libqtile/backend/base.py 390 391 392 393 @abstractmethod @expose_command () def toggle_floating ( self ) -> None : \"\"\"Toggle the floating state of the window.\"\"\" toggle_fullscreen () abstractmethod Toggle the fullscreen state of the window. Source code in libqtile/backend/base.py 415 416 417 418 @abstractmethod @expose_command () def toggle_fullscreen ( self ) -> None : \"\"\"Toggle the fullscreen state of the window.\"\"\" toggle_maximize () abstractmethod Toggle the fullscreen state of the window. Source code in libqtile/backend/base.py 405 406 407 408 @abstractmethod @expose_command () def toggle_maximize ( self ) -> None : \"\"\"Toggle the fullscreen state of the window.\"\"\" toggle_minimize () abstractmethod Toggle the minimized state of the window. Source code in libqtile/backend/base.py 410 411 412 413 @abstractmethod @expose_command () def toggle_minimize ( self ) -> None : \"\"\"Toggle the minimized state of the window.\"\"\" togroup ( group_name = None , groupName = None , switch_group = False , toggle = False ) abstractmethod Move window to a specified group Also switch to that group if switch_group is True. If toggle is True and and the specified group is already on the screen, use the last used group as target instead. groupName is deprecated and will be dropped soon. Please use group_name instead. Examples Move window to current group:: togroup() Move window to group \"a\":: togroup(\"a\") Move window to group \"a\", and switch to group \"a\":: togroup(\"a\", switch_group=True) Source code in libqtile/backend/base.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 @abstractmethod @expose_command () def togroup ( self , group_name : str | None = None , groupName : str | None = None , # Deprecated # noqa: N803 switch_group : bool = False , toggle : bool = False , ) -> None : \"\"\"Move window to a specified group Also switch to that group if `switch_group` is True. If `toggle` is True and and the specified group is already on the screen, use the last used group as target instead. `groupName` is deprecated and will be dropped soon. Please use `group_name` instead. Examples ======== Move window to current group:: togroup() Move window to group \"a\":: togroup(\"a\") Move window to group \"a\", and switch to group \"a\":: togroup(\"a\", switch_group=True) \"\"\" if groupName is not None : logger . warning ( \"Window.togroup's groupName is deprecated; use group_name\" ) group_name = groupName self . togroup ( group_name , switch_group = switch_group , toggle = toggle ) toscreen ( index = None ) Move window to a specified screen. If index is not specified, we assume the current screen Examples Move window to current screen:: toscreen() Move window to screen 0:: toscreen(0) Source code in libqtile/backend/base.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 @expose_command () def toscreen ( self , index : int | None = None ) -> None : \"\"\"Move window to a specified screen. If index is not specified, we assume the current screen Examples ======== Move window to current screen:: toscreen() Move window to screen 0:: toscreen(0) \"\"\" if index is None : screen = self . qtile . current_screen else : try : screen = self . qtile . screens [ index ] except IndexError : raise CommandError ( \"No such screen: %d \" % index ) self . togroup ( screen . group . name ) up_opacity () Increase the window's opacity by 10%. Source code in libqtile/backend/base.py 515 516 517 518 @expose_command () def up_opacity ( self ) -> None : \"\"\"Increase the window's opacity by 10%.\"\"\" self . set_opacity ( self . opacity + 0.1 ) wants_to_fullscreen () property Does this window want to be fullscreen? Source code in libqtile/backend/base.py 319 320 321 322 @property def wants_to_fullscreen ( self ) -> bool : \"\"\"Does this window want to be fullscreen?\"\"\" return False","title":"base"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core","text":"Bases: CommandObject","title":"Core"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.create_internal","text":"Create an internal window controlled by Qtile. Source code in libqtile/backend/base.py 109 110 111 def create_internal ( self , x : int , y : int , width : int , height : int ) -> Internal : \"\"\"Create an internal window controlled by Qtile.\"\"\" raise NotImplementedError # Only error when called, not when instantiating class","title":"create_internal()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.finalize","text":"Destructor/Clean up resources Source code in libqtile/backend/base.py 41 42 43 @abstractmethod def finalize ( self ): \"\"\"Destructor/Clean up resources\"\"\"","title":"finalize()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.flush","text":"If needed, flush the backend's event queue. Source code in libqtile/backend/base.py 113 114 def flush ( self ) -> None : \"\"\"If needed, flush the backend's event queue.\"\"\"","title":"flush()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.get_screen_info","text":"Get the screen information Source code in libqtile/backend/base.py 61 62 63 @abstractmethod def get_screen_info ( self ) -> list [ tuple [ int , int , int , int ]]: \"\"\"Get the screen information\"\"\"","title":"get_screen_info()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.grab_button","text":"Configure the backend to grab the mouse event Source code in libqtile/backend/base.py 77 78 79 @abstractmethod def grab_button ( self , mouse : config . Mouse ) -> int : \"\"\"Configure the backend to grab the mouse event\"\"\"","title":"grab_button()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.grab_key","text":"Configure the backend to grab the key event Source code in libqtile/backend/base.py 65 66 67 @abstractmethod def grab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Configure the backend to grab the key event\"\"\"","title":"grab_key()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.grab_pointer","text":"Configure the backend to grab mouse events Source code in libqtile/backend/base.py 85 86 87 @abstractmethod def grab_pointer ( self ) -> None : \"\"\"Configure the backend to grab mouse events\"\"\"","title":"grab_pointer()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.graceful_shutdown","text":"Try to close windows gracefully before exiting Source code in libqtile/backend/base.py 116 117 def graceful_shutdown ( self ): \"\"\"Try to close windows gracefully before exiting\"\"\"","title":"graceful_shutdown()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.info","text":"Get basic information about the running backend. Source code in libqtile/backend/base.py 126 127 128 129 @expose_command () def info ( self ) -> dict [ str , Any ]: \"\"\"Get basic information about the running backend.\"\"\" return { \"backend\" : self . name , \"display_name\" : self . display_name }","title":"info()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.keysym_from_name","text":"Get the keysym for a key from its name Source code in libqtile/backend/base.py 122 123 124 def keysym_from_name ( self , name : str ) -> int : \"\"\"Get the keysym for a key from its name\"\"\" raise NotImplementedError","title":"keysym_from_name()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.masked","text":"A context manager to suppress window events while operating on many windows. Source code in libqtile/backend/base.py 104 105 106 107 @contextlib . contextmanager def masked ( self ): \"\"\"A context manager to suppress window events while operating on many windows.\"\"\" yield","title":"masked()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.name","text":"The name of the backend Source code in libqtile/backend/base.py 29 30 31 32 33 @property @abstractmethod def name ( self ) -> str : \"\"\"The name of the backend\"\"\" pass","title":"name()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.on_config_load","text":"Respond to config loading. initial will be True if Qtile just started. Source code in libqtile/backend/base.py 93 94 95 96 def on_config_load ( self , initial : bool ) -> None : \"\"\" Respond to config loading. `initial` will be `True` if Qtile just started. \"\"\"","title":"on_config_load()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.remove_listener","text":"Setup a listener for the given qtile instance Source code in libqtile/backend/base.py 54 55 56 @abstractmethod def remove_listener ( self ) -> None : \"\"\"Setup a listener for the given qtile instance\"\"\"","title":"remove_listener()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.setup_listener","text":"Setup a listener for the given qtile instance Source code in libqtile/backend/base.py 50 51 52 @abstractmethod def setup_listener ( self , qtile : Qtile ) -> None : \"\"\"Setup a listener for the given qtile instance\"\"\"","title":"setup_listener()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.simulate_keypress","text":"Simulate a keypress with given modifiers Source code in libqtile/backend/base.py 119 120 def simulate_keypress ( self , modifiers : list [ str ], key : str ) -> None : \"\"\"Simulate a keypress with given modifiers\"\"\"","title":"simulate_keypress()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.ungrab_buttons","text":"Release the grabbed button events Source code in libqtile/backend/base.py 81 82 83 @abstractmethod def ungrab_buttons ( self ) -> None : \"\"\"Release the grabbed button events\"\"\"","title":"ungrab_buttons()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.ungrab_key","text":"Release the given key event Source code in libqtile/backend/base.py 69 70 71 @abstractmethod def ungrab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Release the given key event\"\"\"","title":"ungrab_key()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.ungrab_keys","text":"Release the grabbed key events Source code in libqtile/backend/base.py 73 74 75 @abstractmethod def ungrab_keys ( self ) -> None : \"\"\"Release the grabbed key events\"\"\"","title":"ungrab_keys()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.ungrab_pointer","text":"Release grabbed pointer events Source code in libqtile/backend/base.py 89 90 91 @abstractmethod def ungrab_pointer ( self ) -> None : \"\"\"Release grabbed pointer events\"\"\"","title":"ungrab_pointer()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.update_client_list","text":"Update the list of windows being managed Source code in libqtile/backend/base.py 101 102 def update_client_list ( self , windows_map : dict [ int , WindowType ]) -> None : \"\"\"Update the list of windows being managed\"\"\"","title":"update_client_list()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.update_desktops","text":"Set the current desktops of the window manager Source code in libqtile/backend/base.py 58 59 def update_desktops ( self , groups : list [ _Group ], index : int ) -> None : \"\"\"Set the current desktops of the window manager\"\"\"","title":"update_desktops()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Core.warp_pointer","text":"Warp the pointer to the given coordinates relative. Source code in libqtile/backend/base.py 98 99 def warp_pointer ( self , x : int , y : int ) -> None : \"\"\"Warp the pointer to the given coordinates relative.\"\"\"","title":"warp_pointer()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer","text":"A helper class for drawing to Internal windows. We stage drawing operations locally in memory using a cairo RecordingSurface before finally drawing all operations to a backend-specific target. Source code in libqtile/backend/base.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def __init__ ( self , qtile : Qtile , win : Internal , width : int , height : int ): self . qtile = qtile self . _win = win self . _width = width self . _height = height self . surface : cairocffi . RecordingSurface self . last_surface : cairocffi . RecordingSurface self . ctx : cairocffi . Context self . _reset_surface () self . _has_mirrors = False self . current_rect = ( 0 , 0 , 0 , 0 ) self . previous_rect = ( - 1 , - 1 , - 1 , - 1 ) self . _enabled = True","title":"Drawer"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.disable","text":"Disable drawing of surface to Internal window. Source code in libqtile/backend/base.py 756 757 758 def disable ( self ): \"\"\"Disable drawing of surface to Internal window.\"\"\" self . _enabled = False","title":"disable()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.draw","text":"A wrapper for the draw operation. This draws our cached operations to the Internal window. If Drawer has been disabled then the RecordingSurface will be cleared if no mirrors are waiting to copy its contents.","title":"draw()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.draw--parameters","text":"offsetx : the X offset to start drawing at. offsety : the Y offset to start drawing at. width : the X portion of the canvas to draw at the starting point. height : the Y portion of the canvas to draw at the starting point. Source code in libqtile/backend/base.py 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 def draw ( self , offsetx : int = 0 , offsety : int = 0 , width : int | None = None , height : int | None = None , ): \"\"\" A wrapper for the draw operation. This draws our cached operations to the Internal window. If Drawer has been disabled then the RecordingSurface will be cleared if no mirrors are waiting to copy its contents. Parameters ========== offsetx : the X offset to start drawing at. offsety : the Y offset to start drawing at. width : the X portion of the canvas to draw at the starting point. height : the Y portion of the canvas to draw at the starting point. \"\"\" if self . _enabled : self . _draw ( offsetx , offsety , width , height ) if self . has_mirrors : self . _create_last_surface () ctx = cairocffi . Context ( self . last_surface ) ctx . set_source_surface ( self . surface ) ctx . paint () self . _reset_surface ()","title":"Parameters"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.enable","text":"Enable drawing of surface to Internal window. Source code in libqtile/backend/base.py 752 753 754 def enable ( self ): \"\"\"Enable drawing of surface to Internal window.\"\"\" self . _enabled = True","title":"enable()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.finalize","text":"Destructor/Clean up resources Source code in libqtile/backend/base.py 656 657 658 659 def finalize ( self ): \"\"\"Destructor/Clean up resources\"\"\" self . surface = None self . ctx = None","title":"finalize()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.fit_fontsize","text":"Try to find a maximum font size that fits any strings within the height Source code in libqtile/backend/base.py 872 873 874 875 876 877 def fit_fontsize ( self , heightlimit ): \"\"\"Try to find a maximum font size that fits any strings within the height\"\"\" self . ctx . set_font_size ( heightlimit ) asc , desc , height , _ , _ = self . font_extents () self . ctx . set_font_size ( int ( heightlimit * heightlimit / height )) return self . font_extents ()","title":"fit_fontsize()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.fit_text","text":"Try to find a maximum font size that fits all strings within the height Source code in libqtile/backend/base.py 879 880 881 882 883 884 885 886 887 888 889 890 891 def fit_text ( self , strings , heightlimit ): \"\"\"Try to find a maximum font size that fits all strings within the height\"\"\" self . ctx . set_font_size ( heightlimit ) _ , _ , _ , maxheight , _ , _ = self . ctx . text_extents ( \"\" . join ( strings )) if not maxheight : return 0 , 0 self . ctx . set_font_size ( int ( heightlimit * heightlimit / maxheight )) maxwidth , maxheight = 0 , 0 for i in strings : _ , _ , x , y , _ , _ = self . ctx . text_extents ( i ) maxwidth = max ( maxwidth , x ) maxheight = max ( maxheight , y ) return maxwidth , maxheight","title":"fit_text()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Drawer.textlayout","text":"Get a text layout Source code in libqtile/backend/base.py 850 851 852 853 854 855 def textlayout ( self , text , colour , font_family , font_size , font_shadow , markup = False , ** kw ): \"\"\"Get a text layout\"\"\" textlayout = drawer . TextLayout ( self , text , colour , font_family , font_size , font_shadow , markup = markup , ** kw ) return textlayout","title":"textlayout()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal","text":"Bases: _Window An Internal window belonging to Qtile.","title":"Internal"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.create_drawer","text":"Create a Drawer that draws to this window. Source code in libqtile/backend/base.py 568 569 570 @abstractmethod def create_drawer ( self , width : int , height : int ) -> Drawer : \"\"\"Create a Drawer that draws to this window.\"\"\"","title":"create_drawer()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_button_click","text":"Handle a pointer button click. Source code in libqtile/backend/base.py 575 576 def process_button_click ( self , x : int , y : int , button : int ) -> None : \"\"\"Handle a pointer button click.\"\"\"","title":"process_button_click()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_button_release","text":"Handle a pointer button release. Source code in libqtile/backend/base.py 578 579 def process_button_release ( self , x : int , y : int , button : int ) -> None : \"\"\"Handle a pointer button release.\"\"\"","title":"process_button_release()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_key_press","text":"Handle a key press. Source code in libqtile/backend/base.py 590 591 def process_key_press ( self , keycode : int ) -> None : \"\"\"Handle a key press.\"\"\"","title":"process_key_press()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_pointer_enter","text":"Handle the pointer entering the window. Source code in libqtile/backend/base.py 581 582 def process_pointer_enter ( self , x : int , y : int ) -> None : \"\"\"Handle the pointer entering the window.\"\"\"","title":"process_pointer_enter()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_pointer_leave","text":"Handle the pointer leaving the window. Source code in libqtile/backend/base.py 584 585 def process_pointer_leave ( self , x : int , y : int ) -> None : \"\"\"Handle the pointer leaving the window.\"\"\"","title":"process_pointer_leave()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_pointer_motion","text":"Handle pointer motion within the window. Source code in libqtile/backend/base.py 587 588 def process_pointer_motion ( self , x : int , y : int ) -> None : \"\"\"Handle pointer motion within the window.\"\"\"","title":"process_pointer_motion()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Internal.process_window_expose","text":"Respond to the window being exposed. Required by X11 backend. Source code in libqtile/backend/base.py 572 573 def process_window_expose ( self ) -> None : \"\"\"Respond to the window being exposed. Required by X11 backend.\"\"\"","title":"process_window_expose()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Static","text":"Bases: _Window A window bound to a screen rather than a group.","title":"Static"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Static.bring_to_front","text":"Bring the window to the front Source code in libqtile/backend/base.py 619 620 621 622 @abstractmethod @expose_command () def bring_to_front ( self ) -> None : \"\"\"Bring the window to the front\"\"\"","title":"bring_to_front()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Static.info","text":"Return a dictionary of info. Source code in libqtile/backend/base.py 606 607 608 609 610 611 612 613 614 615 616 617 @expose_command () def info ( self ) -> dict : \"\"\"Return a dictionary of info.\"\"\" return dict ( name = self . name , wm_class = self . get_wm_class (), x = self . x , y = self . y , width = self . width , height = self . height , id = self . wid , )","title":"info()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window","text":"Bases: _Window A regular Window belonging to a client. Abstract methods are required to be defined as part of a specific backend's implementation. Non-abstract methods have default implementations here to be shared across backends.","title":"Window"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.bring_to_front","text":"Bring the window to the front Source code in libqtile/backend/base.py 430 431 432 433 @abstractmethod @expose_command () def bring_to_front ( self ) -> None : \"\"\"Bring the window to the front\"\"\"","title":"bring_to_front()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.center","text":"Centers a floating window on the screen. Source code in libqtile/backend/base.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 @expose_command () def center ( self ) -> None : \"\"\"Centers a floating window on the screen.\"\"\" if not self . floating : return if not ( self . group and self . group . screen ): return screen = self . group . screen x = screen . x + ( screen . width - self . width ) // 2 y = screen . y + ( screen . height - self . height ) // 2 self . place ( x , y , self . width , self . height , self . borderwidth , self . bordercolor , above = True , respect_hints = True , )","title":"center()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.disable_floating","text":"Tile the window. Source code in libqtile/backend/base.py 400 401 402 403 @abstractmethod @expose_command () def disable_floating ( self ) -> None : \"\"\"Tile the window.\"\"\"","title":"disable_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.disable_fullscreen","text":"Un-fullscreen the window Source code in libqtile/backend/base.py 425 426 427 428 @abstractmethod @expose_command () def disable_fullscreen ( self ) -> None : \"\"\"Un-fullscreen the window\"\"\"","title":"disable_fullscreen()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.down_opacity","text":"Decrease the window's opacity by 10%. Source code in libqtile/backend/base.py 510 511 512 513 @expose_command () def down_opacity ( self ) -> None : \"\"\"Decrease the window's opacity by 10%.\"\"\" self . set_opacity ( self . opacity - 0.1 )","title":"down_opacity()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.enable_floating","text":"Float the window. Source code in libqtile/backend/base.py 395 396 397 398 @abstractmethod @expose_command () def enable_floating ( self ) -> None : \"\"\"Float the window.\"\"\"","title":"enable_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.enable_fullscreen","text":"Fullscreen the window Source code in libqtile/backend/base.py 420 421 422 423 @abstractmethod @expose_command () def enable_fullscreen ( self ) -> None : \"\"\"Fullscreen the window\"\"\"","title":"enable_fullscreen()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.floating","text":"Whether this window is floating. Source code in libqtile/backend/base.py 283 284 285 286 @property def floating ( self ) -> bool : \"\"\"Whether this window is floating.\"\"\" return False","title":"floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.focus","text":"Focus this window and optional warp the pointer to it. Source code in libqtile/backend/base.py 328 329 330 331 @abstractmethod @expose_command () def focus ( self , warp : bool = True ) -> None : \"\"\"Focus this window and optional warp the pointer to it.\"\"\"","title":"focus()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.fullscreen","text":"Whether this window is fullscreened. Source code in libqtile/backend/base.py 310 311 312 313 @property def fullscreen ( self ) -> bool : \"\"\"Whether this window is fullscreened.\"\"\" return False","title":"fullscreen()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.get_pid","text":"Return the PID that owns the window. Source code in libqtile/backend/base.py 345 346 347 @abstractmethod def get_pid ( self ) -> int : \"\"\"Return the PID that owns the window.\"\"\"","title":"get_pid()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.get_position","text":"Get the (x, y) of the window Source code in libqtile/backend/base.py 352 353 354 355 @abstractmethod @expose_command () def get_position ( self ) -> tuple [ int , int ]: \"\"\"Get the (x, y) of the window\"\"\"","title":"get_position()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.get_size","text":"Get the (width, height) of the window Source code in libqtile/backend/base.py 357 358 359 360 @abstractmethod @expose_command () def get_size ( self ) -> tuple [ int , int ]: \"\"\"Get the (width, height) of the window\"\"\"","title":"get_size()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.group","text":"The group to which this window belongs. Source code in libqtile/backend/base.py 274 275 276 277 @property @abstractmethod def group ( self ) -> _Group | None : \"\"\"The group to which this window belongs.\"\"\"","title":"group()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.has_user_set_position","text":"Whether this window has user-defined geometry Source code in libqtile/backend/base.py 337 338 339 def has_user_set_position ( self ) -> bool : \"\"\"Whether this window has user-defined geometry\"\"\" return False","title":"has_user_set_position()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.is_transient_for","text":"What window is this window a transient window for? Source code in libqtile/backend/base.py 341 342 343 def is_transient_for ( self ) -> WindowType | None : \"\"\"What window is this window a transient window for?\"\"\" return None","title":"is_transient_for()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.match","text":"Compare this window against a Match instance. Source code in libqtile/backend/base.py 324 325 326 def match ( self , match : config . Match ) -> bool : \"\"\"Compare this window against a Match instance.\"\"\" return match . compare ( self )","title":"match()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.maximized","text":"Whether this window is maximized. Source code in libqtile/backend/base.py 292 293 294 295 @property def maximized ( self ) -> bool : \"\"\"Whether this window is maximized.\"\"\" return False","title":"maximized()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.minimized","text":"Whether this window is minimized. Source code in libqtile/backend/base.py 301 302 303 304 @property def minimized ( self ) -> bool : \"\"\"Whether this window is minimized.\"\"\" return False","title":"minimized()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.move_floating","text":"Move window by dx and dy Source code in libqtile/backend/base.py 362 363 364 365 @abstractmethod @expose_command () def move_floating ( self , dx : int , dy : int ) -> None : \"\"\"Move window by dx and dy\"\"\"","title":"move_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.paint_borders","text":"Paint the window borders with the given color(s) and width Source code in libqtile/backend/base.py 349 350 def paint_borders ( self , color : ColorsType , width : int ) -> None : \"\"\"Paint the window borders with the given color(s) and width\"\"\"","title":"paint_borders()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.resize_floating","text":"Add dw and dh to size of window Source code in libqtile/backend/base.py 367 368 369 370 @abstractmethod @expose_command () def resize_floating ( self , dw : int , dh : int ) -> None : \"\"\"Add dw and dh to size of window\"\"\"","title":"resize_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.set_opacity","text":"Set the window's opacity Source code in libqtile/backend/base.py 500 501 502 503 504 505 506 507 508 @expose_command () def set_opacity ( self , opacity : float ) -> None : \"\"\"Set the window's opacity\"\"\" if opacity < 0.1 : self . opacity = 0.1 elif opacity > 1 : self . opacity = 1 else : self . opacity = opacity","title":"set_opacity()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.set_position","text":"Move floating window to x and y; swap tiling window with the window under the pointer. Source code in libqtile/backend/base.py 377 378 379 380 381 382 383 @abstractmethod @expose_command () def set_position ( self , x : int , y : int ) -> None : \"\"\" Move floating window to x and y; swap tiling window with the window under the pointer. \"\"\"","title":"set_position()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.set_position_floating","text":"Move window to x and y Source code in libqtile/backend/base.py 372 373 374 375 @abstractmethod @expose_command () def set_position_floating ( self , x : int , y : int ) -> None : \"\"\"Move window to x and y\"\"\"","title":"set_position_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.set_size_floating","text":"Set window dimensions to w and h Source code in libqtile/backend/base.py 385 386 387 388 @abstractmethod @expose_command () def set_size_floating ( self , w : int , h : int ) -> None : \"\"\"Set window dimensions to w and h\"\"\"","title":"set_size_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.static","text":"Makes this window a static window, attached to a Screen. Values left unspecified are taken from the existing window state. Source code in libqtile/backend/base.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 @abstractmethod @expose_command () def static ( self , screen : int | None = None , x : int | None = None , y : int | None = None , width : int | None = None , height : int | None = None , ) -> None : \"\"\"Makes this window a static window, attached to a Screen. Values left unspecified are taken from the existing window state. \"\"\" self . defunct = True","title":"static()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.toggle_floating","text":"Toggle the floating state of the window. Source code in libqtile/backend/base.py 390 391 392 393 @abstractmethod @expose_command () def toggle_floating ( self ) -> None : \"\"\"Toggle the floating state of the window.\"\"\"","title":"toggle_floating()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.toggle_fullscreen","text":"Toggle the fullscreen state of the window. Source code in libqtile/backend/base.py 415 416 417 418 @abstractmethod @expose_command () def toggle_fullscreen ( self ) -> None : \"\"\"Toggle the fullscreen state of the window.\"\"\"","title":"toggle_fullscreen()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.toggle_maximize","text":"Toggle the fullscreen state of the window. Source code in libqtile/backend/base.py 405 406 407 408 @abstractmethod @expose_command () def toggle_maximize ( self ) -> None : \"\"\"Toggle the fullscreen state of the window.\"\"\"","title":"toggle_maximize()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.toggle_minimize","text":"Toggle the minimized state of the window. Source code in libqtile/backend/base.py 410 411 412 413 @abstractmethod @expose_command () def toggle_minimize ( self ) -> None : \"\"\"Toggle the minimized state of the window.\"\"\"","title":"toggle_minimize()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.togroup","text":"Move window to a specified group Also switch to that group if switch_group is True. If toggle is True and and the specified group is already on the screen, use the last used group as target instead. groupName is deprecated and will be dropped soon. Please use group_name instead.","title":"togroup()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.togroup--examples","text":"Move window to current group:: togroup() Move window to group \"a\":: togroup(\"a\") Move window to group \"a\", and switch to group \"a\":: togroup(\"a\", switch_group=True) Source code in libqtile/backend/base.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 @abstractmethod @expose_command () def togroup ( self , group_name : str | None = None , groupName : str | None = None , # Deprecated # noqa: N803 switch_group : bool = False , toggle : bool = False , ) -> None : \"\"\"Move window to a specified group Also switch to that group if `switch_group` is True. If `toggle` is True and and the specified group is already on the screen, use the last used group as target instead. `groupName` is deprecated and will be dropped soon. Please use `group_name` instead. Examples ======== Move window to current group:: togroup() Move window to group \"a\":: togroup(\"a\") Move window to group \"a\", and switch to group \"a\":: togroup(\"a\", switch_group=True) \"\"\" if groupName is not None : logger . warning ( \"Window.togroup's groupName is deprecated; use group_name\" ) group_name = groupName self . togroup ( group_name , switch_group = switch_group , toggle = toggle )","title":"Examples"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.toscreen","text":"Move window to a specified screen. If index is not specified, we assume the current screen","title":"toscreen()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.toscreen--examples","text":"Move window to current screen:: toscreen() Move window to screen 0:: toscreen(0) Source code in libqtile/backend/base.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 @expose_command () def toscreen ( self , index : int | None = None ) -> None : \"\"\"Move window to a specified screen. If index is not specified, we assume the current screen Examples ======== Move window to current screen:: toscreen() Move window to screen 0:: toscreen(0) \"\"\" if index is None : screen = self . qtile . current_screen else : try : screen = self . qtile . screens [ index ] except IndexError : raise CommandError ( \"No such screen: %d \" % index ) self . togroup ( screen . group . name )","title":"Examples"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.up_opacity","text":"Increase the window's opacity by 10%. Source code in libqtile/backend/base.py 515 516 517 518 @expose_command () def up_opacity ( self ) -> None : \"\"\"Increase the window's opacity by 10%.\"\"\" self . set_opacity ( self . opacity + 0.1 )","title":"up_opacity()"},{"location":"reference/libqtile/backend/base/#libqtile.backend.base.Window.wants_to_fullscreen","text":"Does this window want to be fullscreen? Source code in libqtile/backend/base.py 319 320 321 322 @property def wants_to_fullscreen ( self ) -> bool : \"\"\"Does this window want to be fullscreen?\"\"\" return False","title":"wants_to_fullscreen()"},{"location":"reference/libqtile/backend/wayland/","text":"","title":"wayland"},{"location":"reference/libqtile/backend/wayland/core/","text":"Core () Bases: base . Core , wlrq . HasListeners Source code in libqtile/backend/wayland/core.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def __init__ ( self ) -> None : \"\"\"Setup the Wayland core backend\"\"\" self . qtile : Qtile | None = None self . _hovered_internal : window . Internal | None = None self . focused_internal : window . Internal | None = None # Log exceptions that are raised in Wayland callback functions. log_utils . init_log ( logger . level , log_path = log_utils . get_default_log (), logger = pywayland . server . listener . logger , ) self . fd : int | None = None self . display = pywayland . server . display . Display () self . event_loop = self . display . get_event_loop () ( self . compositor , self . _allocator , self . renderer , self . backend , ) = wlroots_helper . build_compositor ( self . display ) self . socket = self . display . add_socket () os . environ [ \"WAYLAND_DISPLAY\" ] = self . socket . decode () logger . info ( \"Starting core with WAYLAND_DISPLAY= %s \" , self . socket . decode ()) # These windows have not been mapped yet; they'll get managed when mapped self . pending_windows : set [ window . WindowType ] = set () # mapped_windows contains just regular windows self . mapped_windows : list [ window . WindowType ] = [] # Ascending in Z # stacked_windows also contains layer_shell windows from the current output self . stacked_windows : Sequence [ window . WindowType ] = [] # Ascending in Z self . _current_output : Output | None = None # set up inputs self . keyboards : list [ inputs . Keyboard ] = [] self . _pointers : list [ inputs . Pointer ] = [] self . grabbed_keys : list [ tuple [ int , int ]] = [] self . grabbed_buttons : list [ tuple [ int , int ]] = [] DataDeviceManager ( self . display ) self . live_dnd : wlrq . Dnd | None = None DataControlManagerV1 ( self . display ) self . seat = seat . Seat ( self . display , \"seat0\" ) self . add_listener ( self . seat . request_set_selection_event , self . _on_request_set_selection ) self . add_listener ( self . seat . request_set_primary_selection_event , self . _on_request_set_primary_selection ) self . add_listener ( self . seat . request_start_drag_event , self . _on_request_start_drag ) self . add_listener ( self . seat . start_drag_event , self . _on_start_drag ) self . add_listener ( self . backend . new_input_event , self . _on_new_input ) # Some devices are added early, so we need to remember to configure them self . _pending_input_devices : list [ inputs . _Device ] = [] hook . subscribe . startup_complete ( self . _configure_pending_inputs ) self . _input_inhibit_manager = InputInhibitManager ( self . display ) self . add_listener ( self . _input_inhibit_manager . activate_event , self . _on_input_inhibitor_activate ) self . add_listener ( self . _input_inhibit_manager . deactivate_event , self . _on_input_inhibitor_deactivate ) self . exclusive_client : pywayland . server . Client | None = None # set up outputs self . outputs : list [ Output ] = [] self . add_listener ( self . backend . new_output_event , self . _on_new_output ) self . output_layout = OutputLayout () self . add_listener ( self . output_layout . change_event , self . _on_output_layout_change ) self . output_manager = OutputManagerV1 ( self . display ) self . add_listener ( self . output_manager . apply_event , self . _on_output_manager_apply ) self . add_listener ( self . output_manager . test_event , self . _on_output_manager_test ) self . _blanked_outputs : set [ Output ] = set () # set up cursor self . cursor = Cursor ( self . output_layout ) self . cursor_manager = XCursorManager ( 24 ) self . add_listener ( self . seat . request_set_cursor_event , self . _on_request_cursor ) self . add_listener ( self . cursor . axis_event , self . _on_cursor_axis ) self . add_listener ( self . cursor . frame_event , self . _on_cursor_frame ) self . add_listener ( self . cursor . button_event , self . _on_cursor_button ) self . add_listener ( self . cursor . motion_event , self . _on_cursor_motion ) self . add_listener ( self . cursor . motion_absolute_event , self . _on_cursor_motion_absolute ) self . _cursor_state = wlrq . CursorState () # set up shell self . xdg_shell = XdgShell ( self . display ) self . add_listener ( self . xdg_shell . new_surface_event , self . _on_new_xdg_surface ) self . layer_shell = LayerShellV1 ( self . display ) self . add_listener ( self . layer_shell . new_surface_event , self . _on_new_layer_surface ) # Add support for additional protocols ExportDmabufManagerV1 ( self . display ) XdgOutputManagerV1 ( self . display , self . output_layout ) ScreencopyManagerV1 ( self . display ) GammaControlManagerV1 ( self . display ) output_power_manager = OutputPowerManagerV1 ( self . display ) self . add_listener ( output_power_manager . set_mode_event , self . _on_output_power_manager_set_mode ) self . idle = Idle ( self . display ) idle_ihibitor_manager = IdleInhibitorManagerV1 ( self . display ) self . add_listener ( idle_ihibitor_manager . new_inhibitor_event , self . _on_new_idle_inhibitor ) PrimarySelectionV1DeviceManager ( self . display ) virtual_keyboard_manager_v1 = vkeyboard . VirtualKeyboardManagerV1 ( self . display ) self . add_listener ( virtual_keyboard_manager_v1 . new_virtual_keyboard_event , self . _on_new_virtual_keyboard , ) virtual_pointer_manager_v1 = vpointer . VirtualPointerManagerV1 ( self . display ) self . add_listener ( virtual_pointer_manager_v1 . new_virtual_pointer_event , self . _on_new_virtual_pointer , ) xdg_decoration_manager_v1 = xdg_decoration_v1 . XdgDecorationManagerV1 . create ( self . display ) self . add_listener ( xdg_decoration_manager_v1 . new_toplevel_decoration_event , self . _on_new_toplevel_decoration , ) # wlr_server_decoration will be removed in a future version of wlroots server_decoration_manager = ServerDecorationManager . create ( self . display ) server_decoration_manager . set_default_mode ( ServerDecorationManagerMode . SERVER ) pointer_constraints_v1 = PointerConstraintsV1 ( self . display ) self . add_listener ( pointer_constraints_v1 . new_constraint_event , self . _on_new_pointer_constraint , ) self . pointer_constraints : set [ window . PointerConstraint ] = set () self . active_pointer_constraint : window . PointerConstraint | None = None self . _relative_pointer_manager_v1 = RelativePointerManagerV1 ( self . display ) self . foreign_toplevel_manager_v1 = ForeignToplevelManagerV1 . create ( self . display ) # Set up XWayland self . _xwayland = xwayland . XWayland ( self . display , self . compositor , True ) if self . _xwayland : os . environ [ \"DISPLAY\" ] = self . _xwayland . display_name or \"\" logger . info ( \"Set up XWayland with DISPLAY= %s \" , os . environ [ \"DISPLAY\" ]) self . add_listener ( self . _xwayland . ready_event , self . _on_xwayland_ready ) self . add_listener ( self . _xwayland . new_surface_event , self . _on_xwayland_new_surface ) else : logger . info ( \"Failed to set up XWayland. Continuing without.\" ) # Start self . backend . start () change_vt ( vt ) Change virtual terminal to that specified Source code in libqtile/backend/wayland/core.py 1131 1132 1133 1134 1135 1136 1137 @expose_command () def change_vt ( self , vt : int ) -> bool : \"\"\"Change virtual terminal to that specified\"\"\" success = self . backend . get_session () . change_vt ( vt ) if not success : logger . warning ( \"Could not change VT to: %s \" , vt ) return success check_idle_inhibitor () Checks if any window that is currently mapped has idle inhibitor and if so inhibits idle Source code in libqtile/backend/wayland/core.py 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 def check_idle_inhibitor ( self ) -> None : \"\"\" Checks if any window that is currently mapped has idle inhibitor and if so inhibits idle \"\"\" for win in self . mapped_windows : if isinstance ( win , ( window . Window , window . Static )) and win . is_idle_inhibited : self . idle . set_enabled ( self . seat , False ) break else : self . idle . set_enabled ( self . seat , True ) get_inputs () Get information on all input devices. Source code in libqtile/backend/wayland/core.py 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 @expose_command () def get_inputs ( self ) -> dict [ str , list [ dict [ str , str ]]]: \"\"\"Get information on all input devices.\"\"\" info = {} device_lists : dict [ str , list [ inputs . _Device ]] = { \"type:keyboard\" : self . keyboards , # type: ignore \"type:pointer\" : self . _pointers , # type: ignore } for type_key , devices in device_lists . items (): type_info = [] for dev in devices : type_info . append ( dict ( name = dev . wlr_device . name , identifier = dev . get_info ()[ 1 ], ) ) info [ type_key ] = type_info return info get_screen_info () Get the screen information Source code in libqtile/backend/wayland/core.py 1010 1011 1012 def get_screen_info ( self ) -> list [ tuple [ int , int , int , int ]]: \"\"\"Get the screen information\"\"\" return [ screen . get_geometry () for screen in self . outputs if screen . wlr_output . enabled ] grab_button ( mouse ) Configure the backend to grab the mouse event Source code in libqtile/backend/wayland/core.py 1032 1033 1034 1035 1036 1037 def grab_button ( self , mouse : config . Mouse ) -> int : \"\"\"Configure the backend to grab the mouse event\"\"\" keysym = wlrq . buttons [ mouse . button_code ] mask_key = wlrq . translate_masks ( mouse . modifiers ) self . grabbed_buttons . append (( keysym , mask_key )) return mask_key grab_key ( key ) Configure the backend to grab the key event Source code in libqtile/backend/wayland/core.py 1014 1015 1016 1017 1018 1019 def grab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Configure the backend to grab the key event\"\"\" keysym = xkb . keysym_from_name ( key . key , case_insensitive = True ) mask_key = wlrq . translate_masks ( key . modifiers ) self . grabbed_keys . append (( keysym , mask_key )) return keysym , mask_key grab_pointer () Configure the backend to grab mouse events Source code in libqtile/backend/wayland/core.py 1043 1044 def grab_pointer ( self ) -> None : \"\"\"Configure the backend to grab mouse events\"\"\" graceful_shutdown () Try to close windows gracefully before exiting Source code in libqtile/backend/wayland/core.py 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 def graceful_shutdown ( self ) -> None : \"\"\"Try to close windows gracefully before exiting\"\"\" assert self . qtile is not None # Copy in case the dictionary changes during the loop for win in self . qtile . windows_map . copy () . values (): win . kill () # give everyone a little time to exit and write their state. but don't # sleep forever (1s). end = time . time () + 1 while time . time () < end : self . _poll () if not self . qtile . windows_map : break hide_cursor () Hide the cursor. Source code in libqtile/backend/wayland/core.py 1139 1140 1141 1142 1143 1144 @expose_command () def hide_cursor ( self ) -> None : \"\"\"Hide the cursor.\"\"\" if not self . _cursor_state . hidden : self . cursor . set_surface ( None , self . _cursor_state . hotspot ) self . _cursor_state . hidden = True keysym_from_name ( name ) Get the keysym for a key from its name Source code in libqtile/backend/wayland/core.py 1094 1095 1096 def keysym_from_name ( self , name : str ) -> int : \"\"\"Get the keysym for a key from its name\"\"\" return xkb . keysym_from_name ( name , case_insensitive = True ) new_wid () Get a new unique window ID Source code in libqtile/backend/wayland/core.py 847 848 849 850 def new_wid ( self ) -> int : \"\"\"Get a new unique window ID\"\"\" assert self . qtile is not None return max ( self . qtile . windows_map . keys (), default = 0 ) + 1 remove_listener () Remove the listener from the given event loop Source code in libqtile/backend/wayland/core.py 792 793 794 795 796 797 798 def remove_listener ( self ) -> None : \"\"\"Remove the listener from the given event loop\"\"\" if self . fd is not None : logger . debug ( \"Removing io watch\" ) loop = asyncio . get_running_loop () loop . remove_reader ( self . fd ) self . fd = None set_keymap ( layout = None , options = None , variant = None ) Set the keymap for the current keyboard. The options correspond to xkbcommon configuration environmental variables and if not specified are taken from the environment. Acceptable values are strings identical to those accepted by the env variables. Source code in libqtile/backend/wayland/core.py 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 @expose_command () def set_keymap ( self , layout : str | None = None , options : str | None = None , variant : str | None = None , ) -> None : \"\"\" Set the keymap for the current keyboard. The options correspond to xkbcommon configuration environmental variables and if not specified are taken from the environment. Acceptable values are strings identical to those accepted by the env variables. \"\"\" if self . keyboards : for keyboard in self . keyboards : keyboard . set_keymap ( layout , options , variant ) else : logger . warning ( \"Could not set keymap: no keyboards set up.\" ) setup_listener ( qtile ) Setup a listener for the given qtile instance Source code in libqtile/backend/wayland/core.py 782 783 784 785 786 787 788 789 790 def setup_listener ( self , qtile : Qtile ) -> None : \"\"\"Setup a listener for the given qtile instance\"\"\" logger . debug ( \"Adding io watch\" ) self . qtile = qtile self . fd = wllib . wl_event_loop_get_fd ( self . event_loop . _ptr ) if self . fd : asyncio . get_running_loop () . add_reader ( self . fd , self . _poll ) else : raise RuntimeError ( \"Failed to get Wayland event loop file descriptor.\" ) simulate_keypress ( modifiers , key ) Simulates a keypress on the focused window. Source code in libqtile/backend/wayland/core.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 def simulate_keypress ( self , modifiers : list [ str ], key : str ) -> None : \"\"\"Simulates a keypress on the focused window.\"\"\" keysym = xkb . keysym_from_name ( key , case_insensitive = True ) mods = wlrq . translate_masks ( modifiers ) if ( keysym , mods ) in self . grabbed_keys : assert self . qtile is not None self . qtile . process_key_event ( keysym , mods ) return if self . focused_internal : self . focused_internal . process_key_press ( keysym ) stack_windows () Put all windows of all types in a Z-ordered list. Source code in libqtile/backend/wayland/core.py 984 985 986 987 988 989 990 991 992 993 994 995 996 def stack_windows ( self ) -> None : \"\"\"Put all windows of all types in a Z-ordered list.\"\"\" if self . _current_output : layers = self . _current_output . layers self . stacked_windows = ( layers [ LayerShellV1Layer . BACKGROUND ] + layers [ LayerShellV1Layer . BOTTOM ] + self . mapped_windows # type: ignore + layers [ LayerShellV1Layer . TOP ] + layers [ LayerShellV1Layer . OVERLAY ] ) else : self . stacked_windows = self . mapped_windows ungrab_buttons () Release the grabbed button events Source code in libqtile/backend/wayland/core.py 1039 1040 1041 def ungrab_buttons ( self ) -> None : \"\"\"Release the grabbed button events\"\"\" self . grabbed_buttons . clear () ungrab_key ( key ) Release the given key event Source code in libqtile/backend/wayland/core.py 1021 1022 1023 1024 1025 1026 def ungrab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Release the given key event\"\"\" keysym = xkb . keysym_from_name ( key . key , case_insensitive = True ) mask_key = wlrq . translate_masks ( key . modifiers ) self . grabbed_keys . remove (( keysym , mask_key )) return keysym , mask_key ungrab_keys () Release the grabbed key events Source code in libqtile/backend/wayland/core.py 1028 1029 1030 def ungrab_keys ( self ) -> None : \"\"\"Release the grabbed key events\"\"\" self . grabbed_keys . clear () ungrab_pointer () Release grabbed pointer events Source code in libqtile/backend/wayland/core.py 1046 1047 def ungrab_pointer ( self ) -> None : \"\"\"Release grabbed pointer events\"\"\" unhide_cursor () Unhide the cursor. Source code in libqtile/backend/wayland/core.py 1146 1147 1148 1149 1150 1151 1152 1153 1154 @expose_command () def unhide_cursor ( self ) -> None : \"\"\"Unhide the cursor.\"\"\" if self . _cursor_state . hidden : self . cursor . set_surface ( self . _cursor_state . surface , self . _cursor_state . hotspot , ) self . _cursor_state . hidden = False warp_pointer ( x , y ) Warp the pointer to the coordinates in relative to the output layout Source code in libqtile/backend/wayland/core.py 1049 1050 1051 def warp_pointer ( self , x : float , y : float ) -> None : \"\"\"Warp the pointer to the coordinates in relative to the output layout\"\"\" self . cursor . warp ( WarpMode . LayoutClosest , x , y )","title":"core"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core","text":"Bases: base . Core , wlrq . HasListeners Source code in libqtile/backend/wayland/core.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def __init__ ( self ) -> None : \"\"\"Setup the Wayland core backend\"\"\" self . qtile : Qtile | None = None self . _hovered_internal : window . Internal | None = None self . focused_internal : window . Internal | None = None # Log exceptions that are raised in Wayland callback functions. log_utils . init_log ( logger . level , log_path = log_utils . get_default_log (), logger = pywayland . server . listener . logger , ) self . fd : int | None = None self . display = pywayland . server . display . Display () self . event_loop = self . display . get_event_loop () ( self . compositor , self . _allocator , self . renderer , self . backend , ) = wlroots_helper . build_compositor ( self . display ) self . socket = self . display . add_socket () os . environ [ \"WAYLAND_DISPLAY\" ] = self . socket . decode () logger . info ( \"Starting core with WAYLAND_DISPLAY= %s \" , self . socket . decode ()) # These windows have not been mapped yet; they'll get managed when mapped self . pending_windows : set [ window . WindowType ] = set () # mapped_windows contains just regular windows self . mapped_windows : list [ window . WindowType ] = [] # Ascending in Z # stacked_windows also contains layer_shell windows from the current output self . stacked_windows : Sequence [ window . WindowType ] = [] # Ascending in Z self . _current_output : Output | None = None # set up inputs self . keyboards : list [ inputs . Keyboard ] = [] self . _pointers : list [ inputs . Pointer ] = [] self . grabbed_keys : list [ tuple [ int , int ]] = [] self . grabbed_buttons : list [ tuple [ int , int ]] = [] DataDeviceManager ( self . display ) self . live_dnd : wlrq . Dnd | None = None DataControlManagerV1 ( self . display ) self . seat = seat . Seat ( self . display , \"seat0\" ) self . add_listener ( self . seat . request_set_selection_event , self . _on_request_set_selection ) self . add_listener ( self . seat . request_set_primary_selection_event , self . _on_request_set_primary_selection ) self . add_listener ( self . seat . request_start_drag_event , self . _on_request_start_drag ) self . add_listener ( self . seat . start_drag_event , self . _on_start_drag ) self . add_listener ( self . backend . new_input_event , self . _on_new_input ) # Some devices are added early, so we need to remember to configure them self . _pending_input_devices : list [ inputs . _Device ] = [] hook . subscribe . startup_complete ( self . _configure_pending_inputs ) self . _input_inhibit_manager = InputInhibitManager ( self . display ) self . add_listener ( self . _input_inhibit_manager . activate_event , self . _on_input_inhibitor_activate ) self . add_listener ( self . _input_inhibit_manager . deactivate_event , self . _on_input_inhibitor_deactivate ) self . exclusive_client : pywayland . server . Client | None = None # set up outputs self . outputs : list [ Output ] = [] self . add_listener ( self . backend . new_output_event , self . _on_new_output ) self . output_layout = OutputLayout () self . add_listener ( self . output_layout . change_event , self . _on_output_layout_change ) self . output_manager = OutputManagerV1 ( self . display ) self . add_listener ( self . output_manager . apply_event , self . _on_output_manager_apply ) self . add_listener ( self . output_manager . test_event , self . _on_output_manager_test ) self . _blanked_outputs : set [ Output ] = set () # set up cursor self . cursor = Cursor ( self . output_layout ) self . cursor_manager = XCursorManager ( 24 ) self . add_listener ( self . seat . request_set_cursor_event , self . _on_request_cursor ) self . add_listener ( self . cursor . axis_event , self . _on_cursor_axis ) self . add_listener ( self . cursor . frame_event , self . _on_cursor_frame ) self . add_listener ( self . cursor . button_event , self . _on_cursor_button ) self . add_listener ( self . cursor . motion_event , self . _on_cursor_motion ) self . add_listener ( self . cursor . motion_absolute_event , self . _on_cursor_motion_absolute ) self . _cursor_state = wlrq . CursorState () # set up shell self . xdg_shell = XdgShell ( self . display ) self . add_listener ( self . xdg_shell . new_surface_event , self . _on_new_xdg_surface ) self . layer_shell = LayerShellV1 ( self . display ) self . add_listener ( self . layer_shell . new_surface_event , self . _on_new_layer_surface ) # Add support for additional protocols ExportDmabufManagerV1 ( self . display ) XdgOutputManagerV1 ( self . display , self . output_layout ) ScreencopyManagerV1 ( self . display ) GammaControlManagerV1 ( self . display ) output_power_manager = OutputPowerManagerV1 ( self . display ) self . add_listener ( output_power_manager . set_mode_event , self . _on_output_power_manager_set_mode ) self . idle = Idle ( self . display ) idle_ihibitor_manager = IdleInhibitorManagerV1 ( self . display ) self . add_listener ( idle_ihibitor_manager . new_inhibitor_event , self . _on_new_idle_inhibitor ) PrimarySelectionV1DeviceManager ( self . display ) virtual_keyboard_manager_v1 = vkeyboard . VirtualKeyboardManagerV1 ( self . display ) self . add_listener ( virtual_keyboard_manager_v1 . new_virtual_keyboard_event , self . _on_new_virtual_keyboard , ) virtual_pointer_manager_v1 = vpointer . VirtualPointerManagerV1 ( self . display ) self . add_listener ( virtual_pointer_manager_v1 . new_virtual_pointer_event , self . _on_new_virtual_pointer , ) xdg_decoration_manager_v1 = xdg_decoration_v1 . XdgDecorationManagerV1 . create ( self . display ) self . add_listener ( xdg_decoration_manager_v1 . new_toplevel_decoration_event , self . _on_new_toplevel_decoration , ) # wlr_server_decoration will be removed in a future version of wlroots server_decoration_manager = ServerDecorationManager . create ( self . display ) server_decoration_manager . set_default_mode ( ServerDecorationManagerMode . SERVER ) pointer_constraints_v1 = PointerConstraintsV1 ( self . display ) self . add_listener ( pointer_constraints_v1 . new_constraint_event , self . _on_new_pointer_constraint , ) self . pointer_constraints : set [ window . PointerConstraint ] = set () self . active_pointer_constraint : window . PointerConstraint | None = None self . _relative_pointer_manager_v1 = RelativePointerManagerV1 ( self . display ) self . foreign_toplevel_manager_v1 = ForeignToplevelManagerV1 . create ( self . display ) # Set up XWayland self . _xwayland = xwayland . XWayland ( self . display , self . compositor , True ) if self . _xwayland : os . environ [ \"DISPLAY\" ] = self . _xwayland . display_name or \"\" logger . info ( \"Set up XWayland with DISPLAY= %s \" , os . environ [ \"DISPLAY\" ]) self . add_listener ( self . _xwayland . ready_event , self . _on_xwayland_ready ) self . add_listener ( self . _xwayland . new_surface_event , self . _on_xwayland_new_surface ) else : logger . info ( \"Failed to set up XWayland. Continuing without.\" ) # Start self . backend . start ()","title":"Core"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.change_vt","text":"Change virtual terminal to that specified Source code in libqtile/backend/wayland/core.py 1131 1132 1133 1134 1135 1136 1137 @expose_command () def change_vt ( self , vt : int ) -> bool : \"\"\"Change virtual terminal to that specified\"\"\" success = self . backend . get_session () . change_vt ( vt ) if not success : logger . warning ( \"Could not change VT to: %s \" , vt ) return success","title":"change_vt()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.check_idle_inhibitor","text":"Checks if any window that is currently mapped has idle inhibitor and if so inhibits idle Source code in libqtile/backend/wayland/core.py 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 def check_idle_inhibitor ( self ) -> None : \"\"\" Checks if any window that is currently mapped has idle inhibitor and if so inhibits idle \"\"\" for win in self . mapped_windows : if isinstance ( win , ( window . Window , window . Static )) and win . is_idle_inhibited : self . idle . set_enabled ( self . seat , False ) break else : self . idle . set_enabled ( self . seat , True )","title":"check_idle_inhibitor()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.get_inputs","text":"Get information on all input devices. Source code in libqtile/backend/wayland/core.py 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 @expose_command () def get_inputs ( self ) -> dict [ str , list [ dict [ str , str ]]]: \"\"\"Get information on all input devices.\"\"\" info = {} device_lists : dict [ str , list [ inputs . _Device ]] = { \"type:keyboard\" : self . keyboards , # type: ignore \"type:pointer\" : self . _pointers , # type: ignore } for type_key , devices in device_lists . items (): type_info = [] for dev in devices : type_info . append ( dict ( name = dev . wlr_device . name , identifier = dev . get_info ()[ 1 ], ) ) info [ type_key ] = type_info return info","title":"get_inputs()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.get_screen_info","text":"Get the screen information Source code in libqtile/backend/wayland/core.py 1010 1011 1012 def get_screen_info ( self ) -> list [ tuple [ int , int , int , int ]]: \"\"\"Get the screen information\"\"\" return [ screen . get_geometry () for screen in self . outputs if screen . wlr_output . enabled ]","title":"get_screen_info()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.grab_button","text":"Configure the backend to grab the mouse event Source code in libqtile/backend/wayland/core.py 1032 1033 1034 1035 1036 1037 def grab_button ( self , mouse : config . Mouse ) -> int : \"\"\"Configure the backend to grab the mouse event\"\"\" keysym = wlrq . buttons [ mouse . button_code ] mask_key = wlrq . translate_masks ( mouse . modifiers ) self . grabbed_buttons . append (( keysym , mask_key )) return mask_key","title":"grab_button()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.grab_key","text":"Configure the backend to grab the key event Source code in libqtile/backend/wayland/core.py 1014 1015 1016 1017 1018 1019 def grab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Configure the backend to grab the key event\"\"\" keysym = xkb . keysym_from_name ( key . key , case_insensitive = True ) mask_key = wlrq . translate_masks ( key . modifiers ) self . grabbed_keys . append (( keysym , mask_key )) return keysym , mask_key","title":"grab_key()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.grab_pointer","text":"Configure the backend to grab mouse events Source code in libqtile/backend/wayland/core.py 1043 1044 def grab_pointer ( self ) -> None : \"\"\"Configure the backend to grab mouse events\"\"\"","title":"grab_pointer()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.graceful_shutdown","text":"Try to close windows gracefully before exiting Source code in libqtile/backend/wayland/core.py 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 def graceful_shutdown ( self ) -> None : \"\"\"Try to close windows gracefully before exiting\"\"\" assert self . qtile is not None # Copy in case the dictionary changes during the loop for win in self . qtile . windows_map . copy () . values (): win . kill () # give everyone a little time to exit and write their state. but don't # sleep forever (1s). end = time . time () + 1 while time . time () < end : self . _poll () if not self . qtile . windows_map : break","title":"graceful_shutdown()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.hide_cursor","text":"Hide the cursor. Source code in libqtile/backend/wayland/core.py 1139 1140 1141 1142 1143 1144 @expose_command () def hide_cursor ( self ) -> None : \"\"\"Hide the cursor.\"\"\" if not self . _cursor_state . hidden : self . cursor . set_surface ( None , self . _cursor_state . hotspot ) self . _cursor_state . hidden = True","title":"hide_cursor()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.keysym_from_name","text":"Get the keysym for a key from its name Source code in libqtile/backend/wayland/core.py 1094 1095 1096 def keysym_from_name ( self , name : str ) -> int : \"\"\"Get the keysym for a key from its name\"\"\" return xkb . keysym_from_name ( name , case_insensitive = True )","title":"keysym_from_name()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.new_wid","text":"Get a new unique window ID Source code in libqtile/backend/wayland/core.py 847 848 849 850 def new_wid ( self ) -> int : \"\"\"Get a new unique window ID\"\"\" assert self . qtile is not None return max ( self . qtile . windows_map . keys (), default = 0 ) + 1","title":"new_wid()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.remove_listener","text":"Remove the listener from the given event loop Source code in libqtile/backend/wayland/core.py 792 793 794 795 796 797 798 def remove_listener ( self ) -> None : \"\"\"Remove the listener from the given event loop\"\"\" if self . fd is not None : logger . debug ( \"Removing io watch\" ) loop = asyncio . get_running_loop () loop . remove_reader ( self . fd ) self . fd = None","title":"remove_listener()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.set_keymap","text":"Set the keymap for the current keyboard. The options correspond to xkbcommon configuration environmental variables and if not specified are taken from the environment. Acceptable values are strings identical to those accepted by the env variables. Source code in libqtile/backend/wayland/core.py 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 @expose_command () def set_keymap ( self , layout : str | None = None , options : str | None = None , variant : str | None = None , ) -> None : \"\"\" Set the keymap for the current keyboard. The options correspond to xkbcommon configuration environmental variables and if not specified are taken from the environment. Acceptable values are strings identical to those accepted by the env variables. \"\"\" if self . keyboards : for keyboard in self . keyboards : keyboard . set_keymap ( layout , options , variant ) else : logger . warning ( \"Could not set keymap: no keyboards set up.\" )","title":"set_keymap()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.setup_listener","text":"Setup a listener for the given qtile instance Source code in libqtile/backend/wayland/core.py 782 783 784 785 786 787 788 789 790 def setup_listener ( self , qtile : Qtile ) -> None : \"\"\"Setup a listener for the given qtile instance\"\"\" logger . debug ( \"Adding io watch\" ) self . qtile = qtile self . fd = wllib . wl_event_loop_get_fd ( self . event_loop . _ptr ) if self . fd : asyncio . get_running_loop () . add_reader ( self . fd , self . _poll ) else : raise RuntimeError ( \"Failed to get Wayland event loop file descriptor.\" )","title":"setup_listener()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.simulate_keypress","text":"Simulates a keypress on the focused window. Source code in libqtile/backend/wayland/core.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 def simulate_keypress ( self , modifiers : list [ str ], key : str ) -> None : \"\"\"Simulates a keypress on the focused window.\"\"\" keysym = xkb . keysym_from_name ( key , case_insensitive = True ) mods = wlrq . translate_masks ( modifiers ) if ( keysym , mods ) in self . grabbed_keys : assert self . qtile is not None self . qtile . process_key_event ( keysym , mods ) return if self . focused_internal : self . focused_internal . process_key_press ( keysym )","title":"simulate_keypress()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.stack_windows","text":"Put all windows of all types in a Z-ordered list. Source code in libqtile/backend/wayland/core.py 984 985 986 987 988 989 990 991 992 993 994 995 996 def stack_windows ( self ) -> None : \"\"\"Put all windows of all types in a Z-ordered list.\"\"\" if self . _current_output : layers = self . _current_output . layers self . stacked_windows = ( layers [ LayerShellV1Layer . BACKGROUND ] + layers [ LayerShellV1Layer . BOTTOM ] + self . mapped_windows # type: ignore + layers [ LayerShellV1Layer . TOP ] + layers [ LayerShellV1Layer . OVERLAY ] ) else : self . stacked_windows = self . mapped_windows","title":"stack_windows()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.ungrab_buttons","text":"Release the grabbed button events Source code in libqtile/backend/wayland/core.py 1039 1040 1041 def ungrab_buttons ( self ) -> None : \"\"\"Release the grabbed button events\"\"\" self . grabbed_buttons . clear ()","title":"ungrab_buttons()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.ungrab_key","text":"Release the given key event Source code in libqtile/backend/wayland/core.py 1021 1022 1023 1024 1025 1026 def ungrab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Release the given key event\"\"\" keysym = xkb . keysym_from_name ( key . key , case_insensitive = True ) mask_key = wlrq . translate_masks ( key . modifiers ) self . grabbed_keys . remove (( keysym , mask_key )) return keysym , mask_key","title":"ungrab_key()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.ungrab_keys","text":"Release the grabbed key events Source code in libqtile/backend/wayland/core.py 1028 1029 1030 def ungrab_keys ( self ) -> None : \"\"\"Release the grabbed key events\"\"\" self . grabbed_keys . clear ()","title":"ungrab_keys()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.ungrab_pointer","text":"Release grabbed pointer events Source code in libqtile/backend/wayland/core.py 1046 1047 def ungrab_pointer ( self ) -> None : \"\"\"Release grabbed pointer events\"\"\"","title":"ungrab_pointer()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.unhide_cursor","text":"Unhide the cursor. Source code in libqtile/backend/wayland/core.py 1146 1147 1148 1149 1150 1151 1152 1153 1154 @expose_command () def unhide_cursor ( self ) -> None : \"\"\"Unhide the cursor.\"\"\" if self . _cursor_state . hidden : self . cursor . set_surface ( self . _cursor_state . surface , self . _cursor_state . hotspot , ) self . _cursor_state . hidden = False","title":"unhide_cursor()"},{"location":"reference/libqtile/backend/wayland/core/#libqtile.backend.wayland.core.Core.warp_pointer","text":"Warp the pointer to the coordinates in relative to the output layout Source code in libqtile/backend/wayland/core.py 1049 1050 1051 def warp_pointer ( self , x : float , y : float ) -> None : \"\"\"Warp the pointer to the coordinates in relative to the output layout\"\"\" self . cursor . warp ( WarpMode . LayoutClosest , x , y )","title":"warp_pointer()"},{"location":"reference/libqtile/backend/wayland/drawer/","text":"Drawer ( qtile , win , width , height ) Bases: base . Drawer A helper class for drawing and text layout. We stage drawing operations locally in memory using a cairo RecordingSurface. Then apply these operations to our ImageSurface self._source. Then copy the pixels onto the window's wlr_texture. Source code in libqtile/backend/wayland/drawer.py 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , qtile : Qtile , win : Internal , width : int , height : int ): base . Drawer . __init__ ( self , qtile , win , width , height ) self . _stride = cairocffi . ImageSurface . format_stride_for_width ( cairocffi . FORMAT_ARGB32 , self . width ) self . _source = cairocffi . ImageSurface ( cairocffi . FORMAT_ARGB32 , width , height ) with cairocffi . Context ( self . _source ) as context : # Initialise surface to all black context . set_source_rgba ( * utils . rgb ( \"#000000\" )) context . paint ()","title":"drawer"},{"location":"reference/libqtile/backend/wayland/drawer/#libqtile.backend.wayland.drawer.Drawer","text":"Bases: base . Drawer A helper class for drawing and text layout. We stage drawing operations locally in memory using a cairo RecordingSurface. Then apply these operations to our ImageSurface self._source. Then copy the pixels onto the window's wlr_texture. Source code in libqtile/backend/wayland/drawer.py 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , qtile : Qtile , win : Internal , width : int , height : int ): base . Drawer . __init__ ( self , qtile , win , width , height ) self . _stride = cairocffi . ImageSurface . format_stride_for_width ( cairocffi . FORMAT_ARGB32 , self . width ) self . _source = cairocffi . ImageSurface ( cairocffi . FORMAT_ARGB32 , width , height ) with cairocffi . Context ( self . _source ) as context : # Initialise surface to all black context . set_source_rgba ( * utils . rgb ( \"#000000\" )) context . paint ()","title":"Drawer"},{"location":"reference/libqtile/backend/wayland/inputs/","text":"InputConfig ( ** config ) Bases: configurable . Configurable This is used to configure input devices. An instance of this class represents one set of settings that can be applied to an input device. To use this, define a dictionary called wl_input_rules in your config. The keys are used to match input devices, and the values are instances of this class with the desired settings. For example: .. code-block:: python from libqtile.backend.wayland import InputConfig wl_input_rules = { \"1267:12377:ELAN1300:00 04F3:3059 Touchpad\": InputConfig(left_handed=True), \"*\": InputConfig(left_handed=True, pointer_accel=True), \"type:keyboard\": InputConfig(kb_options=\"ctrl:nocaps,compose:ralt\"), } When a input device is being configured, the most specific matching key in the dictionary is found and the corresponding settings are used to configure the device. Unique identifiers are chosen first, then \"type:X\" , then \"*\" . The command qtile cmd-obj -o core -f get_inputs can be used to get information about connected devices, including their identifiers. Options default to None , leave a device's default settings intact. For information on what each option does, see the documenation for libinput: https://wayland.freedesktop.org/libinput/doc/latest/configuration.html . Note that devices often only support a subset of settings. This tries to mirror how Sway configures libinput devices. For more information check out sway-input(5): https://man.archlinux.org/man/sway-input.5#LIBINPUT_CONFIGURATION Keyboards, managed by xkbcommon <https://github.com/xkbcommon/libxkbcommon> , are configured with the options prefixed by kb_ . X11's helpful XKB guide <https://www.x.org/releases/X11R7.5/doc/input/XKB-Config.html> may be useful for figuring out the syntax for some of these settings. Source code in libqtile/backend/wayland/inputs.py 122 123 124 def __init__ ( self , ** config : Any ) -> None : configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( InputConfig . defaults ) Keyboard ( core , wlr_device ) Bases: _Device Source code in libqtile/backend/wayland/inputs.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def __init__ ( self , core : Core , wlr_device : InputDevice ): super () . __init__ ( core , wlr_device ) self . qtile = core . qtile self . seat = core . seat self . keyboard = wlr_device . keyboard self . keyboard . data = self self . grabbed_keys = core . grabbed_keys self . keyboard . set_repeat_info ( 25 , 600 ) self . xkb_context = xkb . Context () self . _keymaps : dict [ tuple [ str | None , str | None , str | None ], xkb . Keymap ] = {} self . set_keymap ( None , None , None ) self . add_listener ( self . keyboard . modifiers_event , self . _on_modifier ) self . add_listener ( self . keyboard . key_event , self . _on_key ) self . add_listener ( self . keyboard . destroy_event , self . _on_destroy ) configure ( configs ) Applies InputConfig rules to this keyboard device. Source code in libqtile/backend/wayland/inputs.py 278 279 280 281 282 283 284 def configure ( self , configs : dict [ str , InputConfig ]) -> None : \"\"\"Applies ``InputConfig`` rules to this keyboard device.\"\"\" config = self . _match_config ( configs ) if config : self . keyboard . set_repeat_info ( config . kb_repeat_rate , config . kb_repeat_delay ) self . set_keymap ( config . kb_layout , config . kb_options , config . kb_variant ) set_keymap ( layout , options , variant ) Set the keymap for this keyboard. Source code in libqtile/backend/wayland/inputs.py 225 226 227 228 229 230 231 232 233 234 235 236 def set_keymap ( self , layout : str | None , options : str | None , variant : str | None ) -> None : \"\"\" Set the keymap for this keyboard. \"\"\" if ( layout , options , variant ) in self . _keymaps : keymap = self . _keymaps [( layout , options , variant )] else : keymap = self . xkb_context . keymap_new_from_names ( layout = layout , options = options , variant = variant ) self . _keymaps [( layout , options , variant )] = keymap self . keyboard . set_keymap ( keymap ) Pointer ( core , wlr_device ) Bases: _Device Source code in libqtile/backend/wayland/inputs.py 290 291 292 293 def __init__ ( self , core : Core , wlr_device : InputDevice ): super () . __init__ ( core , wlr_device ) self . add_listener ( wlr_device . destroy_event , self . _on_destroy ) configure ( configs ) Applies InputConfig rules to this pointer device. Source code in libqtile/backend/wayland/inputs.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def configure ( self , configs : dict [ str , InputConfig ]) -> None : \"\"\"Applies ``InputConfig`` rules to this pointer device.\"\"\" config = self . _match_config ( configs ) if config is None : return handle = self . wlr_device . libinput_get_device_handle () if handle is None : logger . debug ( \"Device not handled by libinput: %s \" , self . wlr_device . name ) return if libinput is None : if not Pointer . _logged_unsupported : logger . error ( \"Qtile was not built with libinput configuration support. \" \"For support, pywlroots must be installed at build time.\" ) Pointer . _logged_unsupported = True return if libinput . libinput_device_config_accel_is_available ( handle ): if ACCEL_PROFILES . get ( config . accel_profile ): libinput . libinput_device_config_accel_set_profile ( handle , ACCEL_PROFILES . get ( config . accel_profile ) ) if config . pointer_accel is not None : libinput . libinput_device_config_accel_set_speed ( handle , config . pointer_accel ) if CLICK_METHODS . get ( config . click_method ): libinput . libinput_device_config_click_set_method ( handle , CLICK_METHODS . get ( config . click_method ) ) if config . drag is not None : libinput . libinput_device_config_tap_set_drag_enabled ( handle , int ( config . drag )) if config . drag_lock is not None : libinput . libinput_device_config_tap_set_drag_lock_enabled ( handle , int ( config . drag_lock ) ) if config . dwt is not None : if libinput . libinput_device_config_dwt_is_available ( handle ): libinput . libinput_device_config_dwt_set_enabled ( handle , int ( config . dwt )) if config . left_handed is not None : if libinput . libinput_device_config_left_handed_is_available ( handle ): libinput . libinput_device_config_left_handed_set ( handle , int ( config . left_handed )) if config . middle_emulation is not None : libinput . libinput_device_config_middle_emulation_set_enabled ( handle , int ( config . middle_emulation ) ) if config . natural_scroll is not None : if libinput . libinput_device_config_scroll_has_natural_scroll ( handle ): libinput . libinput_device_config_scroll_set_natural_scroll_enabled ( handle , int ( config . natural_scroll ) ) if SCROLL_METHODS . get ( config . scroll_method ): libinput . libinput_device_config_scroll_set_method ( handle , SCROLL_METHODS . get ( config . scroll_method ) ) if config . scroll_method == \"on_button_down\" : if isinstance ( config . scroll_button , str ): if config . scroll_button == \"disable\" : button = 0 else : # e.g. Button1 button = buttons [ int ( config . scroll_button [ - 1 ]) - 1 ] else : button = config . scroll_button libinput . libinput_device_config_scroll_set_button ( handle , button ) if libinput . libinput_device_config_tap_get_finger_count ( handle ) > 1 : if config . tap is not None : libinput . libinput_device_config_tap_set_enabled ( handle , int ( config . tap )) if config . tap_button_map is not None : if TAP_MAPS . get ( config . tap_button_map ): libinput . libinput_device_config_tap_set_button_map ( handle , TAP_MAPS . get ( config . tap_button_map ) )","title":"inputs"},{"location":"reference/libqtile/backend/wayland/inputs/#libqtile.backend.wayland.inputs.InputConfig","text":"Bases: configurable . Configurable This is used to configure input devices. An instance of this class represents one set of settings that can be applied to an input device. To use this, define a dictionary called wl_input_rules in your config. The keys are used to match input devices, and the values are instances of this class with the desired settings. For example: .. code-block:: python from libqtile.backend.wayland import InputConfig wl_input_rules = { \"1267:12377:ELAN1300:00 04F3:3059 Touchpad\": InputConfig(left_handed=True), \"*\": InputConfig(left_handed=True, pointer_accel=True), \"type:keyboard\": InputConfig(kb_options=\"ctrl:nocaps,compose:ralt\"), } When a input device is being configured, the most specific matching key in the dictionary is found and the corresponding settings are used to configure the device. Unique identifiers are chosen first, then \"type:X\" , then \"*\" . The command qtile cmd-obj -o core -f get_inputs can be used to get information about connected devices, including their identifiers. Options default to None , leave a device's default settings intact. For information on what each option does, see the documenation for libinput: https://wayland.freedesktop.org/libinput/doc/latest/configuration.html . Note that devices often only support a subset of settings. This tries to mirror how Sway configures libinput devices. For more information check out sway-input(5): https://man.archlinux.org/man/sway-input.5#LIBINPUT_CONFIGURATION Keyboards, managed by xkbcommon <https://github.com/xkbcommon/libxkbcommon> , are configured with the options prefixed by kb_ . X11's helpful XKB guide <https://www.x.org/releases/X11R7.5/doc/input/XKB-Config.html> may be useful for figuring out the syntax for some of these settings. Source code in libqtile/backend/wayland/inputs.py 122 123 124 def __init__ ( self , ** config : Any ) -> None : configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( InputConfig . defaults )","title":"InputConfig"},{"location":"reference/libqtile/backend/wayland/inputs/#libqtile.backend.wayland.inputs.Keyboard","text":"Bases: _Device Source code in libqtile/backend/wayland/inputs.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def __init__ ( self , core : Core , wlr_device : InputDevice ): super () . __init__ ( core , wlr_device ) self . qtile = core . qtile self . seat = core . seat self . keyboard = wlr_device . keyboard self . keyboard . data = self self . grabbed_keys = core . grabbed_keys self . keyboard . set_repeat_info ( 25 , 600 ) self . xkb_context = xkb . Context () self . _keymaps : dict [ tuple [ str | None , str | None , str | None ], xkb . Keymap ] = {} self . set_keymap ( None , None , None ) self . add_listener ( self . keyboard . modifiers_event , self . _on_modifier ) self . add_listener ( self . keyboard . key_event , self . _on_key ) self . add_listener ( self . keyboard . destroy_event , self . _on_destroy )","title":"Keyboard"},{"location":"reference/libqtile/backend/wayland/inputs/#libqtile.backend.wayland.inputs.Keyboard.configure","text":"Applies InputConfig rules to this keyboard device. Source code in libqtile/backend/wayland/inputs.py 278 279 280 281 282 283 284 def configure ( self , configs : dict [ str , InputConfig ]) -> None : \"\"\"Applies ``InputConfig`` rules to this keyboard device.\"\"\" config = self . _match_config ( configs ) if config : self . keyboard . set_repeat_info ( config . kb_repeat_rate , config . kb_repeat_delay ) self . set_keymap ( config . kb_layout , config . kb_options , config . kb_variant )","title":"configure()"},{"location":"reference/libqtile/backend/wayland/inputs/#libqtile.backend.wayland.inputs.Keyboard.set_keymap","text":"Set the keymap for this keyboard. Source code in libqtile/backend/wayland/inputs.py 225 226 227 228 229 230 231 232 233 234 235 236 def set_keymap ( self , layout : str | None , options : str | None , variant : str | None ) -> None : \"\"\" Set the keymap for this keyboard. \"\"\" if ( layout , options , variant ) in self . _keymaps : keymap = self . _keymaps [( layout , options , variant )] else : keymap = self . xkb_context . keymap_new_from_names ( layout = layout , options = options , variant = variant ) self . _keymaps [( layout , options , variant )] = keymap self . keyboard . set_keymap ( keymap )","title":"set_keymap()"},{"location":"reference/libqtile/backend/wayland/inputs/#libqtile.backend.wayland.inputs.Pointer","text":"Bases: _Device Source code in libqtile/backend/wayland/inputs.py 290 291 292 293 def __init__ ( self , core : Core , wlr_device : InputDevice ): super () . __init__ ( core , wlr_device ) self . add_listener ( wlr_device . destroy_event , self . _on_destroy )","title":"Pointer"},{"location":"reference/libqtile/backend/wayland/inputs/#libqtile.backend.wayland.inputs.Pointer.configure","text":"Applies InputConfig rules to this pointer device. Source code in libqtile/backend/wayland/inputs.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def configure ( self , configs : dict [ str , InputConfig ]) -> None : \"\"\"Applies ``InputConfig`` rules to this pointer device.\"\"\" config = self . _match_config ( configs ) if config is None : return handle = self . wlr_device . libinput_get_device_handle () if handle is None : logger . debug ( \"Device not handled by libinput: %s \" , self . wlr_device . name ) return if libinput is None : if not Pointer . _logged_unsupported : logger . error ( \"Qtile was not built with libinput configuration support. \" \"For support, pywlroots must be installed at build time.\" ) Pointer . _logged_unsupported = True return if libinput . libinput_device_config_accel_is_available ( handle ): if ACCEL_PROFILES . get ( config . accel_profile ): libinput . libinput_device_config_accel_set_profile ( handle , ACCEL_PROFILES . get ( config . accel_profile ) ) if config . pointer_accel is not None : libinput . libinput_device_config_accel_set_speed ( handle , config . pointer_accel ) if CLICK_METHODS . get ( config . click_method ): libinput . libinput_device_config_click_set_method ( handle , CLICK_METHODS . get ( config . click_method ) ) if config . drag is not None : libinput . libinput_device_config_tap_set_drag_enabled ( handle , int ( config . drag )) if config . drag_lock is not None : libinput . libinput_device_config_tap_set_drag_lock_enabled ( handle , int ( config . drag_lock ) ) if config . dwt is not None : if libinput . libinput_device_config_dwt_is_available ( handle ): libinput . libinput_device_config_dwt_set_enabled ( handle , int ( config . dwt )) if config . left_handed is not None : if libinput . libinput_device_config_left_handed_is_available ( handle ): libinput . libinput_device_config_left_handed_set ( handle , int ( config . left_handed )) if config . middle_emulation is not None : libinput . libinput_device_config_middle_emulation_set_enabled ( handle , int ( config . middle_emulation ) ) if config . natural_scroll is not None : if libinput . libinput_device_config_scroll_has_natural_scroll ( handle ): libinput . libinput_device_config_scroll_set_natural_scroll_enabled ( handle , int ( config . natural_scroll ) ) if SCROLL_METHODS . get ( config . scroll_method ): libinput . libinput_device_config_scroll_set_method ( handle , SCROLL_METHODS . get ( config . scroll_method ) ) if config . scroll_method == \"on_button_down\" : if isinstance ( config . scroll_button , str ): if config . scroll_button == \"disable\" : button = 0 else : # e.g. Button1 button = buttons [ int ( config . scroll_button [ - 1 ]) - 1 ] else : button = config . scroll_button libinput . libinput_device_config_scroll_set_button ( handle , button ) if libinput . libinput_device_config_tap_get_finger_count ( handle ) > 1 : if config . tap is not None : libinput . libinput_device_config_tap_set_enabled ( handle , int ( config . tap )) if config . tap_button_map is not None : if TAP_MAPS . get ( config . tap_button_map ): libinput . libinput_device_config_tap_set_button_map ( handle , TAP_MAPS . get ( config . tap_button_map ) )","title":"configure()"},{"location":"reference/libqtile/backend/wayland/layer/","text":"LayerStatic ( core , qtile , surface , wid ) Bases: Static [ LayerSurfaceV1 ] A static window belonging to the layer shell. Source code in libqtile/backend/wayland/layer.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , core : Core , qtile : Qtile , surface : LayerSurfaceV1 , wid : int , ): Static . __init__ ( self , core , qtile , surface , wid ) self . subsurfaces : list [ SubSurface ] = [] self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . _layer = LayerShellV1Layer . BACKGROUND self . desired_width = 0 self . desired_height = 0 if surface . output is None : surface . output = core . output_layout . output_at ( core . cursor . x , core . cursor . y ) if surface . output : output = surface . output . data if output : self . output = output self . screen = self . output . screen self . mapped = True self . _outputs . add ( self . output )","title":"layer"},{"location":"reference/libqtile/backend/wayland/layer/#libqtile.backend.wayland.layer.LayerStatic","text":"Bases: Static [ LayerSurfaceV1 ] A static window belonging to the layer shell. Source code in libqtile/backend/wayland/layer.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , core : Core , qtile : Qtile , surface : LayerSurfaceV1 , wid : int , ): Static . __init__ ( self , core , qtile , surface , wid ) self . subsurfaces : list [ SubSurface ] = [] self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . _layer = LayerShellV1Layer . BACKGROUND self . desired_width = 0 self . desired_height = 0 if surface . output is None : surface . output = core . output_layout . output_at ( core . cursor . x , core . cursor . y ) if surface . output : output = surface . output . data if output : self . output = output self . screen = self . output . screen self . mapped = True self . _outputs . add ( self . output )","title":"LayerStatic"},{"location":"reference/libqtile/backend/wayland/libinput_ffi_build/","text":"","title":"libinput_ffi_build"},{"location":"reference/libqtile/backend/wayland/output/","text":"Output ( core , wlr_output ) Bases: HasListeners Source code in libqtile/backend/wayland/output.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __init__ ( self , core : Core , wlr_output : wlrOutput ): self . core = core self . renderer = core . renderer self . wlr_output = wlr_output wlr_output . data = self self . output_layout = self . core . output_layout self . _damage : OutputDamage = OutputDamage ( wlr_output ) self . wallpaper : Texture | None = None self . x , self . y = self . output_layout . output_coords ( wlr_output ) self . add_listener ( wlr_output . destroy_event , self . _on_destroy ) self . add_listener ( self . _damage . frame_event , self . _on_frame ) # The layers enum indexes into this list to get a list of surfaces self . layers : list [ list [ LayerStatic ]] = [[] for _ in range ( len ( LayerShellV1Layer ))] # This is run during tests, when we want to fix the output's geometry if wlr_output . is_headless and \"PYTEST_CURRENT_TEST\" in os . environ : assert len ( core . outputs ) < 2 , \"This should not be reached\" if not core . outputs : # First test output wlr_output . set_custom_mode ( 800 , 600 , 0 ) else : # Second test output wlr_output . set_custom_mode ( 640 , 480 , 0 ) wlr_output . commit () contains ( rect ) Returns whether the given window is visible on this output. Source code in libqtile/backend/wayland/output.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def contains ( self , rect : WindowType | Dnd ) -> bool : \"\"\"Returns whether the given window is visible on this output.\"\"\" if rect . x + rect . width < self . x : return False if rect . y + rect . height < self . y : return False ow , oh = self . wlr_output . effective_resolution () if self . x + ow < rect . x : return False if self . y + oh < rect . y : return False return True damage () Damage this output so it gets re-rendered. Source code in libqtile/backend/wayland/output.py 340 341 342 343 def damage ( self ) -> None : \"\"\"Damage this output so it gets re-rendered.\"\"\" if self . wlr_output . enabled : self . _damage . add_whole () organise_layers () Organise the positioning of layer shell surfaces. Source code in libqtile/backend/wayland/output.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def organise_layers ( self ) -> None : \"\"\"Organise the positioning of layer shell surfaces.\"\"\" logger . debug ( \"Output: organising layers\" ) ow , oh = self . wlr_output . effective_resolution () for layer in self . layers : for win in layer : state = win . surface . current margin = state . margin ww = win . desired_width = state . desired_width wh = win . desired_height = state . desired_height # Horizontal axis if ( state . anchor & LayerSurfaceV1Anchor . HORIZONTAL ) and ww == 0 : x = margin . left ww = ow - margin . left - margin . right elif state . anchor & LayerSurfaceV1Anchor . LEFT : x = margin . left elif state . anchor & LayerSurfaceV1Anchor . RIGHT : x = ow - ww - margin . right else : x = int ( ow / 2 - ww / 2 ) # Vertical axis if ( state . anchor & LayerSurfaceV1Anchor . VERTICAL ) and wh == 0 : y = margin . top wh = oh - margin . top - margin . bottom elif state . anchor & LayerSurfaceV1Anchor . TOP : y = margin . top elif state . anchor & LayerSurfaceV1Anchor . BOTTOM : y = oh - wh - margin . bottom else : y = int ( oh / 2 - wh / 2 ) if ww <= 0 or wh <= 0 : win . kill () continue if 0 < state . exclusive_zone : # Reserve space if: # - layer is anchored to an edge and both perpendicular edges, or # - layer is anchored to a single edge only. space = [ 0 , 0 , 0 , 0 ] if state . anchor & LayerSurfaceV1Anchor . HORIZONTAL : if state . anchor & LayerSurfaceV1Anchor . TOP : space [ 2 ] = state . exclusive_zone elif state . anchor & LayerSurfaceV1Anchor . BOTTOM : space [ 3 ] = state . exclusive_zone elif state . anchor & LayerSurfaceV1Anchor . VERTICAL : if state . anchor & LayerSurfaceV1Anchor . LEFT : space [ 0 ] = state . exclusive_zone elif state . anchor & LayerSurfaceV1Anchor . RIGHT : space [ 1 ] = state . exclusive_zone else : # Single edge only if state . anchor == LayerSurfaceV1Anchor . TOP : space [ 2 ] = state . exclusive_zone elif state . anchor == LayerSurfaceV1Anchor . BOTTOM : space [ 3 ] = state . exclusive_zone if state . anchor == LayerSurfaceV1Anchor . LEFT : space [ 0 ] = state . exclusive_zone elif state . anchor == LayerSurfaceV1Anchor . RIGHT : space [ 1 ] = state . exclusive_zone to_reserve : tuple [ int , int , int , int ] = tuple ( space ) # type: ignore if win . reserved_space != to_reserve : # Don't reserve more space if it's already been reserved assert self . core . qtile is not None self . core . qtile . reserve_space ( to_reserve , self . screen ) win . reserved_space = to_reserve win . place ( int ( x + self . x ), int ( y + self . y ), int ( ww ), int ( wh ), 0 , None ) self . core . stack_windows ()","title":"output"},{"location":"reference/libqtile/backend/wayland/output/#libqtile.backend.wayland.output.Output","text":"Bases: HasListeners Source code in libqtile/backend/wayland/output.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __init__ ( self , core : Core , wlr_output : wlrOutput ): self . core = core self . renderer = core . renderer self . wlr_output = wlr_output wlr_output . data = self self . output_layout = self . core . output_layout self . _damage : OutputDamage = OutputDamage ( wlr_output ) self . wallpaper : Texture | None = None self . x , self . y = self . output_layout . output_coords ( wlr_output ) self . add_listener ( wlr_output . destroy_event , self . _on_destroy ) self . add_listener ( self . _damage . frame_event , self . _on_frame ) # The layers enum indexes into this list to get a list of surfaces self . layers : list [ list [ LayerStatic ]] = [[] for _ in range ( len ( LayerShellV1Layer ))] # This is run during tests, when we want to fix the output's geometry if wlr_output . is_headless and \"PYTEST_CURRENT_TEST\" in os . environ : assert len ( core . outputs ) < 2 , \"This should not be reached\" if not core . outputs : # First test output wlr_output . set_custom_mode ( 800 , 600 , 0 ) else : # Second test output wlr_output . set_custom_mode ( 640 , 480 , 0 ) wlr_output . commit ()","title":"Output"},{"location":"reference/libqtile/backend/wayland/output/#libqtile.backend.wayland.output.Output.contains","text":"Returns whether the given window is visible on this output. Source code in libqtile/backend/wayland/output.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def contains ( self , rect : WindowType | Dnd ) -> bool : \"\"\"Returns whether the given window is visible on this output.\"\"\" if rect . x + rect . width < self . x : return False if rect . y + rect . height < self . y : return False ow , oh = self . wlr_output . effective_resolution () if self . x + ow < rect . x : return False if self . y + oh < rect . y : return False return True","title":"contains()"},{"location":"reference/libqtile/backend/wayland/output/#libqtile.backend.wayland.output.Output.damage","text":"Damage this output so it gets re-rendered. Source code in libqtile/backend/wayland/output.py 340 341 342 343 def damage ( self ) -> None : \"\"\"Damage this output so it gets re-rendered.\"\"\" if self . wlr_output . enabled : self . _damage . add_whole ()","title":"damage()"},{"location":"reference/libqtile/backend/wayland/output/#libqtile.backend.wayland.output.Output.organise_layers","text":"Organise the positioning of layer shell surfaces. Source code in libqtile/backend/wayland/output.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def organise_layers ( self ) -> None : \"\"\"Organise the positioning of layer shell surfaces.\"\"\" logger . debug ( \"Output: organising layers\" ) ow , oh = self . wlr_output . effective_resolution () for layer in self . layers : for win in layer : state = win . surface . current margin = state . margin ww = win . desired_width = state . desired_width wh = win . desired_height = state . desired_height # Horizontal axis if ( state . anchor & LayerSurfaceV1Anchor . HORIZONTAL ) and ww == 0 : x = margin . left ww = ow - margin . left - margin . right elif state . anchor & LayerSurfaceV1Anchor . LEFT : x = margin . left elif state . anchor & LayerSurfaceV1Anchor . RIGHT : x = ow - ww - margin . right else : x = int ( ow / 2 - ww / 2 ) # Vertical axis if ( state . anchor & LayerSurfaceV1Anchor . VERTICAL ) and wh == 0 : y = margin . top wh = oh - margin . top - margin . bottom elif state . anchor & LayerSurfaceV1Anchor . TOP : y = margin . top elif state . anchor & LayerSurfaceV1Anchor . BOTTOM : y = oh - wh - margin . bottom else : y = int ( oh / 2 - wh / 2 ) if ww <= 0 or wh <= 0 : win . kill () continue if 0 < state . exclusive_zone : # Reserve space if: # - layer is anchored to an edge and both perpendicular edges, or # - layer is anchored to a single edge only. space = [ 0 , 0 , 0 , 0 ] if state . anchor & LayerSurfaceV1Anchor . HORIZONTAL : if state . anchor & LayerSurfaceV1Anchor . TOP : space [ 2 ] = state . exclusive_zone elif state . anchor & LayerSurfaceV1Anchor . BOTTOM : space [ 3 ] = state . exclusive_zone elif state . anchor & LayerSurfaceV1Anchor . VERTICAL : if state . anchor & LayerSurfaceV1Anchor . LEFT : space [ 0 ] = state . exclusive_zone elif state . anchor & LayerSurfaceV1Anchor . RIGHT : space [ 1 ] = state . exclusive_zone else : # Single edge only if state . anchor == LayerSurfaceV1Anchor . TOP : space [ 2 ] = state . exclusive_zone elif state . anchor == LayerSurfaceV1Anchor . BOTTOM : space [ 3 ] = state . exclusive_zone if state . anchor == LayerSurfaceV1Anchor . LEFT : space [ 0 ] = state . exclusive_zone elif state . anchor == LayerSurfaceV1Anchor . RIGHT : space [ 1 ] = state . exclusive_zone to_reserve : tuple [ int , int , int , int ] = tuple ( space ) # type: ignore if win . reserved_space != to_reserve : # Don't reserve more space if it's already been reserved assert self . core . qtile is not None self . core . qtile . reserve_space ( to_reserve , self . screen ) win . reserved_space = to_reserve win . place ( int ( x + self . x ), int ( y + self . y ), int ( ww ), int ( wh ), 0 , None ) self . core . stack_windows ()","title":"organise_layers()"},{"location":"reference/libqtile/backend/wayland/subsurface/","text":"SubSurface ( parent , subsurface ) Bases: HasListeners This represents a single struct wlr_subsurface object and is owned by a single parent window (of WindowType | SubSurface ). We only need to track them so that we can listen to their commit events and render accordingly. Source code in libqtile/backend/wayland/subsurface.py 44 45 46 47 48 49 50 def __init__ ( self , parent : XdgWindow | SubSurface , subsurface : WlrSubSurface ): self . parent = parent self . subsurfaces : list [ SubSurface ] = [] self . add_listener ( subsurface . destroy_event , self . _on_destroy ) self . add_listener ( subsurface . surface . commit_event , parent . _on_commit ) self . add_listener ( subsurface . surface . new_subsurface_event , self . _on_new_subsurface )","title":"subsurface"},{"location":"reference/libqtile/backend/wayland/subsurface/#libqtile.backend.wayland.subsurface.SubSurface","text":"Bases: HasListeners This represents a single struct wlr_subsurface object and is owned by a single parent window (of WindowType | SubSurface ). We only need to track them so that we can listen to their commit events and render accordingly. Source code in libqtile/backend/wayland/subsurface.py 44 45 46 47 48 49 50 def __init__ ( self , parent : XdgWindow | SubSurface , subsurface : WlrSubSurface ): self . parent = parent self . subsurfaces : list [ SubSurface ] = [] self . add_listener ( subsurface . destroy_event , self . _on_destroy ) self . add_listener ( subsurface . surface . commit_event , parent . _on_commit ) self . add_listener ( subsurface . surface . new_subsurface_event , self . _on_new_subsurface )","title":"SubSurface"},{"location":"reference/libqtile/backend/wayland/window/","text":"Internal ( core , qtile , x , y , width , height ) Bases: _Base , base . Internal Internal windows are simply textures controlled by the compositor. Source code in libqtile/backend/wayland/window.py 790 791 792 793 794 795 796 797 798 799 800 801 def __init__ ( self , core : Core , qtile : Qtile , x : int , y : int , width : int , height : int ): self . core = core self . qtile = qtile self . _mapped : bool = False self . _wid : int = self . core . new_wid () self . x : int = x self . y : int = y self . _width : int = width self . _height : int = height self . _opacity : float = 1.0 self . _outputs : set [ Output ] = set ( o for o in self . core . outputs if o . contains ( self )) self . texture : Texture = self . _new_texture () create_drawer ( width , height ) Create a Drawer that draws to this window. Source code in libqtile/backend/wayland/window.py 821 822 823 def create_drawer ( self , width : int , height : int ) -> Drawer : \"\"\"Create a Drawer that draws to this window.\"\"\" return Drawer ( self . qtile , self , width , height ) info () Return a dictionary of info. Source code in libqtile/backend/wayland/window.py 895 896 897 898 899 900 901 902 903 904 @expose_command () def info ( self ) -> dict : \"\"\"Return a dictionary of info.\"\"\" return dict ( x = self . x , y = self . y , width = self . width , height = self . height , id = self . wid , ) PointerConstraint ( core , wlr_constraint ) Bases: HasListeners A small object to listen to signals on struct wlr_pointer_constraint_v1 instances. Source code in libqtile/backend/wayland/window.py 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 def __init__ ( self , core : Core , wlr_constraint : PointerConstraintV1 ): self . core = core self . wlr_constraint = wlr_constraint self . _warp_target : tuple [ float , float ] = ( 0 , 0 ) self . _needs_warp : bool = False assert core . qtile is not None owner = None for win in core . qtile . windows_map . values (): if isinstance ( win , ( Window | Static )): if win . surface . surface == self . wlr_constraint . surface : owner = win break if owner is None : logger . error ( \"No window found for pointer constraints. Please report.\" ) raise RuntimeError self . window : Window | Static = owner self . add_listener ( wlr_constraint . set_region_event , self . _on_set_region ) self . add_listener ( wlr_constraint . destroy_event , self . _on_destroy ) Window ( core , qtile , surface ) Bases: typing . Generic [ S ] , _Base , base . Window , HasListeners This is a generic window class for \"regular\" windows. The type variable S denotes which type of surface the window manages, and by extension which shell the window belongs to. While this does implement some of base.Window 's abstract methods, the concrete classes are responsible for implementing a few others. Source code in libqtile/backend/wayland/window.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def __init__ ( self , core : Core , qtile : Qtile , surface : S ): base . Window . __init__ ( self ) self . core = core self . qtile = qtile self . surface = surface self . _group : _Group | None = None self . _mapped : bool = False self . x = 0 self . y = 0 self . bordercolor : list [ ffi . CData ] = [ _rgb (( 0 , 0 , 0 , 1 ))] self . _opacity : float = 1.0 self . _outputs : set [ Output ] = set () self . _wm_class : str | None = None self . _idle_inhibitors_count : int = 0 # This is a placeholder to be set properly when the window maps for the first # time (and therefore exposed to the user). We need the attribute to exist so # that __repr__ doesn't AttributeError. self . _wid : int = - 1 self . _width : int = 0 self . _height : int = 0 self . float_x : int | None = None self . float_y : int | None = None self . _float_width : int = 0 self . _float_height : int = 0 self . _float_state = FloatStates . NOT_FLOATING surface . data = self . ftm_handle = core . foreign_toplevel_manager_v1 . create_handle () info () Return a dictionary of info. Source code in libqtile/backend/wayland/window.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 @expose_command () def info ( self ) -> dict : \"\"\"Return a dictionary of info.\"\"\" float_info = { \"x\" : self . float_x , \"y\" : self . float_y , \"width\" : self . _float_width , \"height\" : self . _float_height , } return dict ( name = self . name , x = self . x , y = self . y , width = self . width , height = self . height , group = self . group . name if self . group else None , id = self . wid , wm_class = self . get_wm_class (), float_info = float_info , floating = self . _float_state != FloatStates . NOT_FLOATING , maximized = self . _float_state == FloatStates . MAXIMIZED , minimized = self . _float_state == FloatStates . MINIMIZED , fullscreen = self . _float_state == FloatStates . FULLSCREEN , ) togroup ( group_name = None , * , switch_group = False , toggle = False ) Move window to a specified group Also switch to that group if switch_group is True. If toggle is True and and the specified group is already on the screen, use the last used group as target instead. Source code in libqtile/backend/wayland/window.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def togroup ( self , group_name : str | None = None , * , switch_group : bool = False , toggle : bool = False ) -> None : \"\"\" Move window to a specified group Also switch to that group if switch_group is True. If `toggle` is True and and the specified group is already on the screen, use the last used group as target instead. \"\"\" if group_name is None : group = self . qtile . current_group else : if group_name not in self . qtile . groups_map : raise CommandError ( \"No such group: %s \" % group_name ) group = self . qtile . groups_map [ group_name ] if self . group is group : if toggle and self . group . screen . previous_group : group = self . group . screen . previous_group else : return self . hide () if self . group : if self . group . screen : # for floats remove window offset self . x -= self . group . screen . x self . group . remove ( self ) if group . screen and self . x < group . screen . x : self . x += group . screen . x group . add ( self ) if switch_group : group . toscreen ( toggle = toggle )","title":"window"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.Internal","text":"Bases: _Base , base . Internal Internal windows are simply textures controlled by the compositor. Source code in libqtile/backend/wayland/window.py 790 791 792 793 794 795 796 797 798 799 800 801 def __init__ ( self , core : Core , qtile : Qtile , x : int , y : int , width : int , height : int ): self . core = core self . qtile = qtile self . _mapped : bool = False self . _wid : int = self . core . new_wid () self . x : int = x self . y : int = y self . _width : int = width self . _height : int = height self . _opacity : float = 1.0 self . _outputs : set [ Output ] = set ( o for o in self . core . outputs if o . contains ( self )) self . texture : Texture = self . _new_texture ()","title":"Internal"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.Internal.create_drawer","text":"Create a Drawer that draws to this window. Source code in libqtile/backend/wayland/window.py 821 822 823 def create_drawer ( self , width : int , height : int ) -> Drawer : \"\"\"Create a Drawer that draws to this window.\"\"\" return Drawer ( self . qtile , self , width , height )","title":"create_drawer()"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.Internal.info","text":"Return a dictionary of info. Source code in libqtile/backend/wayland/window.py 895 896 897 898 899 900 901 902 903 904 @expose_command () def info ( self ) -> dict : \"\"\"Return a dictionary of info.\"\"\" return dict ( x = self . x , y = self . y , width = self . width , height = self . height , id = self . wid , )","title":"info()"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.PointerConstraint","text":"Bases: HasListeners A small object to listen to signals on struct wlr_pointer_constraint_v1 instances. Source code in libqtile/backend/wayland/window.py 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 def __init__ ( self , core : Core , wlr_constraint : PointerConstraintV1 ): self . core = core self . wlr_constraint = wlr_constraint self . _warp_target : tuple [ float , float ] = ( 0 , 0 ) self . _needs_warp : bool = False assert core . qtile is not None owner = None for win in core . qtile . windows_map . values (): if isinstance ( win , ( Window | Static )): if win . surface . surface == self . wlr_constraint . surface : owner = win break if owner is None : logger . error ( \"No window found for pointer constraints. Please report.\" ) raise RuntimeError self . window : Window | Static = owner self . add_listener ( wlr_constraint . set_region_event , self . _on_set_region ) self . add_listener ( wlr_constraint . destroy_event , self . _on_destroy )","title":"PointerConstraint"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.Window","text":"Bases: typing . Generic [ S ] , _Base , base . Window , HasListeners This is a generic window class for \"regular\" windows. The type variable S denotes which type of surface the window manages, and by extension which shell the window belongs to. While this does implement some of base.Window 's abstract methods, the concrete classes are responsible for implementing a few others. Source code in libqtile/backend/wayland/window.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def __init__ ( self , core : Core , qtile : Qtile , surface : S ): base . Window . __init__ ( self ) self . core = core self . qtile = qtile self . surface = surface self . _group : _Group | None = None self . _mapped : bool = False self . x = 0 self . y = 0 self . bordercolor : list [ ffi . CData ] = [ _rgb (( 0 , 0 , 0 , 1 ))] self . _opacity : float = 1.0 self . _outputs : set [ Output ] = set () self . _wm_class : str | None = None self . _idle_inhibitors_count : int = 0 # This is a placeholder to be set properly when the window maps for the first # time (and therefore exposed to the user). We need the attribute to exist so # that __repr__ doesn't AttributeError. self . _wid : int = - 1 self . _width : int = 0 self . _height : int = 0 self . float_x : int | None = None self . float_y : int | None = None self . _float_width : int = 0 self . _float_height : int = 0 self . _float_state = FloatStates . NOT_FLOATING surface . data = self . ftm_handle = core . foreign_toplevel_manager_v1 . create_handle ()","title":"Window"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.Window.info","text":"Return a dictionary of info. Source code in libqtile/backend/wayland/window.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 @expose_command () def info ( self ) -> dict : \"\"\"Return a dictionary of info.\"\"\" float_info = { \"x\" : self . float_x , \"y\" : self . float_y , \"width\" : self . _float_width , \"height\" : self . _float_height , } return dict ( name = self . name , x = self . x , y = self . y , width = self . width , height = self . height , group = self . group . name if self . group else None , id = self . wid , wm_class = self . get_wm_class (), float_info = float_info , floating = self . _float_state != FloatStates . NOT_FLOATING , maximized = self . _float_state == FloatStates . MAXIMIZED , minimized = self . _float_state == FloatStates . MINIMIZED , fullscreen = self . _float_state == FloatStates . FULLSCREEN , )","title":"info()"},{"location":"reference/libqtile/backend/wayland/window/#libqtile.backend.wayland.window.Window.togroup","text":"Move window to a specified group Also switch to that group if switch_group is True. If toggle is True and and the specified group is already on the screen, use the last used group as target instead. Source code in libqtile/backend/wayland/window.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def togroup ( self , group_name : str | None = None , * , switch_group : bool = False , toggle : bool = False ) -> None : \"\"\" Move window to a specified group Also switch to that group if switch_group is True. If `toggle` is True and and the specified group is already on the screen, use the last used group as target instead. \"\"\" if group_name is None : group = self . qtile . current_group else : if group_name not in self . qtile . groups_map : raise CommandError ( \"No such group: %s \" % group_name ) group = self . qtile . groups_map [ group_name ] if self . group is group : if toggle and self . group . screen . previous_group : group = self . group . screen . previous_group else : return self . hide () if self . group : if self . group . screen : # for floats remove window offset self . x -= self . group . screen . x self . group . remove ( self ) if group . screen and self . x < group . screen . x : self . x += group . screen . x group . add ( self ) if switch_group : group . toscreen ( toggle = toggle )","title":"togroup()"},{"location":"reference/libqtile/backend/wayland/wlrq/","text":"CursorState dataclass The surface and hotspot state of the cursor. This is tracked directly by the core so that the cursor can be hidden and later restored to this state at will. Dnd ( core , wlr_drag ) Bases: HasListeners A helper for drag and drop functionality. Source code in libqtile/backend/wayland/wlrq.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def __init__ ( self , core : Core , wlr_drag : data_device_manager . Drag ): self . core = core self . wlr_drag = wlr_drag self . _outputs : set [ Output ] = set () self . x : float = core . cursor . x self . y : float = core . cursor . y self . width : int = 0 # Set upon surface commit self . height : int = 0 self . add_listener ( wlr_drag . destroy_event , self . _on_destroy ) self . icon = icon = wlr_drag . icon if icon is not None : self . add_listener ( icon . map_event , self . _on_icon_map ) self . add_listener ( icon . unmap_event , self . _on_icon_unmap ) self . add_listener ( icon . destroy_event , self . _on_icon_destroy ) self . add_listener ( icon . surface . commit_event , self . _on_icon_commit ) HasListeners Classes can subclass this to get some convenience handlers around pywayland.server.Listener . This guarantees that all listeners that set up and then removed in reverse order. get_xwayland_atoms ( xwayland ) These can be used when matching on XWayland clients with wm_type. http://standards.freedesktop.org/wm-spec/latest/ar01s05.html#idm139870830002400 Source code in libqtile/backend/wayland/wlrq.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def get_xwayland_atoms ( xwayland : xwayland . XWayland ) -> dict [ int , str ]: \"\"\" These can be used when matching on XWayland clients with wm_type. http://standards.freedesktop.org/wm-spec/latest/ar01s05.html#idm139870830002400 \"\"\" xwayland_wm_types = { \"_NET_WM_WINDOW_TYPE_DESKTOP\" : \"desktop\" , \"_NET_WM_WINDOW_TYPE_DOCK\" : \"dock\" , \"_NET_WM_WINDOW_TYPE_TOOLBAR\" : \"toolbar\" , \"_NET_WM_WINDOW_TYPE_MENU\" : \"menu\" , \"_NET_WM_WINDOW_TYPE_UTILITY\" : \"utility\" , \"_NET_WM_WINDOW_TYPE_SPLASH\" : \"splash\" , \"_NET_WM_WINDOW_TYPE_DIALOG\" : \"dialog\" , \"_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\" : \"dropdown\" , \"_NET_WM_WINDOW_TYPE_POPUP_MENU\" : \"menu\" , \"_NET_WM_WINDOW_TYPE_TOOLTIP\" : \"tooltip\" , \"_NET_WM_WINDOW_TYPE_NOTIFICATION\" : \"notification\" , \"_NET_WM_WINDOW_TYPE_COMBO\" : \"combo\" , \"_NET_WM_WINDOW_TYPE_DND\" : \"dnd\" , \"_NET_WM_WINDOW_TYPE_NORMAL\" : \"normal\" , } atoms = {} for atom , name in xwayland_wm_types . items (): atoms [ xwayland . get_atom ( atom )] = name return atoms translate_masks ( modifiers ) Translate a modifier mask specified as a list of strings into an or-ed bit representation. Source code in libqtile/backend/wayland/wlrq.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def translate_masks ( modifiers : list [ str ]) -> int : \"\"\" Translate a modifier mask specified as a list of strings into an or-ed bit representation. \"\"\" masks = [] for i in modifiers : try : masks . append ( ModMasks [ i . lower ()]) except KeyError as e : raise WlrQError ( \"Unknown modifier: %s \" % i ) from e if masks : return functools . reduce ( operator . or_ , masks ) else : return 0","title":"wlrq"},{"location":"reference/libqtile/backend/wayland/wlrq/#libqtile.backend.wayland.wlrq.CursorState","text":"The surface and hotspot state of the cursor. This is tracked directly by the core so that the cursor can be hidden and later restored to this state at will.","title":"CursorState"},{"location":"reference/libqtile/backend/wayland/wlrq/#libqtile.backend.wayland.wlrq.Dnd","text":"Bases: HasListeners A helper for drag and drop functionality. Source code in libqtile/backend/wayland/wlrq.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def __init__ ( self , core : Core , wlr_drag : data_device_manager . Drag ): self . core = core self . wlr_drag = wlr_drag self . _outputs : set [ Output ] = set () self . x : float = core . cursor . x self . y : float = core . cursor . y self . width : int = 0 # Set upon surface commit self . height : int = 0 self . add_listener ( wlr_drag . destroy_event , self . _on_destroy ) self . icon = icon = wlr_drag . icon if icon is not None : self . add_listener ( icon . map_event , self . _on_icon_map ) self . add_listener ( icon . unmap_event , self . _on_icon_unmap ) self . add_listener ( icon . destroy_event , self . _on_icon_destroy ) self . add_listener ( icon . surface . commit_event , self . _on_icon_commit )","title":"Dnd"},{"location":"reference/libqtile/backend/wayland/wlrq/#libqtile.backend.wayland.wlrq.HasListeners","text":"Classes can subclass this to get some convenience handlers around pywayland.server.Listener . This guarantees that all listeners that set up and then removed in reverse order.","title":"HasListeners"},{"location":"reference/libqtile/backend/wayland/wlrq/#libqtile.backend.wayland.wlrq.get_xwayland_atoms","text":"These can be used when matching on XWayland clients with wm_type. http://standards.freedesktop.org/wm-spec/latest/ar01s05.html#idm139870830002400 Source code in libqtile/backend/wayland/wlrq.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def get_xwayland_atoms ( xwayland : xwayland . XWayland ) -> dict [ int , str ]: \"\"\" These can be used when matching on XWayland clients with wm_type. http://standards.freedesktop.org/wm-spec/latest/ar01s05.html#idm139870830002400 \"\"\" xwayland_wm_types = { \"_NET_WM_WINDOW_TYPE_DESKTOP\" : \"desktop\" , \"_NET_WM_WINDOW_TYPE_DOCK\" : \"dock\" , \"_NET_WM_WINDOW_TYPE_TOOLBAR\" : \"toolbar\" , \"_NET_WM_WINDOW_TYPE_MENU\" : \"menu\" , \"_NET_WM_WINDOW_TYPE_UTILITY\" : \"utility\" , \"_NET_WM_WINDOW_TYPE_SPLASH\" : \"splash\" , \"_NET_WM_WINDOW_TYPE_DIALOG\" : \"dialog\" , \"_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\" : \"dropdown\" , \"_NET_WM_WINDOW_TYPE_POPUP_MENU\" : \"menu\" , \"_NET_WM_WINDOW_TYPE_TOOLTIP\" : \"tooltip\" , \"_NET_WM_WINDOW_TYPE_NOTIFICATION\" : \"notification\" , \"_NET_WM_WINDOW_TYPE_COMBO\" : \"combo\" , \"_NET_WM_WINDOW_TYPE_DND\" : \"dnd\" , \"_NET_WM_WINDOW_TYPE_NORMAL\" : \"normal\" , } atoms = {} for atom , name in xwayland_wm_types . items (): atoms [ xwayland . get_atom ( atom )] = name return atoms","title":"get_xwayland_atoms()"},{"location":"reference/libqtile/backend/wayland/wlrq/#libqtile.backend.wayland.wlrq.translate_masks","text":"Translate a modifier mask specified as a list of strings into an or-ed bit representation. Source code in libqtile/backend/wayland/wlrq.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def translate_masks ( modifiers : list [ str ]) -> int : \"\"\" Translate a modifier mask specified as a list of strings into an or-ed bit representation. \"\"\" masks = [] for i in modifiers : try : masks . append ( ModMasks [ i . lower ()]) except KeyError as e : raise WlrQError ( \"Unknown modifier: %s \" % i ) from e if masks : return functools . reduce ( operator . or_ , masks ) else : return 0","title":"translate_masks()"},{"location":"reference/libqtile/backend/wayland/xdgwindow/","text":"XdgPopupWindow ( parent , xdg_popup ) Bases: HasListeners This represents a single struct wlr_xdg_popup object and is owned by a single parent window (of WindowType | XdgPopupWindow ). wlroots does most of the work for us, but we need to listen to certain events so that we know when to render frames and we need to unconstrain the popups so they are completely visible. Source code in libqtile/backend/wayland/xdgwindow.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def __init__ ( self , parent : XdgWindow | XdgPopupWindow , xdg_popup : XdgPopup ): self . parent = parent self . xdg_popup = xdg_popup self . core : Core = parent . core self . popups : list [ XdgPopupWindow ] = [] # Keep on output if isinstance ( parent , XdgPopupWindow ): # This is a nested XdgPopup self . output : Output = parent . output self . output_box : Box = parent . output_box else : # Parent is an XdgSurface; This is a first-level XdgPopup box = xdg_popup . base . get_geometry () lx , ly = self . core . output_layout . closest_point ( parent . x + box . x , parent . y + box . y ) wlr_output = self . core . output_layout . output_at ( lx , ly ) if wlr_output and wlr_output . data : output = wlr_output . data else : logger . warning ( \"Failed to find output at for xdg_popup. Please report.\" ) output = self . core . outputs [ 0 ] self . output = output box = Box ( * output . get_geometry ()) box . x = round ( box . x - lx ) box . y = round ( box . y - ly ) self . output_box = box xdg_popup . unconstrain_from_box ( self . output_box ) self . add_listener ( xdg_popup . base . map_event , self . _on_map ) self . add_listener ( xdg_popup . base . unmap_event , self . _on_unmap ) self . add_listener ( xdg_popup . base . destroy_event , self . _on_destroy ) self . add_listener ( xdg_popup . base . new_popup_event , self . _on_new_popup ) self . add_listener ( xdg_popup . base . surface . commit_event , self . _on_commit ) XdgStatic ( core , qtile , surface , wid , idle_inhibitor_count ) Bases: Static [ XdgSurface ] A static window belonging to the XDG shell. Source code in libqtile/backend/wayland/xdgwindow.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def __init__ ( self , core : Core , qtile : Qtile , surface : XdgSurface , wid : int , idle_inhibitor_count : int , ): Static . __init__ ( self , core , qtile , surface , wid , idle_inhibitor_count = idle_inhibitor_count ) self . subsurfaces : list [ SubSurface ] = [] self . _find_outputs () if surface . toplevel . title : self . name = surface . toplevel . title self . _wm_class = surface . toplevel . app_id self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . add_listener ( surface . toplevel . set_title_event , self . _on_set_title ) self . add_listener ( surface . toplevel . set_app_id_event , self . _on_set_app_id ) XdgWindow ( core , qtile , surface ) Bases: Window [ XdgSurface ] An Wayland client connecting via the xdg shell. Source code in libqtile/backend/wayland/xdgwindow.py 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , core : Core , qtile : Qtile , surface : XdgSurface ): Window . __init__ ( self , core , qtile , surface ) self . _wm_class = surface . toplevel . app_id self . popups : list [ XdgPopupWindow ] = [] self . subsurfaces : list [ SubSurface ] = [] self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . new_popup_event , self . _on_new_popup ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . add_listener ( surface . surface . new_subsurface_event , self . _on_new_subsurface ) is_transient_for () What window is this window a transient window for? Source code in libqtile/backend/wayland/xdgwindow.py 186 187 188 189 190 191 192 193 def is_transient_for ( self ) -> base . WindowType | None : \"\"\"What window is this window a transient window for?\"\"\" parent = self . surface . toplevel . parent if parent : for win in self . qtile . windows_map . values (): if isinstance ( win , XdgWindow ) and win . surface == parent : return win return None","title":"xdgwindow"},{"location":"reference/libqtile/backend/wayland/xdgwindow/#libqtile.backend.wayland.xdgwindow.XdgPopupWindow","text":"Bases: HasListeners This represents a single struct wlr_xdg_popup object and is owned by a single parent window (of WindowType | XdgPopupWindow ). wlroots does most of the work for us, but we need to listen to certain events so that we know when to render frames and we need to unconstrain the popups so they are completely visible. Source code in libqtile/backend/wayland/xdgwindow.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def __init__ ( self , parent : XdgWindow | XdgPopupWindow , xdg_popup : XdgPopup ): self . parent = parent self . xdg_popup = xdg_popup self . core : Core = parent . core self . popups : list [ XdgPopupWindow ] = [] # Keep on output if isinstance ( parent , XdgPopupWindow ): # This is a nested XdgPopup self . output : Output = parent . output self . output_box : Box = parent . output_box else : # Parent is an XdgSurface; This is a first-level XdgPopup box = xdg_popup . base . get_geometry () lx , ly = self . core . output_layout . closest_point ( parent . x + box . x , parent . y + box . y ) wlr_output = self . core . output_layout . output_at ( lx , ly ) if wlr_output and wlr_output . data : output = wlr_output . data else : logger . warning ( \"Failed to find output at for xdg_popup. Please report.\" ) output = self . core . outputs [ 0 ] self . output = output box = Box ( * output . get_geometry ()) box . x = round ( box . x - lx ) box . y = round ( box . y - ly ) self . output_box = box xdg_popup . unconstrain_from_box ( self . output_box ) self . add_listener ( xdg_popup . base . map_event , self . _on_map ) self . add_listener ( xdg_popup . base . unmap_event , self . _on_unmap ) self . add_listener ( xdg_popup . base . destroy_event , self . _on_destroy ) self . add_listener ( xdg_popup . base . new_popup_event , self . _on_new_popup ) self . add_listener ( xdg_popup . base . surface . commit_event , self . _on_commit )","title":"XdgPopupWindow"},{"location":"reference/libqtile/backend/wayland/xdgwindow/#libqtile.backend.wayland.xdgwindow.XdgStatic","text":"Bases: Static [ XdgSurface ] A static window belonging to the XDG shell. Source code in libqtile/backend/wayland/xdgwindow.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def __init__ ( self , core : Core , qtile : Qtile , surface : XdgSurface , wid : int , idle_inhibitor_count : int , ): Static . __init__ ( self , core , qtile , surface , wid , idle_inhibitor_count = idle_inhibitor_count ) self . subsurfaces : list [ SubSurface ] = [] self . _find_outputs () if surface . toplevel . title : self . name = surface . toplevel . title self . _wm_class = surface . toplevel . app_id self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . add_listener ( surface . toplevel . set_title_event , self . _on_set_title ) self . add_listener ( surface . toplevel . set_app_id_event , self . _on_set_app_id )","title":"XdgStatic"},{"location":"reference/libqtile/backend/wayland/xdgwindow/#libqtile.backend.wayland.xdgwindow.XdgWindow","text":"Bases: Window [ XdgSurface ] An Wayland client connecting via the xdg shell. Source code in libqtile/backend/wayland/xdgwindow.py 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , core : Core , qtile : Qtile , surface : XdgSurface ): Window . __init__ ( self , core , qtile , surface ) self . _wm_class = surface . toplevel . app_id self . popups : list [ XdgPopupWindow ] = [] self . subsurfaces : list [ SubSurface ] = [] self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . new_popup_event , self . _on_new_popup ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . add_listener ( surface . surface . new_subsurface_event , self . _on_new_subsurface )","title":"XdgWindow"},{"location":"reference/libqtile/backend/wayland/xdgwindow/#libqtile.backend.wayland.xdgwindow.XdgWindow.is_transient_for","text":"What window is this window a transient window for? Source code in libqtile/backend/wayland/xdgwindow.py 186 187 188 189 190 191 192 193 def is_transient_for ( self ) -> base . WindowType | None : \"\"\"What window is this window a transient window for?\"\"\" parent = self . surface . toplevel . parent if parent : for win in self . qtile . windows_map . values (): if isinstance ( win , XdgWindow ) and win . surface == parent : return win return None","title":"is_transient_for()"},{"location":"reference/libqtile/backend/wayland/xwindow/","text":"XStatic ( core , qtile , surface , wid , idle_inhibitor_count ) Bases: Static [ xwayland . Surface ] A static window belonging to the XWayland shell. Source code in libqtile/backend/wayland/xwindow.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def __init__ ( self , core : Core , qtile : Qtile , surface : xwayland . Surface , wid : int , idle_inhibitor_count : int , ): Static . __init__ ( self , core , qtile , surface , wid , idle_inhibitor_count = idle_inhibitor_count ) self . _wm_class = surface . wm_class self . _find_outputs () self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . add_listener ( surface . set_title_event , self . _on_set_title ) self . add_listener ( surface . set_class_event , self . _on_set_class ) # Checks to see if the user manually created the XStatic surface. # In which case override_redirect would be false. if surface . override_redirect : self . add_listener ( surface . set_geometry_event , self . _on_set_geometry ) XWindow ( core , qtile , surface ) Bases: Window [ xwayland . Surface ] An X11 client connecting via XWayland. Source code in libqtile/backend/wayland/xwindow.py 46 47 48 49 50 51 52 53 54 def __init__ ( self , core : Core , qtile : Qtile , surface : xwayland . Surface ): Window . __init__ ( self , core , qtile , surface ) self . _wm_class = self . surface . wm_class self . _unmapping : bool = False # Whether the client or Qtile unmapped this self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) is_transient_for () What window is this window a transient window for? Source code in libqtile/backend/wayland/xwindow.py 182 183 184 185 186 187 188 189 def is_transient_for ( self ) -> base . WindowType | None : \"\"\"What window is this window a transient window for?\"\"\" parent = self . surface . parent if parent : for win in self . qtile . windows_map . values (): if isinstance ( win , XWindow ) and win . surface == parent : return win return None","title":"xwindow"},{"location":"reference/libqtile/backend/wayland/xwindow/#libqtile.backend.wayland.xwindow.XStatic","text":"Bases: Static [ xwayland . Surface ] A static window belonging to the XWayland shell. Source code in libqtile/backend/wayland/xwindow.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def __init__ ( self , core : Core , qtile : Qtile , surface : xwayland . Surface , wid : int , idle_inhibitor_count : int , ): Static . __init__ ( self , core , qtile , surface , wid , idle_inhibitor_count = idle_inhibitor_count ) self . _wm_class = surface . wm_class self . _find_outputs () self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy ) self . add_listener ( surface . surface . commit_event , self . _on_commit ) self . add_listener ( surface . set_title_event , self . _on_set_title ) self . add_listener ( surface . set_class_event , self . _on_set_class ) # Checks to see if the user manually created the XStatic surface. # In which case override_redirect would be false. if surface . override_redirect : self . add_listener ( surface . set_geometry_event , self . _on_set_geometry )","title":"XStatic"},{"location":"reference/libqtile/backend/wayland/xwindow/#libqtile.backend.wayland.xwindow.XWindow","text":"Bases: Window [ xwayland . Surface ] An X11 client connecting via XWayland. Source code in libqtile/backend/wayland/xwindow.py 46 47 48 49 50 51 52 53 54 def __init__ ( self , core : Core , qtile : Qtile , surface : xwayland . Surface ): Window . __init__ ( self , core , qtile , surface ) self . _wm_class = self . surface . wm_class self . _unmapping : bool = False # Whether the client or Qtile unmapped this self . add_listener ( surface . map_event , self . _on_map ) self . add_listener ( surface . unmap_event , self . _on_unmap ) self . add_listener ( surface . destroy_event , self . _on_destroy )","title":"XWindow"},{"location":"reference/libqtile/backend/wayland/xwindow/#libqtile.backend.wayland.xwindow.XWindow.is_transient_for","text":"What window is this window a transient window for? Source code in libqtile/backend/wayland/xwindow.py 182 183 184 185 186 187 188 189 def is_transient_for ( self ) -> base . WindowType | None : \"\"\"What window is this window a transient window for?\"\"\" parent = self . surface . parent if parent : for win in self . qtile . windows_map . values (): if isinstance ( win , XWindow ) and win . surface == parent : return win return None","title":"is_transient_for()"},{"location":"reference/libqtile/backend/x11/","text":"","title":"x11"},{"location":"reference/libqtile/backend/x11/core/","text":"Core ( display_name = None ) Bases: base . Core :param display_name: The display name to setup the X11 connection to. Uses the DISPLAY environment variable if not given. Source code in libqtile/backend/x11/core.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def __init__ ( self , display_name : str | None = None ) -> None : \"\"\"Setup the X11 core backend :param display_name: The display name to setup the X11 connection to. Uses the DISPLAY environment variable if not given. \"\"\" if display_name is None : display_name = os . environ . get ( \"DISPLAY\" ) if not display_name : raise QtileError ( \"No DISPLAY set\" ) self . conn = xcbq . Connection ( display_name ) self . _display_name = display_name # Because we only do Xinerama multi-screening, # we can assume that the first # screen's root is _the_ root. self . _root = self . conn . default_screen . root supporting_wm_wid = self . _root . get_property ( \"_NET_SUPPORTING_WM_CHECK\" , \"WINDOW\" , unpack = int ) if len ( supporting_wm_wid ) > 0 : supporting_wm_wid = supporting_wm_wid [ 0 ] supporting_wm = window . XWindow ( self . conn , supporting_wm_wid ) existing_wmname = supporting_wm . get_property ( \"_NET_WM_NAME\" , \"UTF8_STRING\" , unpack = str ) if existing_wmname : logger . error ( \"not starting; existing window manager %s \" , existing_wmname ) raise ExistingWMException ( existing_wmname ) self . eventmask = ( EventMask . StructureNotify | EventMask . SubstructureNotify | EventMask . SubstructureRedirect | EventMask . EnterWindow | EventMask . LeaveWindow | EventMask . ButtonPress ) self . _root . set_attribute ( eventmask = self . eventmask ) self . _root . set_property ( \"_NET_SUPPORTED\" , [ self . conn . atoms [ x ] for x in xcbq . SUPPORTED_ATOMS ] ) self . _wmname = \"qtile\" self . _supporting_wm_check_window = self . conn . create_window ( - 1 , - 1 , 1 , 1 ) self . _supporting_wm_check_window . set_property ( \"_NET_WM_NAME\" , self . _wmname ) self . _supporting_wm_check_window . set_property ( \"_NET_SUPPORTING_WM_CHECK\" , self . _supporting_wm_check_window . wid ) self . _root . set_property ( \"_NET_SUPPORTING_WM_CHECK\" , self . _supporting_wm_check_window . wid ) self . _selection = { \"PRIMARY\" : { \"owner\" : None , \"selection\" : \"\" }, \"CLIPBOARD\" : { \"owner\" : None , \"selection\" : \"\" }, } self . _selection_window = self . conn . create_window ( - 1 , - 1 , 1 , 1 ) self . _selection_window . set_attribute ( eventmask = EventMask . PropertyChange ) if hasattr ( self . conn , \"xfixes\" ): self . conn . xfixes . select_selection_input ( self . _selection_window , \"PRIMARY\" ) # type: ignore self . conn . xfixes . select_selection_input ( self . _selection_window , \"CLIPBOARD\" ) # type: ignore primary_atom = self . conn . atoms [ \"PRIMARY\" ] reply = self . conn . conn . core . GetSelectionOwner ( primary_atom ) . reply () self . _selection [ \"PRIMARY\" ][ \"owner\" ] = reply . owner clipboard_atom = self . conn . atoms [ \"CLIPBOARD\" ] reply = self . conn . conn . core . GetSelectionOwner ( primary_atom ) . reply () self . _selection [ \"CLIPBOARD\" ][ \"owner\" ] = reply . owner # ask for selection on start-up self . convert_selection ( primary_atom ) self . convert_selection ( clipboard_atom ) # setup the default cursor self . _root . set_cursor ( \"left_ptr\" ) self . qtile = None # type: Qtile | None self . _painter = None numlock_code = self . conn . keysym_to_keycode ( xcbq . keysyms [ \"num_lock\" ])[ 0 ] self . _numlock_mask = xcbq . ModMasks . get ( self . conn . get_modifier ( numlock_code ), 0 ) self . _valid_mask = ~ ( self . _numlock_mask | xcbq . ModMasks [ \"lock\" ] | xcbq . AllButtonsMask | xcbq . PointerMotionHintMask ) display_name () property The name of the connected display Source code in libqtile/backend/x11/core.py 415 416 417 418 @property def display_name ( self ) -> str : \"\"\"The name of the connected display\"\"\" return self . _display_name focus_by_click ( e , window = None ) Bring a window to the front Parameters e: xcb event Click event used to determine window to focus Source code in libqtile/backend/x11/core.py 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 def focus_by_click ( self , e , window = None ): \"\"\"Bring a window to the front Parameters ========== e: xcb event Click event used to determine window to focus \"\"\" qtile = self . qtile assert qtile is not None if window : if qtile . config . bring_front_click and ( qtile . config . bring_front_click != \"floating_only\" or getattr ( window , \"floating\" , False ) ): self . conn . conn . core . ConfigureWindow ( window . wid , xcffib . xproto . ConfigWindow . StackMode , [ StackMode . Above ] ) try : if window . group . screen is not qtile . current_screen : qtile . focus_screen ( window . group . screen . index , warp = False ) qtile . current_group . focus ( window , False ) window . focus ( False ) except AttributeError : # probably clicked an internal window screen = qtile . find_screen ( e . root_x , e . root_y ) if screen : qtile . focus_screen ( screen . index , warp = False ) else : # clicked on root window screen = qtile . find_screen ( e . root_x , e . root_y ) if screen : qtile . focus_screen ( screen . index , warp = False ) get_mouse_position () Get mouse coordinates. Source code in libqtile/backend/x11/core.py 845 846 847 848 849 850 def get_mouse_position ( self ) -> tuple [ int , int ]: \"\"\" Get mouse coordinates. \"\"\" reply = self . conn . conn . core . QueryPointer ( self . _root . wid ) . reply () return reply . root_x , reply . root_y get_valid_timestamp () Get a valid timestamp, i.e. not CurrentTime, for X server. It may be used in cases where CurrentTime is unacceptable for X server. Source code in libqtile/backend/x11/core.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def get_valid_timestamp ( self ): \"\"\"Get a valid timestamp, i.e. not CurrentTime, for X server. It may be used in cases where CurrentTime is unacceptable for X server.\"\"\" # do a zero length append to get the time offset as suggested by ICCCM # https://tronche.com/gui/x/icccm/sec-2.html#s-2.1 # we do this on a separate connection since we can't receive events # without returning control to the event loop, which we can't do # because the event loop (via some window event) wants to know the # current time. conn = None try : conn = xcbq . Connection ( self . _display_name ) conn . default_screen . root . set_attribute ( eventmask = EventMask . PropertyChange ) conn . conn . core . ChangePropertyChecked ( xcffib . xproto . PropMode . Append , self . _root . wid , self . conn . atoms [ \"WM_CLASS\" ], self . conn . atoms [ \"STRING\" ], 8 , 0 , \"\" , ) . check () while True : event = conn . conn . wait_for_event () if event . __class__ != xcffib . xproto . PropertyNotifyEvent : continue return event . time finally : if conn is not None : conn . finalize () grab_button ( mouse ) Grab the given mouse button for events Source code in libqtile/backend/x11/core.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def grab_button ( self , mouse : config . Mouse ) -> int : \"\"\"Grab the given mouse button for events\"\"\" modmask = xcbq . translate_masks ( mouse . modifiers ) eventmask = EventMask . ButtonPress if isinstance ( mouse , config . Drag ): eventmask |= EventMask . ButtonRelease for amask in self . _auto_modmasks (): self . conn . conn . core . GrabButton ( True , self . _root . wid , eventmask , xcffib . xproto . GrabMode . Async , xcffib . xproto . GrabMode . Async , xcffib . xproto . Atom . _None , xcffib . xproto . Atom . _None , mouse . button_code , modmask | amask , ) return modmask & self . _valid_mask grab_key ( key ) Map the key to receive events on it Source code in libqtile/backend/x11/core.py 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 def grab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Map the key to receive events on it\"\"\" keysym , modmask = self . lookup_key ( key ) codes = self . conn . keysym_to_keycode ( keysym ) for code in codes : if code == 0 : logger . warning ( \"Can't grab %s (unknown keysym: %02x )\" , key , keysym ) continue for amask in self . _auto_modmasks (): self . conn . conn . core . GrabKey ( True , self . _root . wid , modmask | amask , code , xcffib . xproto . GrabMode . Async , xcffib . xproto . GrabMode . Async , ) return keysym , modmask & self . _valid_mask grab_pointer () Get the focus for pointer events Source code in libqtile/backend/x11/core.py 493 494 495 496 497 498 499 500 501 502 503 504 def grab_pointer ( self ) -> None : \"\"\"Get the focus for pointer events\"\"\" self . conn . conn . core . GrabPointer ( True , self . _root . wid , xcbq . ButtonMotionMask | xcbq . AllButtonsMask | xcbq . ButtonReleaseMask , xcffib . xproto . GrabMode . Async , xcffib . xproto . GrabMode . Async , xcffib . xproto . Atom . _None , xcffib . xproto . Atom . _None , xcffib . xproto . Atom . _None , ) graceful_shutdown () Try to close windows gracefully before exiting Source code in libqtile/backend/x11/core.py 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 def graceful_shutdown ( self ): \"\"\"Try to close windows gracefully before exiting\"\"\" def get_interesting_pid ( win ): # We don't need to kill Internal or Static windows, they're qtile # managed and don't have any state. if not isinstance ( win , base . Window ): return None try : return win . window . get_net_wm_pid () except Exception : logger . exception ( \"Got an exception in getting the window pid\" ) return None pids = map ( get_interesting_pid , self . qtile . windows_map . values ()) pids = list ( filter ( lambda x : x is not None , pids )) # Give the windows a chance to shut down nicely. for pid in pids : try : os . kill ( pid , signal . SIGTERM ) except OSError : # might have died recently pass def still_alive ( pid ): # most pids will not be children, so we can't use wait() try : os . kill ( pid , 0 ) return True except OSError : return False # give everyone a little time to exit and write their state. but don't # sleep forever (1s). for i in range ( 10 ): pids = list ( filter ( still_alive , pids )) if len ( pids ) == 0 : break time . sleep ( 0.1 ) keysym_from_name ( name ) Get the keysym for a key from its name Source code in libqtile/backend/x11/core.py 852 853 854 def keysym_from_name ( self , name : str ) -> int : \"\"\"Get the keysym for a key from its name\"\"\" return keysyms [ name . lower ()] lookup_key ( key ) Find the keysym and the modifier mask for the given key Source code in libqtile/backend/x11/core.py 446 447 448 449 450 451 452 453 454 def lookup_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Find the keysym and the modifier mask for the given key\"\"\" try : keysym = xcbq . get_keysym ( key . key ) modmask = xcbq . translate_masks ( key . modifiers ) except xcbq . XCBQError as err : raise utils . QtileError ( err ) return keysym , modmask on_config_load ( initial ) Assign windows to groups Source code in libqtile/backend/x11/core.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def on_config_load ( self , initial ) -> None : \"\"\"Assign windows to groups\"\"\" assert self . qtile is not None if not initial : # We are just reloading config for win in self . qtile . windows_map . values (): if type ( win ) is window . Window : win . set_group () return # Qtile just started - scan for clients _ , _ , children = self . _root . query_tree () for item in children : try : attrs = item . get_attributes () state = item . get_wm_state () internal = item . get_property ( \"QTILE_INTERNAL\" ) except ( xcffib . xproto . WindowError , xcffib . xproto . AccessError ): continue if ( attrs and attrs . map_state == xcffib . xproto . MapState . Unmapped or attrs . override_redirect ): continue if state and state [ 0 ] == window . WithdrawnState : item . unmap () continue if item . wid in self . qtile . windows_map : win = self . qtile . windows_map [ item . wid ] win . unhide () return if internal : win = window . Internal ( item , self . qtile ) else : win = window . Window ( item , self . qtile ) if item . get_wm_type () == \"dock\" or win . reserved_space : assert self . qtile . current_screen is not None win . static ( self . qtile . current_screen . index ) continue self . qtile . manage ( win ) remove_listener () Remove the listener from the given event loop Source code in libqtile/backend/x11/core.py 217 218 219 220 221 222 223 def remove_listener ( self ) -> None : \"\"\"Remove the listener from the given event loop\"\"\" if self . fd is not None : logger . debug ( \"Removing io watch\" ) loop = asyncio . get_running_loop () loop . remove_reader ( self . fd ) self . fd = None setup_listener ( qtile ) Setup a listener for the given qtile instance :param qtile: The qtile instance to dispatch events to. :param eventloop: The eventloop to use to listen to the file descriptor. Source code in libqtile/backend/x11/core.py 204 205 206 207 208 209 210 211 212 213 214 215 def setup_listener ( self , qtile : \"Qtile\" ) -> None : \"\"\"Setup a listener for the given qtile instance :param qtile: The qtile instance to dispatch events to. :param eventloop: The eventloop to use to listen to the file descriptor. \"\"\" logger . debug ( \"Adding io watch\" ) self . qtile = qtile self . fd = self . conn . conn . get_file_descriptor () asyncio . get_running_loop () . add_reader ( self . fd , self . _xpoll ) simulate_keypress ( modifiers , key ) Simulates a keypress on the focused window. Source code in libqtile/backend/x11/core.py 750 751 752 753 754 755 756 757 758 759 760 761 762 def simulate_keypress ( self , modifiers , key ): \"\"\"Simulates a keypress on the focused window.\"\"\" # FIXME: This needs to be done with sendevent, once we have that fixed. modmasks = xcbq . translate_masks ( modifiers ) keysym = xcbq . keysyms . get ( key . lower ()) class DummyEv : pass d = DummyEv () d . detail = self . conn . keysym_to_keycode ( keysym )[ 0 ] d . state = modmasks self . handle_KeyPress ( d ) ungrab_buttons () Un-grab all mouse events Source code in libqtile/backend/x11/core.py 533 534 535 536 537 def ungrab_buttons ( self ) -> None : \"\"\"Un-grab all mouse events\"\"\" self . conn . conn . core . UngrabButton ( xcffib . xproto . Atom . Any , self . _root . wid , xcffib . xproto . ModMask . Any ) ungrab_key ( key ) Ungrab the key corresponding to the given keysym and modifier mask Source code in libqtile/backend/x11/core.py 476 477 478 479 480 481 482 483 484 485 def ungrab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Ungrab the key corresponding to the given keysym and modifier mask\"\"\" keysym , modmask = self . lookup_key ( key ) codes = self . conn . keysym_to_keycode ( keysym ) for code in codes : for amask in self . _auto_modmasks (): self . conn . conn . core . UngrabKey ( code , self . _root . wid , modmask | amask ) return keysym , modmask & self . _valid_mask ungrab_keys () Ungrab all of the key events Source code in libqtile/backend/x11/core.py 487 488 489 490 491 def ungrab_keys ( self ) -> None : \"\"\"Ungrab all of the key events\"\"\" self . conn . conn . core . UngrabKey ( xcffib . xproto . Atom . Any , self . _root . wid , xcffib . xproto . ModMask . Any ) ungrab_pointer () Ungrab the focus for pointer events Source code in libqtile/backend/x11/core.py 506 507 508 def ungrab_pointer ( self ) -> None : \"\"\"Ungrab the focus for pointer events\"\"\" self . conn . conn . core . UngrabPointer ( xcffib . xproto . Atom . _None ) update_client_list ( windows_map ) Updates the client stack list This is needed for third party tasklists and drag and drop of tabs in chrome Source code in libqtile/backend/x11/core.py 420 421 422 423 424 425 426 427 428 429 430 def update_client_list ( self , windows_map : dict [ int , base . WindowType ]) -> None : \"\"\"Updates the client stack list This is needed for third party tasklists and drag and drop of tabs in chrome \"\"\" # Regular top-level managed windows, i.e. excluding Static, Internal and Systray Icons wids = [ wid for wid , c in windows_map . items () if isinstance ( c , window . Window )] self . _root . set_property ( \"_NET_CLIENT_LIST\" , wids ) # TODO: check stack order self . _root . set_property ( \"_NET_CLIENT_LIST_STACKING\" , wids ) update_desktops ( groups , index ) Set the current desktops of the window manager The list of desktops is given by the list of groups, with the current desktop given by the index Source code in libqtile/backend/x11/core.py 432 433 434 435 436 437 438 439 440 441 442 443 444 def update_desktops ( self , groups , index : int ) -> None : \"\"\"Set the current desktops of the window manager The list of desktops is given by the list of groups, with the current desktop given by the index \"\"\" self . _root . set_property ( \"_NET_NUMBER_OF_DESKTOPS\" , len ( groups )) self . _root . set_property ( \"_NET_DESKTOP_NAMES\" , \" \\0 \" . join ( i . name for i in groups )) self . _root . set_property ( \"_NET_CURRENT_DESKTOP\" , index ) viewport = [] for group in groups : viewport += [ group . screen . x , group . screen . y ] if group . screen else [ 0 , 0 ] self . _root . set_property ( \"_NET_DESKTOP_VIEWPORT\" , viewport )","title":"core"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core","text":"Bases: base . Core :param display_name: The display name to setup the X11 connection to. Uses the DISPLAY environment variable if not given. Source code in libqtile/backend/x11/core.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def __init__ ( self , display_name : str | None = None ) -> None : \"\"\"Setup the X11 core backend :param display_name: The display name to setup the X11 connection to. Uses the DISPLAY environment variable if not given. \"\"\" if display_name is None : display_name = os . environ . get ( \"DISPLAY\" ) if not display_name : raise QtileError ( \"No DISPLAY set\" ) self . conn = xcbq . Connection ( display_name ) self . _display_name = display_name # Because we only do Xinerama multi-screening, # we can assume that the first # screen's root is _the_ root. self . _root = self . conn . default_screen . root supporting_wm_wid = self . _root . get_property ( \"_NET_SUPPORTING_WM_CHECK\" , \"WINDOW\" , unpack = int ) if len ( supporting_wm_wid ) > 0 : supporting_wm_wid = supporting_wm_wid [ 0 ] supporting_wm = window . XWindow ( self . conn , supporting_wm_wid ) existing_wmname = supporting_wm . get_property ( \"_NET_WM_NAME\" , \"UTF8_STRING\" , unpack = str ) if existing_wmname : logger . error ( \"not starting; existing window manager %s \" , existing_wmname ) raise ExistingWMException ( existing_wmname ) self . eventmask = ( EventMask . StructureNotify | EventMask . SubstructureNotify | EventMask . SubstructureRedirect | EventMask . EnterWindow | EventMask . LeaveWindow | EventMask . ButtonPress ) self . _root . set_attribute ( eventmask = self . eventmask ) self . _root . set_property ( \"_NET_SUPPORTED\" , [ self . conn . atoms [ x ] for x in xcbq . SUPPORTED_ATOMS ] ) self . _wmname = \"qtile\" self . _supporting_wm_check_window = self . conn . create_window ( - 1 , - 1 , 1 , 1 ) self . _supporting_wm_check_window . set_property ( \"_NET_WM_NAME\" , self . _wmname ) self . _supporting_wm_check_window . set_property ( \"_NET_SUPPORTING_WM_CHECK\" , self . _supporting_wm_check_window . wid ) self . _root . set_property ( \"_NET_SUPPORTING_WM_CHECK\" , self . _supporting_wm_check_window . wid ) self . _selection = { \"PRIMARY\" : { \"owner\" : None , \"selection\" : \"\" }, \"CLIPBOARD\" : { \"owner\" : None , \"selection\" : \"\" }, } self . _selection_window = self . conn . create_window ( - 1 , - 1 , 1 , 1 ) self . _selection_window . set_attribute ( eventmask = EventMask . PropertyChange ) if hasattr ( self . conn , \"xfixes\" ): self . conn . xfixes . select_selection_input ( self . _selection_window , \"PRIMARY\" ) # type: ignore self . conn . xfixes . select_selection_input ( self . _selection_window , \"CLIPBOARD\" ) # type: ignore primary_atom = self . conn . atoms [ \"PRIMARY\" ] reply = self . conn . conn . core . GetSelectionOwner ( primary_atom ) . reply () self . _selection [ \"PRIMARY\" ][ \"owner\" ] = reply . owner clipboard_atom = self . conn . atoms [ \"CLIPBOARD\" ] reply = self . conn . conn . core . GetSelectionOwner ( primary_atom ) . reply () self . _selection [ \"CLIPBOARD\" ][ \"owner\" ] = reply . owner # ask for selection on start-up self . convert_selection ( primary_atom ) self . convert_selection ( clipboard_atom ) # setup the default cursor self . _root . set_cursor ( \"left_ptr\" ) self . qtile = None # type: Qtile | None self . _painter = None numlock_code = self . conn . keysym_to_keycode ( xcbq . keysyms [ \"num_lock\" ])[ 0 ] self . _numlock_mask = xcbq . ModMasks . get ( self . conn . get_modifier ( numlock_code ), 0 ) self . _valid_mask = ~ ( self . _numlock_mask | xcbq . ModMasks [ \"lock\" ] | xcbq . AllButtonsMask | xcbq . PointerMotionHintMask )","title":"Core"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.display_name","text":"The name of the connected display Source code in libqtile/backend/x11/core.py 415 416 417 418 @property def display_name ( self ) -> str : \"\"\"The name of the connected display\"\"\" return self . _display_name","title":"display_name()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.focus_by_click","text":"Bring a window to the front","title":"focus_by_click()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.focus_by_click--parameters","text":"e: xcb event Click event used to determine window to focus Source code in libqtile/backend/x11/core.py 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 def focus_by_click ( self , e , window = None ): \"\"\"Bring a window to the front Parameters ========== e: xcb event Click event used to determine window to focus \"\"\" qtile = self . qtile assert qtile is not None if window : if qtile . config . bring_front_click and ( qtile . config . bring_front_click != \"floating_only\" or getattr ( window , \"floating\" , False ) ): self . conn . conn . core . ConfigureWindow ( window . wid , xcffib . xproto . ConfigWindow . StackMode , [ StackMode . Above ] ) try : if window . group . screen is not qtile . current_screen : qtile . focus_screen ( window . group . screen . index , warp = False ) qtile . current_group . focus ( window , False ) window . focus ( False ) except AttributeError : # probably clicked an internal window screen = qtile . find_screen ( e . root_x , e . root_y ) if screen : qtile . focus_screen ( screen . index , warp = False ) else : # clicked on root window screen = qtile . find_screen ( e . root_x , e . root_y ) if screen : qtile . focus_screen ( screen . index , warp = False )","title":"Parameters"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.get_mouse_position","text":"Get mouse coordinates. Source code in libqtile/backend/x11/core.py 845 846 847 848 849 850 def get_mouse_position ( self ) -> tuple [ int , int ]: \"\"\" Get mouse coordinates. \"\"\" reply = self . conn . conn . core . QueryPointer ( self . _root . wid ) . reply () return reply . root_x , reply . root_y","title":"get_mouse_position()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.get_valid_timestamp","text":"Get a valid timestamp, i.e. not CurrentTime, for X server. It may be used in cases where CurrentTime is unacceptable for X server. Source code in libqtile/backend/x11/core.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def get_valid_timestamp ( self ): \"\"\"Get a valid timestamp, i.e. not CurrentTime, for X server. It may be used in cases where CurrentTime is unacceptable for X server.\"\"\" # do a zero length append to get the time offset as suggested by ICCCM # https://tronche.com/gui/x/icccm/sec-2.html#s-2.1 # we do this on a separate connection since we can't receive events # without returning control to the event loop, which we can't do # because the event loop (via some window event) wants to know the # current time. conn = None try : conn = xcbq . Connection ( self . _display_name ) conn . default_screen . root . set_attribute ( eventmask = EventMask . PropertyChange ) conn . conn . core . ChangePropertyChecked ( xcffib . xproto . PropMode . Append , self . _root . wid , self . conn . atoms [ \"WM_CLASS\" ], self . conn . atoms [ \"STRING\" ], 8 , 0 , \"\" , ) . check () while True : event = conn . conn . wait_for_event () if event . __class__ != xcffib . xproto . PropertyNotifyEvent : continue return event . time finally : if conn is not None : conn . finalize ()","title":"get_valid_timestamp()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.grab_button","text":"Grab the given mouse button for events Source code in libqtile/backend/x11/core.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 def grab_button ( self , mouse : config . Mouse ) -> int : \"\"\"Grab the given mouse button for events\"\"\" modmask = xcbq . translate_masks ( mouse . modifiers ) eventmask = EventMask . ButtonPress if isinstance ( mouse , config . Drag ): eventmask |= EventMask . ButtonRelease for amask in self . _auto_modmasks (): self . conn . conn . core . GrabButton ( True , self . _root . wid , eventmask , xcffib . xproto . GrabMode . Async , xcffib . xproto . GrabMode . Async , xcffib . xproto . Atom . _None , xcffib . xproto . Atom . _None , mouse . button_code , modmask | amask , ) return modmask & self . _valid_mask","title":"grab_button()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.grab_key","text":"Map the key to receive events on it Source code in libqtile/backend/x11/core.py 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 def grab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Map the key to receive events on it\"\"\" keysym , modmask = self . lookup_key ( key ) codes = self . conn . keysym_to_keycode ( keysym ) for code in codes : if code == 0 : logger . warning ( \"Can't grab %s (unknown keysym: %02x )\" , key , keysym ) continue for amask in self . _auto_modmasks (): self . conn . conn . core . GrabKey ( True , self . _root . wid , modmask | amask , code , xcffib . xproto . GrabMode . Async , xcffib . xproto . GrabMode . Async , ) return keysym , modmask & self . _valid_mask","title":"grab_key()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.grab_pointer","text":"Get the focus for pointer events Source code in libqtile/backend/x11/core.py 493 494 495 496 497 498 499 500 501 502 503 504 def grab_pointer ( self ) -> None : \"\"\"Get the focus for pointer events\"\"\" self . conn . conn . core . GrabPointer ( True , self . _root . wid , xcbq . ButtonMotionMask | xcbq . AllButtonsMask | xcbq . ButtonReleaseMask , xcffib . xproto . GrabMode . Async , xcffib . xproto . GrabMode . Async , xcffib . xproto . Atom . _None , xcffib . xproto . Atom . _None , xcffib . xproto . Atom . _None , )","title":"grab_pointer()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.graceful_shutdown","text":"Try to close windows gracefully before exiting Source code in libqtile/backend/x11/core.py 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 def graceful_shutdown ( self ): \"\"\"Try to close windows gracefully before exiting\"\"\" def get_interesting_pid ( win ): # We don't need to kill Internal or Static windows, they're qtile # managed and don't have any state. if not isinstance ( win , base . Window ): return None try : return win . window . get_net_wm_pid () except Exception : logger . exception ( \"Got an exception in getting the window pid\" ) return None pids = map ( get_interesting_pid , self . qtile . windows_map . values ()) pids = list ( filter ( lambda x : x is not None , pids )) # Give the windows a chance to shut down nicely. for pid in pids : try : os . kill ( pid , signal . SIGTERM ) except OSError : # might have died recently pass def still_alive ( pid ): # most pids will not be children, so we can't use wait() try : os . kill ( pid , 0 ) return True except OSError : return False # give everyone a little time to exit and write their state. but don't # sleep forever (1s). for i in range ( 10 ): pids = list ( filter ( still_alive , pids )) if len ( pids ) == 0 : break time . sleep ( 0.1 )","title":"graceful_shutdown()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.keysym_from_name","text":"Get the keysym for a key from its name Source code in libqtile/backend/x11/core.py 852 853 854 def keysym_from_name ( self , name : str ) -> int : \"\"\"Get the keysym for a key from its name\"\"\" return keysyms [ name . lower ()]","title":"keysym_from_name()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.lookup_key","text":"Find the keysym and the modifier mask for the given key Source code in libqtile/backend/x11/core.py 446 447 448 449 450 451 452 453 454 def lookup_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Find the keysym and the modifier mask for the given key\"\"\" try : keysym = xcbq . get_keysym ( key . key ) modmask = xcbq . translate_masks ( key . modifiers ) except xcbq . XCBQError as err : raise utils . QtileError ( err ) return keysym , modmask","title":"lookup_key()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.on_config_load","text":"Assign windows to groups Source code in libqtile/backend/x11/core.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def on_config_load ( self , initial ) -> None : \"\"\"Assign windows to groups\"\"\" assert self . qtile is not None if not initial : # We are just reloading config for win in self . qtile . windows_map . values (): if type ( win ) is window . Window : win . set_group () return # Qtile just started - scan for clients _ , _ , children = self . _root . query_tree () for item in children : try : attrs = item . get_attributes () state = item . get_wm_state () internal = item . get_property ( \"QTILE_INTERNAL\" ) except ( xcffib . xproto . WindowError , xcffib . xproto . AccessError ): continue if ( attrs and attrs . map_state == xcffib . xproto . MapState . Unmapped or attrs . override_redirect ): continue if state and state [ 0 ] == window . WithdrawnState : item . unmap () continue if item . wid in self . qtile . windows_map : win = self . qtile . windows_map [ item . wid ] win . unhide () return if internal : win = window . Internal ( item , self . qtile ) else : win = window . Window ( item , self . qtile ) if item . get_wm_type () == \"dock\" or win . reserved_space : assert self . qtile . current_screen is not None win . static ( self . qtile . current_screen . index ) continue self . qtile . manage ( win )","title":"on_config_load()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.remove_listener","text":"Remove the listener from the given event loop Source code in libqtile/backend/x11/core.py 217 218 219 220 221 222 223 def remove_listener ( self ) -> None : \"\"\"Remove the listener from the given event loop\"\"\" if self . fd is not None : logger . debug ( \"Removing io watch\" ) loop = asyncio . get_running_loop () loop . remove_reader ( self . fd ) self . fd = None","title":"remove_listener()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.setup_listener","text":"Setup a listener for the given qtile instance :param qtile: The qtile instance to dispatch events to. :param eventloop: The eventloop to use to listen to the file descriptor. Source code in libqtile/backend/x11/core.py 204 205 206 207 208 209 210 211 212 213 214 215 def setup_listener ( self , qtile : \"Qtile\" ) -> None : \"\"\"Setup a listener for the given qtile instance :param qtile: The qtile instance to dispatch events to. :param eventloop: The eventloop to use to listen to the file descriptor. \"\"\" logger . debug ( \"Adding io watch\" ) self . qtile = qtile self . fd = self . conn . conn . get_file_descriptor () asyncio . get_running_loop () . add_reader ( self . fd , self . _xpoll )","title":"setup_listener()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.simulate_keypress","text":"Simulates a keypress on the focused window. Source code in libqtile/backend/x11/core.py 750 751 752 753 754 755 756 757 758 759 760 761 762 def simulate_keypress ( self , modifiers , key ): \"\"\"Simulates a keypress on the focused window.\"\"\" # FIXME: This needs to be done with sendevent, once we have that fixed. modmasks = xcbq . translate_masks ( modifiers ) keysym = xcbq . keysyms . get ( key . lower ()) class DummyEv : pass d = DummyEv () d . detail = self . conn . keysym_to_keycode ( keysym )[ 0 ] d . state = modmasks self . handle_KeyPress ( d )","title":"simulate_keypress()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.ungrab_buttons","text":"Un-grab all mouse events Source code in libqtile/backend/x11/core.py 533 534 535 536 537 def ungrab_buttons ( self ) -> None : \"\"\"Un-grab all mouse events\"\"\" self . conn . conn . core . UngrabButton ( xcffib . xproto . Atom . Any , self . _root . wid , xcffib . xproto . ModMask . Any )","title":"ungrab_buttons()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.ungrab_key","text":"Ungrab the key corresponding to the given keysym and modifier mask Source code in libqtile/backend/x11/core.py 476 477 478 479 480 481 482 483 484 485 def ungrab_key ( self , key : config . Key | config . KeyChord ) -> tuple [ int , int ]: \"\"\"Ungrab the key corresponding to the given keysym and modifier mask\"\"\" keysym , modmask = self . lookup_key ( key ) codes = self . conn . keysym_to_keycode ( keysym ) for code in codes : for amask in self . _auto_modmasks (): self . conn . conn . core . UngrabKey ( code , self . _root . wid , modmask | amask ) return keysym , modmask & self . _valid_mask","title":"ungrab_key()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.ungrab_keys","text":"Ungrab all of the key events Source code in libqtile/backend/x11/core.py 487 488 489 490 491 def ungrab_keys ( self ) -> None : \"\"\"Ungrab all of the key events\"\"\" self . conn . conn . core . UngrabKey ( xcffib . xproto . Atom . Any , self . _root . wid , xcffib . xproto . ModMask . Any )","title":"ungrab_keys()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.ungrab_pointer","text":"Ungrab the focus for pointer events Source code in libqtile/backend/x11/core.py 506 507 508 def ungrab_pointer ( self ) -> None : \"\"\"Ungrab the focus for pointer events\"\"\" self . conn . conn . core . UngrabPointer ( xcffib . xproto . Atom . _None )","title":"ungrab_pointer()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.update_client_list","text":"Updates the client stack list This is needed for third party tasklists and drag and drop of tabs in chrome Source code in libqtile/backend/x11/core.py 420 421 422 423 424 425 426 427 428 429 430 def update_client_list ( self , windows_map : dict [ int , base . WindowType ]) -> None : \"\"\"Updates the client stack list This is needed for third party tasklists and drag and drop of tabs in chrome \"\"\" # Regular top-level managed windows, i.e. excluding Static, Internal and Systray Icons wids = [ wid for wid , c in windows_map . items () if isinstance ( c , window . Window )] self . _root . set_property ( \"_NET_CLIENT_LIST\" , wids ) # TODO: check stack order self . _root . set_property ( \"_NET_CLIENT_LIST_STACKING\" , wids )","title":"update_client_list()"},{"location":"reference/libqtile/backend/x11/core/#libqtile.backend.x11.core.Core.update_desktops","text":"Set the current desktops of the window manager The list of desktops is given by the list of groups, with the current desktop given by the index Source code in libqtile/backend/x11/core.py 432 433 434 435 436 437 438 439 440 441 442 443 444 def update_desktops ( self , groups , index : int ) -> None : \"\"\"Set the current desktops of the window manager The list of desktops is given by the list of groups, with the current desktop given by the index \"\"\" self . _root . set_property ( \"_NET_NUMBER_OF_DESKTOPS\" , len ( groups )) self . _root . set_property ( \"_NET_DESKTOP_NAMES\" , \" \\0 \" . join ( i . name for i in groups )) self . _root . set_property ( \"_NET_CURRENT_DESKTOP\" , index ) viewport = [] for group in groups : viewport += [ group . screen . x , group . screen . y ] if group . screen else [ 0 , 0 ] self . _root . set_property ( \"_NET_DESKTOP_VIEWPORT\" , viewport )","title":"update_desktops()"},{"location":"reference/libqtile/backend/x11/drawer/","text":"Drawer ( qtile , win , width , height ) Bases: base . Drawer A helper class for drawing to Internal windows. The underlying surface here is an XCBSurface backed by a pixmap. We draw to the pixmap starting at offset 0, 0, and when the time comes to display to the window (on draw()), we copy the appropriate portion of the pixmap onto the window. In the event that our drawing area is resized, we invalidate the underlying surface and pixmap and recreate them when we need them again with the new geometry. Source code in libqtile/backend/x11/drawer.py 26 27 28 29 30 31 32 33 def __init__ ( self , qtile : Qtile , win : Internal , width : int , height : int ): base . Drawer . __init__ ( self , qtile , win , width , height ) self . _xcb_surface = None self . _pixmap = None self . _gc = None self . _depth , self . _visual = qtile . core . conn . default_screen . _get_depth_and_visual ( win . _depth )","title":"drawer"},{"location":"reference/libqtile/backend/x11/drawer/#libqtile.backend.x11.drawer.Drawer","text":"Bases: base . Drawer A helper class for drawing to Internal windows. The underlying surface here is an XCBSurface backed by a pixmap. We draw to the pixmap starting at offset 0, 0, and when the time comes to display to the window (on draw()), we copy the appropriate portion of the pixmap onto the window. In the event that our drawing area is resized, we invalidate the underlying surface and pixmap and recreate them when we need them again with the new geometry. Source code in libqtile/backend/x11/drawer.py 26 27 28 29 30 31 32 33 def __init__ ( self , qtile : Qtile , win : Internal , width : int , height : int ): base . Drawer . __init__ ( self , qtile , win , width , height ) self . _xcb_surface = None self . _pixmap = None self . _gc = None self . _depth , self . _visual = qtile . core . conn . default_screen . _get_depth_and_visual ( win . _depth )","title":"Drawer"},{"location":"reference/libqtile/backend/x11/window/","text":"Internal ( win , qtile , desired_depth = 32 ) Bases: _Window , base . Internal An internal window, that should not be managed by qtile Source code in libqtile/backend/x11/window.py 1115 1116 1117 1118 def __init__ ( self , win , qtile , desired_depth = 32 ): _Window . __init__ ( self , win , qtile ) win . set_property ( \"QTILE_INTERNAL\" , 1 ) self . _depth = desired_depth create_drawer ( width , height ) Create a Drawer that draws to this window. Source code in libqtile/backend/x11/window.py 1120 1121 1122 def create_drawer ( self , width : int , height : int ) -> base . Drawer : \"\"\"Create a Drawer that draws to this window.\"\"\" return Drawer ( self . qtile , self , width , height ) Static ( win , qtile , screen , x = None , y = None , width = None , height = None ) Bases: _Window , base . Static An static window, belonging to a screen rather than a group Source code in libqtile/backend/x11/window.py 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 def __init__ ( self , win , qtile , screen , x = None , y = None , width = None , height = None ): _Window . __init__ ( self , win , qtile ) self . _wm_class : list [ str ] | None = None self . update_wm_class () self . update_name () self . conf_x = x self . conf_y = y self . conf_width = width self . conf_height = height x = x or self . x y = y or self . y self . x = x + screen . x self . y = y + screen . y self . screen = screen self . place ( self . x , self . y , width or self . width , height or self . height , 0 , 0 ) self . unhide () self . update_strut () self . _grab_click () Window ( window , qtile ) Bases: _Window , base . Window Source code in libqtile/backend/x11/window.py 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 def __init__ ( self , window , qtile ): _Window . __init__ ( self , window , qtile ) self . _wm_class : list [ str ] | None = None self . update_wm_class () self . update_name () self . set_group () # add window to the save-set, so it gets mapped when qtile dies qtile . core . conn . conn . core . ChangeSaveSet ( SetMode . Insert , self . window . wid ) self . update_wm_net_icon () self . _grab_click () match ( match ) Match window against given attributes. Parameters match: a config.Match object Source code in libqtile/backend/x11/window.py 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 @expose_command () def match ( self , match ): \"\"\"Match window against given attributes. Parameters ========== match: a config.Match object \"\"\" try : return match . compare ( self ) except ( xcffib . xproto . WindowError , xcffib . xproto . AccessError ): return False move_floating ( dx , dy ) Move window by dx and dy Source code in libqtile/backend/x11/window.py 1800 1801 1802 1803 @expose_command () def move_floating ( self , dx , dy ): \"\"\"Move window by dx and dy\"\"\" self . tweak_float ( dx = dx , dy = dy ) resize_floating ( dw , dh ) Add dw and dh to size of window Source code in libqtile/backend/x11/window.py 1805 1806 1807 1808 @expose_command () def resize_floating ( self , dw , dh ): \"\"\"Add dw and dh to size of window\"\"\" self . tweak_float ( dw = dw , dh = dh ) set_position_floating ( x , y ) Move window to x and y Source code in libqtile/backend/x11/window.py 1810 1811 1812 1813 @expose_command () def set_position_floating ( self , x , y ): \"\"\"Move window to x and y\"\"\" self . tweak_float ( x = x , y = y ) set_size_floating ( w , h ) Set window dimensions to w and h Source code in libqtile/backend/x11/window.py 1815 1816 1817 1818 @expose_command () def set_size_floating ( self , w , h ): \"\"\"Set window dimensions to w and h\"\"\" self . tweak_float ( w = w , h = h ) static ( screen = None , x = None , y = None , width = None , height = None ) Makes this window a static window, attached to a Screen If any of the arguments are left unspecified, the values given by the window itself are used instead. So, for a window that's aware of its appropriate size and location (like dzen), you don't have to specify anything. Source code in libqtile/backend/x11/window.py 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 @expose_command () def static ( self , screen : int | None = None , x : int | None = None , y : int | None = None , width : int | None = None , height : int | None = None , ) -> None : \"\"\"Makes this window a static window, attached to a Screen If any of the arguments are left unspecified, the values given by the window itself are used instead. So, for a window that's aware of its appropriate size and location (like dzen), you don't have to specify anything. \"\"\" self . defunct = True if screen is None : screen = self . qtile . current_screen else : screen = self . qtile . screens [ screen ] if self . group : self . group . remove ( self ) s = Static ( self . window , self . qtile , screen , x , y , width , height ) self . qtile . windows_map [ self . window . wid ] = s self . qtile . core . update_client_list ( self . qtile . windows_map ) hook . fire ( \"client_managed\" , s ) togroup ( group_name = None , * , switch_group = False , toggle = False ) Move window to a specified group Also switch to that group if switch_group is True. If toggle is True and and the specified group is already on the screen, use the last used group as target instead. Source code in libqtile/backend/x11/window.py 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 @expose_command () def togroup ( self , group_name = None , * , switch_group = False , toggle = False ): \"\"\"Move window to a specified group Also switch to that group if switch_group is True. If `toggle` is True and and the specified group is already on the screen, use the last used group as target instead. \"\"\" if group_name is None : group = self . qtile . current_group else : group = self . qtile . groups_map . get ( group_name ) if group is None : raise CommandError ( \"No such group: %s \" % group_name ) if self . group is group : if toggle and self . group . screen . previous_group : group = self . group . screen . previous_group else : return self . hide () if self . group : if self . group . screen : # for floats remove window offset self . x -= self . group . screen . x self . group . remove ( self ) if group . screen and self . x < group . screen . x : self . x += group . screen . x group . add ( self ) if switch_group : group . toscreen ( toggle = toggle ) update_wm_net_icon () Set a dict with the icons of the window Source code in libqtile/backend/x11/window.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 def update_wm_net_icon ( self ): \"\"\"Set a dict with the icons of the window\"\"\" icon = self . window . get_property ( \"_NET_WM_ICON\" , \"CARDINAL\" ) if not icon : return icon = list ( map ( ord , icon . value )) icons = {} while True : if not icon : break size = icon [: 8 ] if len ( size ) != 8 or not size [ 0 ] or not size [ 4 ]: break icon = icon [ 8 :] width = size [ 0 ] height = size [ 4 ] next_pix = width * height * 4 data = icon [: next_pix ] arr = array . array ( \"B\" , data ) for i in range ( 0 , len ( arr ), 4 ): mult = arr [ i + 3 ] / 255.0 arr [ i + 0 ] = int ( arr [ i + 0 ] * mult ) arr [ i + 1 ] = int ( arr [ i + 1 ] * mult ) arr [ i + 2 ] = int ( arr [ i + 2 ] * mult ) icon = icon [ next_pix :] icons [ \" %s x %s \" % ( width , height )] = arr self . icons = icons hook . fire ( \"net_wm_icon_change\" , self ) XWindow ( conn , wid ) Source code in libqtile/backend/x11/window.py 120 121 122 def __init__ ( self , conn , wid ): self . conn = conn self . wid = wid configure ( ** kwargs ) Arguments can be: x, y, width, height, borderwidth, sibling, stackmode Source code in libqtile/backend/x11/window.py 297 298 299 300 301 302 303 304 305 306 def configure ( self , ** kwargs ): \"\"\" Arguments can be: x, y, width, height, borderwidth, sibling, stackmode \"\"\" mask , values = xcbq . ConfigureMasks ( ** kwargs ) # older versions of xcb pack everything into unsigned ints \"=I\" # since 1.12, uses switches to pack things sensibly if float ( \".\" . join ( xcffib . __xcb_proto_version__ . split ( \".\" )[ 0 : 2 ])) < 1.12 : values = [ i & 0xFFFFFFFF for i in values ] return self . conn . conn . core . ConfigureWindow ( self . wid , mask , values ) get_name () Tries to retrieve a canonical window name. We test the following properties in order of preference: - _NET_WM_VISIBLE_NAME - _NET_WM_NAME - WM_NAME. Source code in libqtile/backend/x11/window.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def get_name ( self ): \"\"\"Tries to retrieve a canonical window name. We test the following properties in order of preference: - _NET_WM_VISIBLE_NAME - _NET_WM_NAME - WM_NAME. \"\"\" r = self . get_property ( \"_NET_WM_VISIBLE_NAME\" , \"UTF8_STRING\" ) if r : return self . _property_utf8 ( r ) r = self . get_property ( \"_NET_WM_NAME\" , \"UTF8_STRING\" ) if r : return self . _property_utf8 ( r ) r = self . get_property ( xcffib . xproto . Atom . WM_NAME , \"UTF8_STRING\" ) if r : return self . _property_utf8 ( r ) r = self . get_property ( xcffib . xproto . Atom . WM_NAME , xcffib . xproto . GetPropertyType . Any ) if r : return self . _property_string ( r ) get_property ( prop , type = None , unpack = None ) Return the contents of a property as a GetPropertyReply If unpack is specified, a tuple of values is returned. The type to unpack, either str or int must be specified. Source code in libqtile/backend/x11/window.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def get_property ( self , prop , type = None , unpack = None ): \"\"\"Return the contents of a property as a GetPropertyReply If unpack is specified, a tuple of values is returned. The type to unpack, either `str` or `int` must be specified. \"\"\" if type is None : if prop not in xcbq . PropertyMap : raise ValueError ( \"Must specify type for unknown property.\" ) else : type , _ = xcbq . PropertyMap [ prop ] try : r = self . conn . conn . core . GetProperty ( False , self . wid , self . conn . atoms [ prop ] if isinstance ( prop , str ) else prop , self . conn . atoms [ type ] if isinstance ( type , str ) else type , 0 , ( 2 ** 32 ) - 1 , ) . reply () except ( xcffib . xproto . WindowError , xcffib . xproto . AccessError ): logger . debug ( \"X error in GetProperty (wid= %r , prop= %r ), ignoring\" , self . wid , prop ) if unpack : return [] return None if not r . value_len : if unpack : return [] return None elif unpack : # Should we allow more options for unpacking? if unpack is int : return r . value . to_atoms () elif unpack is str : return r . value . to_string () else : return r get_wm_class () Return an (instance, class) tuple if WM_CLASS exists. Source code in libqtile/backend/x11/window.py 232 233 234 235 236 237 238 def get_wm_class ( self ): \"\"\"Return an (instance, class) tuple if WM_CLASS exists.\"\"\" r = self . get_property ( \"WM_CLASS\" , \"STRING\" ) if r : s = self . _property_string ( r ) return list ( s . strip ( \" \\0 \" ) . split ( \" \\0 \" )) return [] get_wm_transient_for () Returns the WID of the parent window Source code in libqtile/backend/x11/window.py 245 246 247 248 249 250 def get_wm_transient_for ( self ): \"\"\"Returns the WID of the parent window\"\"\" r = self . get_property ( \"WM_TRANSIENT_FOR\" , \"WINDOW\" , unpack = int ) if r : return r [ 0 ] get_wm_type () http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#id2551529 Source code in libqtile/backend/x11/window.py 276 277 278 279 280 281 282 283 def get_wm_type ( self ): \"\"\" http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#id2551529 \"\"\" r = self . get_property ( \"_NET_WM_WINDOW_TYPE\" , \"ATOM\" , unpack = int ) if r : name = self . conn . atoms . get_name ( r [ 0 ]) return xcbq . WindowTypes . get ( name , name ) paint_borders ( depth , colors , borderwidth , width , height ) This method is used only by the managing Window class. Source code in libqtile/backend/x11/window.py 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def paint_borders ( self , depth , colors , borderwidth , width , height ): \"\"\" This method is used only by the managing Window class. \"\"\" self . set_property ( \"_NET_FRAME_EXTENTS\" , [ borderwidth ] * 4 ) if not colors or not borderwidth : return if isinstance ( colors , str ): self . set_attribute ( borderpixel = self . conn . color_pixel ( colors )) return if len ( colors ) > borderwidth : colors = colors [: borderwidth ] core = self . conn . conn . core outer_w = width + borderwidth * 2 outer_h = height + borderwidth * 2 with PixmapID ( self . conn . conn ) as pixmap : with GContextID ( self . conn . conn ) as gc : core . CreatePixmap ( depth , pixmap , self . wid , outer_w , outer_h ) core . CreateGC ( gc , pixmap , 0 , None ) borders = len ( colors ) borderwidths = [ borderwidth // borders ] * borders for i in range ( borderwidth % borders ): borderwidths [ i ] += 1 coord = 0 for i in range ( borders ): core . ChangeGC ( gc , xcffib . xproto . GC . Foreground , [ self . conn . color_pixel ( colors [ i ])] ) rect = xcffib . xproto . RECTANGLE . synthetic ( coord , coord , outer_w - coord * 2 , outer_h - coord * 2 ) core . PolyFillRectangle ( pixmap , gc , 1 , [ rect ]) coord += borderwidths [ i ] self . _set_borderpixmap ( depth , pixmap , gc , borderwidth , width , height ) set_property ( name , value , type = None , format = None ) Parameters name: String Atom name type: String Atom name format: 8, 16, 32 Source code in libqtile/backend/x11/window.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def set_property ( self , name , value , type = None , format = None ): \"\"\" Parameters ========== name: String Atom name type: String Atom name format: 8, 16, 32 \"\"\" if name in xcbq . PropertyMap : if type or format : raise ValueError ( \"Over-riding default type or format for property.\" ) type , format = xcbq . PropertyMap [ name ] else : if None in ( type , format ): raise ValueError ( \"Must specify type and format for unknown property.\" ) try : if isinstance ( value , str ): # xcffib will pack the bytes, but we should encode them properly value = value . encode () else : # if this runs without error, the value is already a list, don't wrap it next ( iter ( value )) except StopIteration : # The value was an iterable, just empty value = [] except TypeError : # the value wasn't an iterable and wasn't a string, so let's # wrap it. value = [ value ] try : self . conn . conn . core . ChangePropertyChecked ( xcffib . xproto . PropMode . Replace , self . wid , self . conn . atoms [ name ], self . conn . atoms [ type ], format , # Format - 8, 16, 32 len ( value ), value , ) . check () except xcffib . xproto . WindowError : logger . debug ( \"X error in SetProperty (wid= %r , prop= %r ), ignoring\" , self . wid , name ) warp_pointer ( x , y ) Warps the pointer to the location x , y on the window Source code in libqtile/backend/x11/window.py 145 146 147 148 149 150 151 152 153 154 155 156 def warp_pointer ( self , x , y ): \"\"\"Warps the pointer to the location `x`, `y` on the window\"\"\" self . conn . conn . core . WarpPointer ( 0 , self . wid , # src_window, dst_window 0 , 0 , # src_x, src_y 0 , 0 , # src_width, src_height x , y , # dest_x, dest_y )","title":"window"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Internal","text":"Bases: _Window , base . Internal An internal window, that should not be managed by qtile Source code in libqtile/backend/x11/window.py 1115 1116 1117 1118 def __init__ ( self , win , qtile , desired_depth = 32 ): _Window . __init__ ( self , win , qtile ) win . set_property ( \"QTILE_INTERNAL\" , 1 ) self . _depth = desired_depth","title":"Internal"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Internal.create_drawer","text":"Create a Drawer that draws to this window. Source code in libqtile/backend/x11/window.py 1120 1121 1122 def create_drawer ( self , width : int , height : int ) -> base . Drawer : \"\"\"Create a Drawer that draws to this window.\"\"\" return Drawer ( self . qtile , self , width , height )","title":"create_drawer()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Static","text":"Bases: _Window , base . Static An static window, belonging to a screen rather than a group Source code in libqtile/backend/x11/window.py 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 def __init__ ( self , win , qtile , screen , x = None , y = None , width = None , height = None ): _Window . __init__ ( self , win , qtile ) self . _wm_class : list [ str ] | None = None self . update_wm_class () self . update_name () self . conf_x = x self . conf_y = y self . conf_width = width self . conf_height = height x = x or self . x y = y or self . y self . x = x + screen . x self . y = y + screen . y self . screen = screen self . place ( self . x , self . y , width or self . width , height or self . height , 0 , 0 ) self . unhide () self . update_strut () self . _grab_click ()","title":"Static"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window","text":"Bases: _Window , base . Window Source code in libqtile/backend/x11/window.py 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 def __init__ ( self , window , qtile ): _Window . __init__ ( self , window , qtile ) self . _wm_class : list [ str ] | None = None self . update_wm_class () self . update_name () self . set_group () # add window to the save-set, so it gets mapped when qtile dies qtile . core . conn . conn . core . ChangeSaveSet ( SetMode . Insert , self . window . wid ) self . update_wm_net_icon () self . _grab_click ()","title":"Window"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.match","text":"Match window against given attributes.","title":"match()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.match--parameters","text":"match: a config.Match object Source code in libqtile/backend/x11/window.py 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 @expose_command () def match ( self , match ): \"\"\"Match window against given attributes. Parameters ========== match: a config.Match object \"\"\" try : return match . compare ( self ) except ( xcffib . xproto . WindowError , xcffib . xproto . AccessError ): return False","title":"Parameters"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.move_floating","text":"Move window by dx and dy Source code in libqtile/backend/x11/window.py 1800 1801 1802 1803 @expose_command () def move_floating ( self , dx , dy ): \"\"\"Move window by dx and dy\"\"\" self . tweak_float ( dx = dx , dy = dy )","title":"move_floating()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.resize_floating","text":"Add dw and dh to size of window Source code in libqtile/backend/x11/window.py 1805 1806 1807 1808 @expose_command () def resize_floating ( self , dw , dh ): \"\"\"Add dw and dh to size of window\"\"\" self . tweak_float ( dw = dw , dh = dh )","title":"resize_floating()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.set_position_floating","text":"Move window to x and y Source code in libqtile/backend/x11/window.py 1810 1811 1812 1813 @expose_command () def set_position_floating ( self , x , y ): \"\"\"Move window to x and y\"\"\" self . tweak_float ( x = x , y = y )","title":"set_position_floating()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.set_size_floating","text":"Set window dimensions to w and h Source code in libqtile/backend/x11/window.py 1815 1816 1817 1818 @expose_command () def set_size_floating ( self , w , h ): \"\"\"Set window dimensions to w and h\"\"\" self . tweak_float ( w = w , h = h )","title":"set_size_floating()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.static","text":"Makes this window a static window, attached to a Screen If any of the arguments are left unspecified, the values given by the window itself are used instead. So, for a window that's aware of its appropriate size and location (like dzen), you don't have to specify anything. Source code in libqtile/backend/x11/window.py 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 @expose_command () def static ( self , screen : int | None = None , x : int | None = None , y : int | None = None , width : int | None = None , height : int | None = None , ) -> None : \"\"\"Makes this window a static window, attached to a Screen If any of the arguments are left unspecified, the values given by the window itself are used instead. So, for a window that's aware of its appropriate size and location (like dzen), you don't have to specify anything. \"\"\" self . defunct = True if screen is None : screen = self . qtile . current_screen else : screen = self . qtile . screens [ screen ] if self . group : self . group . remove ( self ) s = Static ( self . window , self . qtile , screen , x , y , width , height ) self . qtile . windows_map [ self . window . wid ] = s self . qtile . core . update_client_list ( self . qtile . windows_map ) hook . fire ( \"client_managed\" , s )","title":"static()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.togroup","text":"Move window to a specified group Also switch to that group if switch_group is True. If toggle is True and and the specified group is already on the screen, use the last used group as target instead. Source code in libqtile/backend/x11/window.py 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 @expose_command () def togroup ( self , group_name = None , * , switch_group = False , toggle = False ): \"\"\"Move window to a specified group Also switch to that group if switch_group is True. If `toggle` is True and and the specified group is already on the screen, use the last used group as target instead. \"\"\" if group_name is None : group = self . qtile . current_group else : group = self . qtile . groups_map . get ( group_name ) if group is None : raise CommandError ( \"No such group: %s \" % group_name ) if self . group is group : if toggle and self . group . screen . previous_group : group = self . group . screen . previous_group else : return self . hide () if self . group : if self . group . screen : # for floats remove window offset self . x -= self . group . screen . x self . group . remove ( self ) if group . screen and self . x < group . screen . x : self . x += group . screen . x group . add ( self ) if switch_group : group . toscreen ( toggle = toggle )","title":"togroup()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.Window.update_wm_net_icon","text":"Set a dict with the icons of the window Source code in libqtile/backend/x11/window.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 def update_wm_net_icon ( self ): \"\"\"Set a dict with the icons of the window\"\"\" icon = self . window . get_property ( \"_NET_WM_ICON\" , \"CARDINAL\" ) if not icon : return icon = list ( map ( ord , icon . value )) icons = {} while True : if not icon : break size = icon [: 8 ] if len ( size ) != 8 or not size [ 0 ] or not size [ 4 ]: break icon = icon [ 8 :] width = size [ 0 ] height = size [ 4 ] next_pix = width * height * 4 data = icon [: next_pix ] arr = array . array ( \"B\" , data ) for i in range ( 0 , len ( arr ), 4 ): mult = arr [ i + 3 ] / 255.0 arr [ i + 0 ] = int ( arr [ i + 0 ] * mult ) arr [ i + 1 ] = int ( arr [ i + 1 ] * mult ) arr [ i + 2 ] = int ( arr [ i + 2 ] * mult ) icon = icon [ next_pix :] icons [ \" %s x %s \" % ( width , height )] = arr self . icons = icons hook . fire ( \"net_wm_icon_change\" , self )","title":"update_wm_net_icon()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow","text":"Source code in libqtile/backend/x11/window.py 120 121 122 def __init__ ( self , conn , wid ): self . conn = conn self . wid = wid","title":"XWindow"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.configure","text":"Arguments can be: x, y, width, height, borderwidth, sibling, stackmode Source code in libqtile/backend/x11/window.py 297 298 299 300 301 302 303 304 305 306 def configure ( self , ** kwargs ): \"\"\" Arguments can be: x, y, width, height, borderwidth, sibling, stackmode \"\"\" mask , values = xcbq . ConfigureMasks ( ** kwargs ) # older versions of xcb pack everything into unsigned ints \"=I\" # since 1.12, uses switches to pack things sensibly if float ( \".\" . join ( xcffib . __xcb_proto_version__ . split ( \".\" )[ 0 : 2 ])) < 1.12 : values = [ i & 0xFFFFFFFF for i in values ] return self . conn . conn . core . ConfigureWindow ( self . wid , mask , values )","title":"configure()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.get_name","text":"Tries to retrieve a canonical window name. We test the following properties in order of preference: - _NET_WM_VISIBLE_NAME - _NET_WM_NAME - WM_NAME. Source code in libqtile/backend/x11/window.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def get_name ( self ): \"\"\"Tries to retrieve a canonical window name. We test the following properties in order of preference: - _NET_WM_VISIBLE_NAME - _NET_WM_NAME - WM_NAME. \"\"\" r = self . get_property ( \"_NET_WM_VISIBLE_NAME\" , \"UTF8_STRING\" ) if r : return self . _property_utf8 ( r ) r = self . get_property ( \"_NET_WM_NAME\" , \"UTF8_STRING\" ) if r : return self . _property_utf8 ( r ) r = self . get_property ( xcffib . xproto . Atom . WM_NAME , \"UTF8_STRING\" ) if r : return self . _property_utf8 ( r ) r = self . get_property ( xcffib . xproto . Atom . WM_NAME , xcffib . xproto . GetPropertyType . Any ) if r : return self . _property_string ( r )","title":"get_name()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.get_property","text":"Return the contents of a property as a GetPropertyReply If unpack is specified, a tuple of values is returned. The type to unpack, either str or int must be specified. Source code in libqtile/backend/x11/window.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def get_property ( self , prop , type = None , unpack = None ): \"\"\"Return the contents of a property as a GetPropertyReply If unpack is specified, a tuple of values is returned. The type to unpack, either `str` or `int` must be specified. \"\"\" if type is None : if prop not in xcbq . PropertyMap : raise ValueError ( \"Must specify type for unknown property.\" ) else : type , _ = xcbq . PropertyMap [ prop ] try : r = self . conn . conn . core . GetProperty ( False , self . wid , self . conn . atoms [ prop ] if isinstance ( prop , str ) else prop , self . conn . atoms [ type ] if isinstance ( type , str ) else type , 0 , ( 2 ** 32 ) - 1 , ) . reply () except ( xcffib . xproto . WindowError , xcffib . xproto . AccessError ): logger . debug ( \"X error in GetProperty (wid= %r , prop= %r ), ignoring\" , self . wid , prop ) if unpack : return [] return None if not r . value_len : if unpack : return [] return None elif unpack : # Should we allow more options for unpacking? if unpack is int : return r . value . to_atoms () elif unpack is str : return r . value . to_string () else : return r","title":"get_property()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.get_wm_class","text":"Return an (instance, class) tuple if WM_CLASS exists. Source code in libqtile/backend/x11/window.py 232 233 234 235 236 237 238 def get_wm_class ( self ): \"\"\"Return an (instance, class) tuple if WM_CLASS exists.\"\"\" r = self . get_property ( \"WM_CLASS\" , \"STRING\" ) if r : s = self . _property_string ( r ) return list ( s . strip ( \" \\0 \" ) . split ( \" \\0 \" )) return []","title":"get_wm_class()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.get_wm_transient_for","text":"Returns the WID of the parent window Source code in libqtile/backend/x11/window.py 245 246 247 248 249 250 def get_wm_transient_for ( self ): \"\"\"Returns the WID of the parent window\"\"\" r = self . get_property ( \"WM_TRANSIENT_FOR\" , \"WINDOW\" , unpack = int ) if r : return r [ 0 ]","title":"get_wm_transient_for()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.get_wm_type","text":"http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#id2551529 Source code in libqtile/backend/x11/window.py 276 277 278 279 280 281 282 283 def get_wm_type ( self ): \"\"\" http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#id2551529 \"\"\" r = self . get_property ( \"_NET_WM_WINDOW_TYPE\" , \"ATOM\" , unpack = int ) if r : name = self . conn . atoms . get_name ( r [ 0 ]) return xcbq . WindowTypes . get ( name , name )","title":"get_wm_type()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.paint_borders","text":"This method is used only by the managing Window class. Source code in libqtile/backend/x11/window.py 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def paint_borders ( self , depth , colors , borderwidth , width , height ): \"\"\" This method is used only by the managing Window class. \"\"\" self . set_property ( \"_NET_FRAME_EXTENTS\" , [ borderwidth ] * 4 ) if not colors or not borderwidth : return if isinstance ( colors , str ): self . set_attribute ( borderpixel = self . conn . color_pixel ( colors )) return if len ( colors ) > borderwidth : colors = colors [: borderwidth ] core = self . conn . conn . core outer_w = width + borderwidth * 2 outer_h = height + borderwidth * 2 with PixmapID ( self . conn . conn ) as pixmap : with GContextID ( self . conn . conn ) as gc : core . CreatePixmap ( depth , pixmap , self . wid , outer_w , outer_h ) core . CreateGC ( gc , pixmap , 0 , None ) borders = len ( colors ) borderwidths = [ borderwidth // borders ] * borders for i in range ( borderwidth % borders ): borderwidths [ i ] += 1 coord = 0 for i in range ( borders ): core . ChangeGC ( gc , xcffib . xproto . GC . Foreground , [ self . conn . color_pixel ( colors [ i ])] ) rect = xcffib . xproto . RECTANGLE . synthetic ( coord , coord , outer_w - coord * 2 , outer_h - coord * 2 ) core . PolyFillRectangle ( pixmap , gc , 1 , [ rect ]) coord += borderwidths [ i ] self . _set_borderpixmap ( depth , pixmap , gc , borderwidth , width , height )","title":"paint_borders()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.set_property","text":"","title":"set_property()"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.set_property--parameters","text":"name: String Atom name type: String Atom name format: 8, 16, 32 Source code in libqtile/backend/x11/window.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def set_property ( self , name , value , type = None , format = None ): \"\"\" Parameters ========== name: String Atom name type: String Atom name format: 8, 16, 32 \"\"\" if name in xcbq . PropertyMap : if type or format : raise ValueError ( \"Over-riding default type or format for property.\" ) type , format = xcbq . PropertyMap [ name ] else : if None in ( type , format ): raise ValueError ( \"Must specify type and format for unknown property.\" ) try : if isinstance ( value , str ): # xcffib will pack the bytes, but we should encode them properly value = value . encode () else : # if this runs without error, the value is already a list, don't wrap it next ( iter ( value )) except StopIteration : # The value was an iterable, just empty value = [] except TypeError : # the value wasn't an iterable and wasn't a string, so let's # wrap it. value = [ value ] try : self . conn . conn . core . ChangePropertyChecked ( xcffib . xproto . PropMode . Replace , self . wid , self . conn . atoms [ name ], self . conn . atoms [ type ], format , # Format - 8, 16, 32 len ( value ), value , ) . check () except xcffib . xproto . WindowError : logger . debug ( \"X error in SetProperty (wid= %r , prop= %r ), ignoring\" , self . wid , name )","title":"Parameters"},{"location":"reference/libqtile/backend/x11/window/#libqtile.backend.x11.window.XWindow.warp_pointer","text":"Warps the pointer to the location x , y on the window Source code in libqtile/backend/x11/window.py 145 146 147 148 149 150 151 152 153 154 155 156 def warp_pointer ( self , x , y ): \"\"\"Warps the pointer to the location `x`, `y` on the window\"\"\" self . conn . conn . core . WarpPointer ( 0 , self . wid , # src_window, dst_window 0 , 0 , # src_x, src_y 0 , 0 , # src_width, src_height x , y , # dest_x, dest_y )","title":"warp_pointer()"},{"location":"reference/libqtile/backend/x11/xcbq/","text":"A minimal EWMH-aware OO layer over xcffib. This is NOT intended to be complete - it only implements the subset of functionalty needed by qtile. Colormap ( conn , cid ) Source code in libqtile/backend/x11/xcbq.py 371 372 373 def __init__ ( self , conn , cid ): self . conn = conn self . cid = cid alloc_color ( color ) Flexible color allocation. Source code in libqtile/backend/x11/xcbq.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def alloc_color ( self , color ): \"\"\" Flexible color allocation. \"\"\" try : return self . conn . conn . core . AllocNamedColor ( self . cid , len ( color ), color ) . reply () except xcffib . xproto . NameError : def x8to16 ( i ): return 0xFFFF * ( i & 0xFF ) // 0xFF color = hex ( color ) r = x8to16 ( int ( color [ - 6 ] + color [ - 5 ], 16 )) g = x8to16 ( int ( color [ - 4 ] + color [ - 3 ], 16 )) b = x8to16 ( int ( color [ - 2 ] + color [ - 1 ], 16 )) return self . conn . conn . core . AllocColor ( self . cid , r , g , b ) . reply () Connection ( display ) Source code in libqtile/backend/x11/xcbq.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 def __init__ ( self , display ): self . conn = xcffib . connect ( display = display ) self . _connected = True self . cursors = Cursors ( self ) self . setup = self . conn . get_setup () extensions = self . extensions () self . screens = [ Screen ( self , i ) for i in self . setup . roots ] self . default_screen = self . screens [ self . conn . pref_screen ] for i in extensions : if i in self . _extmap : setattr ( self , i , self . _extmap [ i ]( self )) self . atoms = AtomCache ( self ) self . code_to_syms = {} self . sym_to_codes = None self . refresh_keymap () self . modmap = None self . refresh_modmap () self . _cmaps = {} fixup_focus () If the X11 focus is set to None, all keypress events are discarded, which makes our hotkeys not work. This fixes up the focus so it is not None. Source code in libqtile/backend/x11/xcbq.py 654 655 656 657 658 659 660 661 662 663 664 665 666 def fixup_focus ( self ): \"\"\" If the X11 focus is set to None, all keypress events are discarded, which makes our hotkeys not work. This fixes up the focus so it is not None. \"\"\" window = self . conn . core . GetInputFocus () . reply () . focus if window == xcffib . xproto . InputFocus . _None : self . conn . core . SetInputFocus ( xcffib . xproto . InputFocus . PointerRoot , xcffib . xproto . InputFocus . PointerRoot , xcffib . xproto . Time . CurrentTime , ) get_modifier ( keycode ) Return the modifier matching keycode Source code in libqtile/backend/x11/xcbq.py 585 586 587 588 589 590 def get_modifier ( self , keycode ): \"\"\"Return the modifier matching keycode\"\"\" for n , l in self . modmap . items (): if keycode in l : return n return None MaskMap ( obj ) A general utility class that encapsulates the way the bitmask/listofvalue idiom works in X protocol. It understands a special attribute _maskvalue on objects, which will be used instead of the object value if present. This lets us pass in a Font object, rather than Font.fid, for example. Source code in libqtile/backend/x11/xcbq.py 225 226 227 228 229 230 def __init__ ( self , obj ): self . mmap = [] for i in dir ( obj ): if not i . startswith ( \"_\" ): self . mmap . append (( getattr ( obj , i ), i . lower ())) self . mmap . sort () __call__ ( ** kwargs ) kwargs: keys should be in the mmap name set Returns a (mask, values) tuple. Source code in libqtile/backend/x11/xcbq.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def __call__ ( self , ** kwargs ): \"\"\" kwargs: keys should be in the mmap name set Returns a (mask, values) tuple. \"\"\" mask = 0 values = [] for m , s in self . mmap : if s in kwargs : val = kwargs . get ( s ) if val is not None : mask |= m values . append ( getattr ( val , \"_maskvalue\" , val )) del kwargs [ s ] if kwargs : raise ValueError ( \"Unknown mask names: %s \" % list ( kwargs . keys ())) return mask , values NetWmState ( prop_name ) NetWmState is a descriptor for NET_WM_STATE * properties Source code in libqtile/backend/x11/xcbq.py 441 442 def __init__ ( self , prop_name ): self . prop_name = prop_name PseudoScreen ( conn , x , y , width , height ) This may be a Xinerama screen or a RandR CRTC, both of which are rectangular sections of an actual Screen. Source code in libqtile/backend/x11/xcbq.py 362 363 364 365 366 367 def __init__ ( self , conn , x , y , width , height ): self . conn = conn self . x = x self . y = y self . width = width self . height = height Screen ( conn , screen ) Bases: _Wrapper This represents an actual X screen. Source code in libqtile/backend/x11/xcbq.py 305 306 307 308 309 310 311 312 313 314 315 316 317 def __init__ ( self , conn , screen ): _Wrapper . __init__ ( self , screen ) self . default_colormap = Colormap ( conn , screen . default_colormap ) self . root = window . XWindow ( conn , self . root ) self . _visuals = {} # Get visuals for 32 and 24 bit for d in [ 32 , 24 , self . root_depth ]: if d not in self . _visuals : visual = self . get_visual_for_depth ( self , d ) if visual : self . _visuals [ d ] = visual get_visual_for_depth ( screen , depth ) staticmethod Returns the visual object of the screen @ some depth For an ARGB visual -> depth=32 For a RGB visual -> depth=24 Source code in libqtile/backend/x11/xcbq.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 @staticmethod def get_visual_for_depth ( screen , depth ): \"\"\" Returns the visual object of the screen @ some depth For an ARGB visual -> depth=32 For a RGB visual -> depth=24 \"\"\" allowed = screen . allowed_depths if depth not in [ x . depth for x in allowed ]: logger . warning ( \"Unsupported colour depth: %s \" , depth ) return for i in allowed : if i . depth == depth : if i . visuals : return i . visuals [ 0 ] translate_masks ( modifiers ) Translate a modifier mask specified as a list of strings into an or-ed bit representation. Source code in libqtile/backend/x11/xcbq.py 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def translate_masks ( modifiers : list [ str ]) -> int : \"\"\" Translate a modifier mask specified as a list of strings into an or-ed bit representation. \"\"\" masks = [] for i in modifiers : try : masks . append ( ModMasks [ i . lower ()]) except KeyError as e : raise XCBQError ( \"Unknown modifier: %s \" % i ) from e if masks : return functools . reduce ( operator . or_ , masks ) else : return 0","title":"xcbq"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Colormap","text":"Source code in libqtile/backend/x11/xcbq.py 371 372 373 def __init__ ( self , conn , cid ): self . conn = conn self . cid = cid","title":"Colormap"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Colormap.alloc_color","text":"Flexible color allocation. Source code in libqtile/backend/x11/xcbq.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def alloc_color ( self , color ): \"\"\" Flexible color allocation. \"\"\" try : return self . conn . conn . core . AllocNamedColor ( self . cid , len ( color ), color ) . reply () except xcffib . xproto . NameError : def x8to16 ( i ): return 0xFFFF * ( i & 0xFF ) // 0xFF color = hex ( color ) r = x8to16 ( int ( color [ - 6 ] + color [ - 5 ], 16 )) g = x8to16 ( int ( color [ - 4 ] + color [ - 3 ], 16 )) b = x8to16 ( int ( color [ - 2 ] + color [ - 1 ], 16 )) return self . conn . conn . core . AllocColor ( self . cid , r , g , b ) . reply ()","title":"alloc_color()"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Connection","text":"Source code in libqtile/backend/x11/xcbq.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 def __init__ ( self , display ): self . conn = xcffib . connect ( display = display ) self . _connected = True self . cursors = Cursors ( self ) self . setup = self . conn . get_setup () extensions = self . extensions () self . screens = [ Screen ( self , i ) for i in self . setup . roots ] self . default_screen = self . screens [ self . conn . pref_screen ] for i in extensions : if i in self . _extmap : setattr ( self , i , self . _extmap [ i ]( self )) self . atoms = AtomCache ( self ) self . code_to_syms = {} self . sym_to_codes = None self . refresh_keymap () self . modmap = None self . refresh_modmap () self . _cmaps = {}","title":"Connection"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Connection.fixup_focus","text":"If the X11 focus is set to None, all keypress events are discarded, which makes our hotkeys not work. This fixes up the focus so it is not None. Source code in libqtile/backend/x11/xcbq.py 654 655 656 657 658 659 660 661 662 663 664 665 666 def fixup_focus ( self ): \"\"\" If the X11 focus is set to None, all keypress events are discarded, which makes our hotkeys not work. This fixes up the focus so it is not None. \"\"\" window = self . conn . core . GetInputFocus () . reply () . focus if window == xcffib . xproto . InputFocus . _None : self . conn . core . SetInputFocus ( xcffib . xproto . InputFocus . PointerRoot , xcffib . xproto . InputFocus . PointerRoot , xcffib . xproto . Time . CurrentTime , )","title":"fixup_focus()"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Connection.get_modifier","text":"Return the modifier matching keycode Source code in libqtile/backend/x11/xcbq.py 585 586 587 588 589 590 def get_modifier ( self , keycode ): \"\"\"Return the modifier matching keycode\"\"\" for n , l in self . modmap . items (): if keycode in l : return n return None","title":"get_modifier()"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.MaskMap","text":"A general utility class that encapsulates the way the bitmask/listofvalue idiom works in X protocol. It understands a special attribute _maskvalue on objects, which will be used instead of the object value if present. This lets us pass in a Font object, rather than Font.fid, for example. Source code in libqtile/backend/x11/xcbq.py 225 226 227 228 229 230 def __init__ ( self , obj ): self . mmap = [] for i in dir ( obj ): if not i . startswith ( \"_\" ): self . mmap . append (( getattr ( obj , i ), i . lower ())) self . mmap . sort ()","title":"MaskMap"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.MaskMap.__call__","text":"kwargs: keys should be in the mmap name set Returns a (mask, values) tuple. Source code in libqtile/backend/x11/xcbq.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def __call__ ( self , ** kwargs ): \"\"\" kwargs: keys should be in the mmap name set Returns a (mask, values) tuple. \"\"\" mask = 0 values = [] for m , s in self . mmap : if s in kwargs : val = kwargs . get ( s ) if val is not None : mask |= m values . append ( getattr ( val , \"_maskvalue\" , val )) del kwargs [ s ] if kwargs : raise ValueError ( \"Unknown mask names: %s \" % list ( kwargs . keys ())) return mask , values","title":"__call__()"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.NetWmState","text":"NetWmState is a descriptor for NET_WM_STATE * properties Source code in libqtile/backend/x11/xcbq.py 441 442 def __init__ ( self , prop_name ): self . prop_name = prop_name","title":"NetWmState"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.PseudoScreen","text":"This may be a Xinerama screen or a RandR CRTC, both of which are rectangular sections of an actual Screen. Source code in libqtile/backend/x11/xcbq.py 362 363 364 365 366 367 def __init__ ( self , conn , x , y , width , height ): self . conn = conn self . x = x self . y = y self . width = width self . height = height","title":"PseudoScreen"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Screen","text":"Bases: _Wrapper This represents an actual X screen. Source code in libqtile/backend/x11/xcbq.py 305 306 307 308 309 310 311 312 313 314 315 316 317 def __init__ ( self , conn , screen ): _Wrapper . __init__ ( self , screen ) self . default_colormap = Colormap ( conn , screen . default_colormap ) self . root = window . XWindow ( conn , self . root ) self . _visuals = {} # Get visuals for 32 and 24 bit for d in [ 32 , 24 , self . root_depth ]: if d not in self . _visuals : visual = self . get_visual_for_depth ( self , d ) if visual : self . _visuals [ d ] = visual","title":"Screen"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.Screen.get_visual_for_depth","text":"Returns the visual object of the screen @ some depth For an ARGB visual -> depth=32 For a RGB visual -> depth=24 Source code in libqtile/backend/x11/xcbq.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 @staticmethod def get_visual_for_depth ( screen , depth ): \"\"\" Returns the visual object of the screen @ some depth For an ARGB visual -> depth=32 For a RGB visual -> depth=24 \"\"\" allowed = screen . allowed_depths if depth not in [ x . depth for x in allowed ]: logger . warning ( \"Unsupported colour depth: %s \" , depth ) return for i in allowed : if i . depth == depth : if i . visuals : return i . visuals [ 0 ]","title":"get_visual_for_depth()"},{"location":"reference/libqtile/backend/x11/xcbq/#libqtile.backend.x11.xcbq.translate_masks","text":"Translate a modifier mask specified as a list of strings into an or-ed bit representation. Source code in libqtile/backend/x11/xcbq.py 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def translate_masks ( modifiers : list [ str ]) -> int : \"\"\" Translate a modifier mask specified as a list of strings into an or-ed bit representation. \"\"\" masks = [] for i in modifiers : try : masks . append ( ModMasks [ i . lower ()]) except KeyError as e : raise XCBQError ( \"Unknown modifier: %s \" % i ) from e if masks : return functools . reduce ( operator . or_ , masks ) else : return 0","title":"translate_masks()"},{"location":"reference/libqtile/backend/x11/xcursors/","text":"Cursors ( conn ) Bases: dict Source code in libqtile/backend/x11/xcursors.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __init__ ( self , conn ): self . conn = conn cursors = ( ( b \"X_cursor\" , 0 ), ( b \"arrow\" , 2 ), ( b \"based_arrow_down\" , 4 ), ( b \"based_arrow_up\" , 6 ), ( b \"boat\" , 8 ), ( b \"bogosity\" , 10 ), ( b \"bottom_left_corner\" , 12 ), ( b \"bottom_right_corner\" , 14 ), ( b \"bottom_side\" , 16 ), ( b \"bottom_tee\" , 18 ), ( b \"box_spiral\" , 20 ), ( b \"center_ptr\" , 22 ), ( b \"circle\" , 24 ), ( b \"clock\" , 26 ), ( b \"coffee_mug\" , 28 ), ( b \"cross\" , 30 ), ( b \"cross_reverse\" , 32 ), ( b \"crosshair\" , 34 ), ( b \"diamond_cross\" , 36 ), ( b \"dot\" , 38 ), ( b \"dotbox\" , 40 ), ( b \"double_arrow\" , 42 ), ( b \"draft_large\" , 44 ), ( b \"draft_small\" , 46 ), ( b \"draped_box\" , 48 ), ( b \"exchange\" , 50 ), ( b \"fleur\" , 52 ), ( b \"gobbler\" , 54 ), ( b \"gumby\" , 56 ), ( b \"hand1\" , 58 ), ( b \"hand2\" , 60 ), ( b \"heart\" , 62 ), ( b \"icon\" , 64 ), ( b \"iron_cross\" , 66 ), ( b \"left_ptr\" , 68 ), ( b \"left_side\" , 70 ), ( b \"left_tee\" , 72 ), ( b \"leftbutton\" , 74 ), ( b \"ll_angle\" , 76 ), ( b \"lr_angle\" , 78 ), ( b \"man\" , 80 ), ( b \"middlebutton\" , 82 ), ( b \"mouse\" , 84 ), ( b \"pencil\" , 86 ), ( b \"pirate\" , 88 ), ( b \"plus\" , 90 ), ( b \"question_arrow\" , 92 ), ( b \"right_ptr\" , 94 ), ( b \"right_side\" , 96 ), ( b \"right_tee\" , 98 ), ( b \"rightbutton\" , 100 ), ( b \"rtl_logo\" , 102 ), ( b \"sailboat\" , 104 ), ( b \"sb_down_arrow\" , 106 ), ( b \"sb_h_double_arrow\" , 108 ), ( b \"sb_left_arrow\" , 110 ), ( b \"sb_right_arrow\" , 112 ), ( b \"sb_up_arrow\" , 114 ), ( b \"sb_v_double_arrow\" , 116 ), ( b \"shuttle\" , 118 ), ( b \"sizing\" , 120 ), ( b \"spider\" , 122 ), ( b \"spraycan\" , 124 ), ( b \"star\" , 126 ), ( b \"target\" , 128 ), ( b \"tcross\" , 130 ), ( b \"top_left_arrow\" , 132 ), ( b \"top_left_corner\" , 134 ), ( b \"top_right_corner\" , 136 ), ( b \"top_side\" , 138 ), ( b \"top_tee\" , 140 ), ( b \"trek\" , 142 ), ( b \"ul_angle\" , 144 ), ( b \"umbrella\" , 146 ), ( b \"ur_angle\" , 148 ), ( b \"watch\" , 150 ), ( b \"xterm\" , 152 ), ) self . xcursor = self . _setup_xcursor_binding () for name , cursor_font in cursors : self . _new ( name , cursor_font ) if self . xcursor : self . xcursor . xcb_cursor_context_free ( self . _cursor_ctx [ 0 ]) get_font_cursor ( name , cursor_font ) Get the cursor from the font, used as a fallback if xcb-util-cursor is not installed Source code in libqtile/backend/x11/xcursors.py 131 132 133 134 135 136 137 138 139 140 141 142 def get_font_cursor ( self , name , cursor_font ): \"\"\" Get the cursor from the font, used as a fallback if xcb-util-cursor is not installed \"\"\" fid = self . conn . conn . generate_id () self . conn . conn . core . OpenFont ( fid , len ( \"cursor\" ), \"cursor\" ) cursor = self . conn . conn . generate_id () self . conn . conn . core . CreateGlyphCursor ( cursor , fid , fid , cursor_font , cursor_font + 1 , 0 , 0 , 0 , 65535 , 65535 , 65535 ) return cursor get_xcursor ( name ) Get the cursor using xcb-util-cursor, so we support themed cursors Source code in libqtile/backend/x11/xcursors.py 124 125 126 127 128 129 def get_xcursor ( self , name ): \"\"\" Get the cursor using xcb-util-cursor, so we support themed cursors \"\"\" cursor = self . xcursor . xcb_cursor_load_cursor ( self . _cursor_ctx [ 0 ], name ) return cursor","title":"xcursors"},{"location":"reference/libqtile/backend/x11/xcursors/#libqtile.backend.x11.xcursors.Cursors","text":"Bases: dict Source code in libqtile/backend/x11/xcursors.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __init__ ( self , conn ): self . conn = conn cursors = ( ( b \"X_cursor\" , 0 ), ( b \"arrow\" , 2 ), ( b \"based_arrow_down\" , 4 ), ( b \"based_arrow_up\" , 6 ), ( b \"boat\" , 8 ), ( b \"bogosity\" , 10 ), ( b \"bottom_left_corner\" , 12 ), ( b \"bottom_right_corner\" , 14 ), ( b \"bottom_side\" , 16 ), ( b \"bottom_tee\" , 18 ), ( b \"box_spiral\" , 20 ), ( b \"center_ptr\" , 22 ), ( b \"circle\" , 24 ), ( b \"clock\" , 26 ), ( b \"coffee_mug\" , 28 ), ( b \"cross\" , 30 ), ( b \"cross_reverse\" , 32 ), ( b \"crosshair\" , 34 ), ( b \"diamond_cross\" , 36 ), ( b \"dot\" , 38 ), ( b \"dotbox\" , 40 ), ( b \"double_arrow\" , 42 ), ( b \"draft_large\" , 44 ), ( b \"draft_small\" , 46 ), ( b \"draped_box\" , 48 ), ( b \"exchange\" , 50 ), ( b \"fleur\" , 52 ), ( b \"gobbler\" , 54 ), ( b \"gumby\" , 56 ), ( b \"hand1\" , 58 ), ( b \"hand2\" , 60 ), ( b \"heart\" , 62 ), ( b \"icon\" , 64 ), ( b \"iron_cross\" , 66 ), ( b \"left_ptr\" , 68 ), ( b \"left_side\" , 70 ), ( b \"left_tee\" , 72 ), ( b \"leftbutton\" , 74 ), ( b \"ll_angle\" , 76 ), ( b \"lr_angle\" , 78 ), ( b \"man\" , 80 ), ( b \"middlebutton\" , 82 ), ( b \"mouse\" , 84 ), ( b \"pencil\" , 86 ), ( b \"pirate\" , 88 ), ( b \"plus\" , 90 ), ( b \"question_arrow\" , 92 ), ( b \"right_ptr\" , 94 ), ( b \"right_side\" , 96 ), ( b \"right_tee\" , 98 ), ( b \"rightbutton\" , 100 ), ( b \"rtl_logo\" , 102 ), ( b \"sailboat\" , 104 ), ( b \"sb_down_arrow\" , 106 ), ( b \"sb_h_double_arrow\" , 108 ), ( b \"sb_left_arrow\" , 110 ), ( b \"sb_right_arrow\" , 112 ), ( b \"sb_up_arrow\" , 114 ), ( b \"sb_v_double_arrow\" , 116 ), ( b \"shuttle\" , 118 ), ( b \"sizing\" , 120 ), ( b \"spider\" , 122 ), ( b \"spraycan\" , 124 ), ( b \"star\" , 126 ), ( b \"target\" , 128 ), ( b \"tcross\" , 130 ), ( b \"top_left_arrow\" , 132 ), ( b \"top_left_corner\" , 134 ), ( b \"top_right_corner\" , 136 ), ( b \"top_side\" , 138 ), ( b \"top_tee\" , 140 ), ( b \"trek\" , 142 ), ( b \"ul_angle\" , 144 ), ( b \"umbrella\" , 146 ), ( b \"ur_angle\" , 148 ), ( b \"watch\" , 150 ), ( b \"xterm\" , 152 ), ) self . xcursor = self . _setup_xcursor_binding () for name , cursor_font in cursors : self . _new ( name , cursor_font ) if self . xcursor : self . xcursor . xcb_cursor_context_free ( self . _cursor_ctx [ 0 ])","title":"Cursors"},{"location":"reference/libqtile/backend/x11/xcursors/#libqtile.backend.x11.xcursors.Cursors.get_font_cursor","text":"Get the cursor from the font, used as a fallback if xcb-util-cursor is not installed Source code in libqtile/backend/x11/xcursors.py 131 132 133 134 135 136 137 138 139 140 141 142 def get_font_cursor ( self , name , cursor_font ): \"\"\" Get the cursor from the font, used as a fallback if xcb-util-cursor is not installed \"\"\" fid = self . conn . conn . generate_id () self . conn . conn . core . OpenFont ( fid , len ( \"cursor\" ), \"cursor\" ) cursor = self . conn . conn . generate_id () self . conn . conn . core . CreateGlyphCursor ( cursor , fid , fid , cursor_font , cursor_font + 1 , 0 , 0 , 0 , 65535 , 65535 , 65535 ) return cursor","title":"get_font_cursor()"},{"location":"reference/libqtile/backend/x11/xcursors/#libqtile.backend.x11.xcursors.Cursors.get_xcursor","text":"Get the cursor using xcb-util-cursor, so we support themed cursors Source code in libqtile/backend/x11/xcursors.py 124 125 126 127 128 129 def get_xcursor ( self , name ): \"\"\" Get the cursor using xcb-util-cursor, so we support themed cursors \"\"\" cursor = self . xcursor . xcb_cursor_load_cursor ( self . _cursor_ctx [ 0 ], name ) return cursor","title":"get_xcursor()"},{"location":"reference/libqtile/backend/x11/xcursors_ffi_build/","text":"","title":"xcursors_ffi_build"},{"location":"reference/libqtile/backend/x11/xkeysyms/","text":"","title":"xkeysyms"},{"location":"reference/libqtile/command/","text":"The deprecated lazy command objects","title":"command"},{"location":"reference/libqtile/command/base/","text":"The objects in the command graph and command resolution on the objects CommandError Bases: Exception Error raised in resolving a command CommandException Bases: Exception Error raised while executing a command CommandObject Base class for objects that expose commands Any command to be exposed should be decorated with @expose_command() (classes that are not explicitly inheriting from CommandObject will need to import the module) A CommandObject should also implement ._items() and ._select() methods (c.f. docstring for .items() and .select() ). command ( name ) Return the command with the given name Parameters: Name Type Description Default name str The name of the command to fetch. required Source code in libqtile/command/base.py 247 248 249 250 251 252 253 254 255 256 def command ( self , name : str ) -> Callable | None : \"\"\"Return the command with the given name Parameters ---------- name: str The name of the command to fetch. \"\"\" return self . _commands . get ( name ) commands () Returns a list of possible commands for this object Used by qsh for command completion and online help Source code in libqtile/command/base.py 285 286 287 288 289 290 291 292 @expose_command () def commands ( self ) -> list [ str ]: \"\"\" Returns a list of possible commands for this object Used by __qsh__ for command completion and online help \"\"\" return sorted ([ cmd for cmd in self . _commands ]) doc ( name ) Returns the documentation for a specified command name Used by qsh to provide online help. Source code in libqtile/command/base.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 @expose_command () def doc ( self , name ) -> str : \"\"\"Returns the documentation for a specified command name Used by __qsh__ to provide online help. \"\"\" if name in self . commands (): command = self . command ( name ) assert command signature = self . _get_command_signature ( command ) spec = name + signature htext = inspect . getdoc ( command ) or \"\" return spec + \" \\n \" + htext raise CommandError ( \"No such command: %s \" % name ) eval ( code ) Evaluates code in the same context as this function Return value is tuple (success, result) , success being a boolean and result being a string representing the return value of eval, or None if exec was used instead. Source code in libqtile/command/base.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 @expose_command () def eval ( self , code : str ) -> tuple [ bool , str | None ]: \"\"\"Evaluates code in the same context as this function Return value is tuple `(success, result)`, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead. \"\"\" try : globals_ = vars ( sys . modules [ self . __module__ ]) try : return True , str ( eval ( code , globals_ , locals ())) except SyntaxError : exec ( code , globals_ , locals ()) return True , None except Exception : error = traceback . format_exc () . strip () . split ( \" \\n \" )[ - 1 ] return False , error function ( function , * args , ** kwargs ) Call a function with current object as argument Source code in libqtile/command/base.py 337 338 339 340 341 342 343 344 @expose_command () def function ( self , function , * args , ** kwargs ) -> None : \"\"\"Call a function with current object as argument\"\"\" try : function ( self , * args , ** kwargs ) except Exception : error = traceback . format_exc () logger . error ( 'Exception calling \" %s \": \\n %s ' , function , error ) items ( name ) Build a list of contained items for the given item class. Exposing this allows qsh to navigate the object graph. Returns a tuple (root, items) for the specified item class, where: root: True if this class accepts a \"naked\" specification without an item seletion (e.g. \"layout\" defaults to current layout), and False if it does not (e.g. no default \"widget\"). items: a list of contained items Source code in libqtile/command/base.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @expose_command () def items ( self , name : str ) -> tuple [ bool , list [ str | int ] | None ]: \"\"\" Build a list of contained items for the given item class. Exposing this allows __qsh__ to navigate the object graph. Returns a tuple `(root, items)` for the specified item class, where: root: True if this class accepts a \"naked\" specification without an item seletion (e.g. \"layout\" defaults to current layout), and False if it does not (e.g. no default \"widget\"). items: a list of contained items \"\"\" ret = self . _items ( name ) if ret is None : # Not finding information for a particular item class is OK here; # we don't expect layouts to have a window, etc. return False , None return ret select ( selectors ) Return a selected object Recursively finds an object specified by a list of (name, selector) items. Raises SelectError if the object does not exist. Source code in libqtile/command/base.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def select ( self , selectors : list [ SelectorType ]) -> CommandObject : \"\"\"Return a selected object Recursively finds an object specified by a list of `(name, selector)` items. Raises SelectError if the object does not exist. \"\"\" obj : CommandObject = self for name , selector in selectors : root , items = obj . items ( name ) # if non-root object and no selector given if root is False and selector is None : raise SelectError ( \"\" , name , selectors ) # if no items in container, but selector is given if items is None and selector is not None : raise SelectError ( \"\" , name , selectors ) # if selector is not in the list of contained items if items is not None and selector and selector not in items : raise SelectError ( \"\" , name , selectors ) maybe_obj = obj . _select ( name , selector ) if maybe_obj is None : raise SelectError ( \"\" , name , selectors ) obj = maybe_obj return obj SelectError ( err_string , name , selectors ) Bases: Exception Error raised in resolving a command graph object Source code in libqtile/command/base.py 92 93 94 95 def __init__ ( self , err_string : str , name : str , selectors : list [ SelectorType ]): super () . __init__ ( \" {} , name: {} , selectors: {} \" . format ( err_string , name , selectors )) self . name = name self . selectors = selectors expose_command ( name = None ) Decorator to expose methods to the command interface. The exposed command will have the name of the defined method. Methods can also be exposed via multiple names by passing the names to this decorator. e.g. if a layout wants \"up\" and \"previous\" to call the same method: @expose_command(\"previous\") def up(self): ... up will be exposed as up and previous . Multiple names can be passed as a list. Source code in libqtile/command/base.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def expose_command ( name : Callable | str | list [ str ] | None = None ) -> Callable : \"\"\" Decorator to expose methods to the command interface. The exposed command will have the name of the defined method. Methods can also be exposed via multiple names by passing the names to this decorator. e.g. if a layout wants \"up\" and \"previous\" to call the same method: @expose_command(\"previous\") def up(self): ... `up` will be exposed as `up` and `previous`. Multiple names can be passed as a list. \"\"\" def wrapper ( func : Callable ): setattr ( func , \"_cmd\" , True ) if name is not None : if not hasattr ( func , \"_mapping\" ): setattr ( func , \"_mapping\" , list ()) if isinstance ( name , list ): func . _mapping += name # type:ignore elif isinstance ( name , str ): func . _mapping . append ( name ) # type:ignore else : logger . error ( \"Unexpected value received in command decorator: %s \" , name ) return func # If the decorator is added with no parentheses then we should treat it # as if it had been i.e. expose the decorated method if callable ( name ): func = name name = None return wrapper ( func ) return wrapper","title":"base"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandError","text":"Bases: Exception Error raised in resolving a command","title":"CommandError"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandException","text":"Bases: Exception Error raised while executing a command","title":"CommandException"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject","text":"Base class for objects that expose commands Any command to be exposed should be decorated with @expose_command() (classes that are not explicitly inheriting from CommandObject will need to import the module) A CommandObject should also implement ._items() and ._select() methods (c.f. docstring for .items() and .select() ).","title":"CommandObject"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.command","text":"Return the command with the given name Parameters: Name Type Description Default name str The name of the command to fetch. required Source code in libqtile/command/base.py 247 248 249 250 251 252 253 254 255 256 def command ( self , name : str ) -> Callable | None : \"\"\"Return the command with the given name Parameters ---------- name: str The name of the command to fetch. \"\"\" return self . _commands . get ( name )","title":"command()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.commands","text":"Returns a list of possible commands for this object Used by qsh for command completion and online help Source code in libqtile/command/base.py 285 286 287 288 289 290 291 292 @expose_command () def commands ( self ) -> list [ str ]: \"\"\" Returns a list of possible commands for this object Used by __qsh__ for command completion and online help \"\"\" return sorted ([ cmd for cmd in self . _commands ])","title":"commands()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.doc","text":"Returns the documentation for a specified command name Used by qsh to provide online help. Source code in libqtile/command/base.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 @expose_command () def doc ( self , name ) -> str : \"\"\"Returns the documentation for a specified command name Used by __qsh__ to provide online help. \"\"\" if name in self . commands (): command = self . command ( name ) assert command signature = self . _get_command_signature ( command ) spec = name + signature htext = inspect . getdoc ( command ) or \"\" return spec + \" \\n \" + htext raise CommandError ( \"No such command: %s \" % name )","title":"doc()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.eval","text":"Evaluates code in the same context as this function Return value is tuple (success, result) , success being a boolean and result being a string representing the return value of eval, or None if exec was used instead. Source code in libqtile/command/base.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 @expose_command () def eval ( self , code : str ) -> tuple [ bool , str | None ]: \"\"\"Evaluates code in the same context as this function Return value is tuple `(success, result)`, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead. \"\"\" try : globals_ = vars ( sys . modules [ self . __module__ ]) try : return True , str ( eval ( code , globals_ , locals ())) except SyntaxError : exec ( code , globals_ , locals ()) return True , None except Exception : error = traceback . format_exc () . strip () . split ( \" \\n \" )[ - 1 ] return False , error","title":"eval()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.function","text":"Call a function with current object as argument Source code in libqtile/command/base.py 337 338 339 340 341 342 343 344 @expose_command () def function ( self , function , * args , ** kwargs ) -> None : \"\"\"Call a function with current object as argument\"\"\" try : function ( self , * args , ** kwargs ) except Exception : error = traceback . format_exc () logger . error ( 'Exception calling \" %s \": \\n %s ' , function , error )","title":"function()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.items","text":"Build a list of contained items for the given item class. Exposing this allows qsh to navigate the object graph. Returns a tuple (root, items) for the specified item class, where: root: True if this class accepts a \"naked\" specification without an item seletion (e.g. \"layout\" defaults to current layout), and False if it does not (e.g. no default \"widget\"). items: a list of contained items Source code in libqtile/command/base.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @expose_command () def items ( self , name : str ) -> tuple [ bool , list [ str | int ] | None ]: \"\"\" Build a list of contained items for the given item class. Exposing this allows __qsh__ to navigate the object graph. Returns a tuple `(root, items)` for the specified item class, where: root: True if this class accepts a \"naked\" specification without an item seletion (e.g. \"layout\" defaults to current layout), and False if it does not (e.g. no default \"widget\"). items: a list of contained items \"\"\" ret = self . _items ( name ) if ret is None : # Not finding information for a particular item class is OK here; # we don't expect layouts to have a window, etc. return False , None return ret","title":"items()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.CommandObject.select","text":"Return a selected object Recursively finds an object specified by a list of (name, selector) items. Raises SelectError if the object does not exist. Source code in libqtile/command/base.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def select ( self , selectors : list [ SelectorType ]) -> CommandObject : \"\"\"Return a selected object Recursively finds an object specified by a list of `(name, selector)` items. Raises SelectError if the object does not exist. \"\"\" obj : CommandObject = self for name , selector in selectors : root , items = obj . items ( name ) # if non-root object and no selector given if root is False and selector is None : raise SelectError ( \"\" , name , selectors ) # if no items in container, but selector is given if items is None and selector is not None : raise SelectError ( \"\" , name , selectors ) # if selector is not in the list of contained items if items is not None and selector and selector not in items : raise SelectError ( \"\" , name , selectors ) maybe_obj = obj . _select ( name , selector ) if maybe_obj is None : raise SelectError ( \"\" , name , selectors ) obj = maybe_obj return obj","title":"select()"},{"location":"reference/libqtile/command/base/#libqtile.command.base.SelectError","text":"Bases: Exception Error raised in resolving a command graph object Source code in libqtile/command/base.py 92 93 94 95 def __init__ ( self , err_string : str , name : str , selectors : list [ SelectorType ]): super () . __init__ ( \" {} , name: {} , selectors: {} \" . format ( err_string , name , selectors )) self . name = name self . selectors = selectors","title":"SelectError"},{"location":"reference/libqtile/command/base/#libqtile.command.base.expose_command","text":"Decorator to expose methods to the command interface. The exposed command will have the name of the defined method. Methods can also be exposed via multiple names by passing the names to this decorator. e.g. if a layout wants \"up\" and \"previous\" to call the same method: @expose_command(\"previous\") def up(self): ... up will be exposed as up and previous . Multiple names can be passed as a list. Source code in libqtile/command/base.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def expose_command ( name : Callable | str | list [ str ] | None = None ) -> Callable : \"\"\" Decorator to expose methods to the command interface. The exposed command will have the name of the defined method. Methods can also be exposed via multiple names by passing the names to this decorator. e.g. if a layout wants \"up\" and \"previous\" to call the same method: @expose_command(\"previous\") def up(self): ... `up` will be exposed as `up` and `previous`. Multiple names can be passed as a list. \"\"\" def wrapper ( func : Callable ): setattr ( func , \"_cmd\" , True ) if name is not None : if not hasattr ( func , \"_mapping\" ): setattr ( func , \"_mapping\" , list ()) if isinstance ( name , list ): func . _mapping += name # type:ignore elif isinstance ( name , str ): func . _mapping . append ( name ) # type:ignore else : logger . error ( \"Unexpected value received in command decorator: %s \" , name ) return func # If the decorator is added with no parentheses then we should treat it # as if it had been i.e. expose the decorated method if callable ( name ): func = name name = None return wrapper ( func ) return wrapper","title":"expose_command()"},{"location":"reference/libqtile/command/client/","text":"The clients that expose the command graph of a given command interface The clients give the ability to navigate the command graph while providing name resolution with the given command graph interface. When writing functionality that interacts with qtile objects, it should favor using the command graph clients to do this interaction. CommandClient ( command = None , * , current_node = None ) The object that resolves the commands Exposes a similar API to the command graph, but performs resolution of objects. Any navigation done on the command graph is resolved at the point it is invoked. This command resolution is done via the command interface. Parameters: Name Type Description Default command CommandInterface | None The object that is used to resolve command graph calls, as well as navigate the command graph. None current_node CommandGraphNode | None The current node that is pointed to in the command graph. If not specified, the command graph root is used. None Source code in libqtile/command/client.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , command : CommandInterface | None = None , * , current_node : CommandGraphNode | None = None , ) -> None : \"\"\"A client that resolves calls through the command object interface Exposes a similar API to the command graph, but performs resolution of objects. Any navigation done on the command graph is resolved at the point it is invoked. This command resolution is done via the command interface. Parameters ---------- command: CommandInterface The object that is used to resolve command graph calls, as well as navigate the command graph. current_node: CommandGraphNode The current node that is pointed to in the command graph. If not specified, the command graph root is used. \"\"\" if command is None : command = IPCCommandInterface ( Client ( find_sockfile ())) self . _command = command self . _current_node = current_node if current_node is not None else CommandGraphRoot () call ( name , * args , ** kwargs ) Resolve and invoke the call into the command graph Parameters: Name Type Description Default name str The name of the command to resolve in the command graph. required args The arguments to pass into the call invocation. required kwargs The keyword arguments to pass into the call invocation. required Returns: Type Description The output returned from the function call. Source code in libqtile/command/client.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def call ( self , name : str , * args , ** kwargs ) -> Any : \"\"\"Resolve and invoke the call into the command graph Parameters ---------- name: str The name of the command to resolve in the command graph. args: The arguments to pass into the call invocation. kwargs: The keyword arguments to pass into the call invocation. Returns ------- The output returned from the function call. \"\"\" if name not in self . commands : raise SelectError ( \"Not valid child or command\" , name , self . _current_node . selectors ) call = self . _current_node . call ( name ) return self . _command . execute ( call , args , kwargs ) children () property Get the children of the current location in the command graph Source code in libqtile/command/client.py 133 134 135 136 @property def children ( self ) -> list [ str ]: \"\"\"Get the children of the current location in the command graph\"\"\" return self . _current_node . children commands () property Get the commands available on the current object Source code in libqtile/command/client.py 142 143 144 145 146 @property def commands ( self ) -> list [ str ]: \"\"\"Get the commands available on the current object\"\"\" command_call = self . _current_node . call ( \"commands\" ) return self . _command . execute ( command_call , (), {}) items ( name ) Get the available items Source code in libqtile/command/client.py 148 149 150 151 def items ( self , name : str ) -> tuple [ bool , list [ str | int ]]: \"\"\"Get the available items\"\"\" items_call = self . _current_node . call ( \"items\" ) return self . _command . execute ( items_call , ( name ,), {}) navigate ( name , selector ) Resolve the given object in the command graph Parameters: Name Type Description Default name str The name of the command graph object to resolve. required selector str | None If given, the selector to use to select the next object, and if None, then selects the default object. required Returns: Type Description CommandClient The client with the given command graph object resolved. Source code in libqtile/command/client.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def navigate ( self , name : str , selector : str | None ) -> CommandClient : \"\"\"Resolve the given object in the command graph Parameters ---------- name: str The name of the command graph object to resolve. selector: str | None If given, the selector to use to select the next object, and if None, then selects the default object. Returns ------- CommandClient The client with the given command graph object resolved. \"\"\" if name not in self . children : raise SelectError ( \"Not valid child\" , name , self . _current_node . selectors ) normalized_selector = _normalize_item ( name , selector ) if selector is not None else None if normalized_selector is not None : if not self . _command . has_item ( self . _current_node , name , normalized_selector ): raise SelectError ( \"Item not available in object\" , name , self . _current_node . selectors ) next_node = self . _current_node . navigate ( name , normalized_selector ) return self . __class__ ( self . _command , current_node = next_node ) parent () property Get the parent of the current client Source code in libqtile/command/client.py 158 159 160 161 162 163 @property def parent ( self ) -> CommandClient : \"\"\"Get the parent of the current client\"\"\" if self . _current_node . parent is None : raise SelectError ( \"\" , \"\" , self . _current_node . selectors ) return self . __class__ ( self . _command , current_node = self . _current_node . parent ) root () property Get the root of the command graph Source code in libqtile/command/client.py 153 154 155 156 @property def root ( self ) -> CommandClient : \"\"\"Get the root of the command graph\"\"\" return self . __class__ ( self . _command ) InteractiveCommandClient ( command = None , * , current_node = None ) A command graph client that can be used to easily resolve elements interactively Exposes the command graph API in such a way that it can be traversed directly on this object. The command resolution for this object is done via the command interface. Parameters: Name Type Description Default command CommandInterface | None The object that is used to resolve command graph calls, as well as navigate the command graph. None current_node GraphType | None The current node that is pointed to in the command graph. If not specified, the command graph root is used. None Source code in libqtile/command/client.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def __init__ ( self , command : CommandInterface | None = None , * , current_node : GraphType | None = None ) -> None : \"\"\"An interactive client that resolves calls through the gives client Exposes the command graph API in such a way that it can be traversed directly on this object. The command resolution for this object is done via the command interface. Parameters ---------- command: CommandInterface The object that is used to resolve command graph calls, as well as navigate the command graph. current_node: CommandGraphNode The current node that is pointed to in the command graph. If not specified, the command graph root is used. \"\"\" if command is None : command = IPCCommandInterface ( Client ( find_sockfile ())) self . _command = command self . _current_node = current_node if current_node is not None else CommandGraphRoot () __call__ ( * args , ** kwargs ) When the client has navigated to a command, execute it Source code in libqtile/command/client.py 194 195 196 197 198 199 def __call__ ( self , * args , ** kwargs ) -> Any : \"\"\"When the client has navigated to a command, execute it\"\"\" if not isinstance ( self . _current_node , CommandGraphCall ): raise SelectError ( \"Invalid call\" , \"\" , self . _current_node . selectors ) return self . _command . execute ( self . _current_node , args , kwargs ) __getattr__ ( name ) Get the child element of the currently selected object Resolve the element specified by the given name, either the child object, or the command on the current object. Parameters: Name Type Description Default name str The name of the element to resolve required Return InteractiveCommandClient The client navigated to the specified name. Will respresent either a command graph node (if the name is a valid child) or a command graph call (if the name is a valid command). Source code in libqtile/command/client.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def __getattr__ ( self , name : str ) -> InteractiveCommandClient : \"\"\"Get the child element of the currently selected object Resolve the element specified by the given name, either the child object, or the command on the current object. Parameters ---------- name: str The name of the element to resolve Return ------ InteractiveCommandClient The client navigated to the specified name. Will respresent either a command graph node (if the name is a valid child) or a command graph call (if the name is a valid command). \"\"\" # Python's help() command will try to look up __name__ and __origin__ so we # need to handle these explicitly otherwise they'll result in a SelectError # which help() does not expect. if name in [ \"__name__\" , \"__origin__\" ]: raise AttributeError if isinstance ( self . _current_node , CommandGraphCall ): raise SelectError ( \"Cannot select children of call\" , name , self . _current_node . selectors ) # we do not know if the name is a command to be executed, or an object # to navigate to if name not in self . _current_node . children : # we are going to resolve a command, check that the command is valid if not self . _command . has_command ( self . _current_node , name ): raise SelectError ( \"Not valid child or command\" , name , self . _current_node . selectors ) call_object = self . _current_node . call ( name ) return self . __class__ ( self . _command , current_node = call_object ) next_node = self . _current_node . navigate ( name , None ) return self . __class__ ( self . _command , current_node = next_node ) __getitem__ ( name ) Get the selected element of the currently selected object From the current command graph object, select the instance with the given name. Parameters: Name Type Description Default name str | int The name, or index if it's of int type, of the item to resolve required Return InteractiveCommandClient The current client, navigated to the specified command graph object. Source code in libqtile/command/client.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def __getitem__ ( self , name : str | int ) -> InteractiveCommandClient : \"\"\"Get the selected element of the currently selected object From the current command graph object, select the instance with the given name. Parameters ---------- name: str The name, or index if it's of int type, of the item to resolve Return ------ InteractiveCommandClient The current client, navigated to the specified command graph object. \"\"\" if isinstance ( self . _current_node , CommandGraphRoot ): raise KeyError ( \"Root node has no available items\" , name , self . _current_node . selectors ) if not isinstance ( self . _current_node , CommandGraphObject ): raise SelectError ( \"Unable to make selection on current node\" , str ( name ), self . _current_node . selectors , ) if self . _current_node . selector is not None : raise SelectError ( \"Selection already made\" , str ( name ), self . _current_node . selectors ) # check the selection is valid in the server-side qtile manager if not self . _command . has_item ( self . _current_node . parent , self . _current_node . object_type , name ): raise SelectError ( \"Item not available in object\" , str ( name ), self . _current_node . selectors ) next_node = self . _current_node . parent . navigate ( self . _current_node . object_type , name ) return self . __class__ ( self . _command , current_node = next_node ) normalize_item ( item ) Normalize the item according to Qtile._items(). Source code in libqtile/command/client.py 286 287 288 289 290 291 292 293 def normalize_item ( self , item : str ) -> str | int : \"Normalize the item according to Qtile._items().\" object_type = ( self . _current_node . object_type if isinstance ( self . _current_node , CommandGraphObject ) else None ) return _normalize_item ( object_type , item )","title":"client"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient","text":"The object that resolves the commands Exposes a similar API to the command graph, but performs resolution of objects. Any navigation done on the command graph is resolved at the point it is invoked. This command resolution is done via the command interface. Parameters: Name Type Description Default command CommandInterface | None The object that is used to resolve command graph calls, as well as navigate the command graph. None current_node CommandGraphNode | None The current node that is pointed to in the command graph. If not specified, the command graph root is used. None Source code in libqtile/command/client.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , command : CommandInterface | None = None , * , current_node : CommandGraphNode | None = None , ) -> None : \"\"\"A client that resolves calls through the command object interface Exposes a similar API to the command graph, but performs resolution of objects. Any navigation done on the command graph is resolved at the point it is invoked. This command resolution is done via the command interface. Parameters ---------- command: CommandInterface The object that is used to resolve command graph calls, as well as navigate the command graph. current_node: CommandGraphNode The current node that is pointed to in the command graph. If not specified, the command graph root is used. \"\"\" if command is None : command = IPCCommandInterface ( Client ( find_sockfile ())) self . _command = command self . _current_node = current_node if current_node is not None else CommandGraphRoot ()","title":"CommandClient"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.call","text":"Resolve and invoke the call into the command graph Parameters: Name Type Description Default name str The name of the command to resolve in the command graph. required args The arguments to pass into the call invocation. required kwargs The keyword arguments to pass into the call invocation. required Returns: Type Description The output returned from the function call. Source code in libqtile/command/client.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def call ( self , name : str , * args , ** kwargs ) -> Any : \"\"\"Resolve and invoke the call into the command graph Parameters ---------- name: str The name of the command to resolve in the command graph. args: The arguments to pass into the call invocation. kwargs: The keyword arguments to pass into the call invocation. Returns ------- The output returned from the function call. \"\"\" if name not in self . commands : raise SelectError ( \"Not valid child or command\" , name , self . _current_node . selectors ) call = self . _current_node . call ( name ) return self . _command . execute ( call , args , kwargs )","title":"call()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.children","text":"Get the children of the current location in the command graph Source code in libqtile/command/client.py 133 134 135 136 @property def children ( self ) -> list [ str ]: \"\"\"Get the children of the current location in the command graph\"\"\" return self . _current_node . children","title":"children()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.commands","text":"Get the commands available on the current object Source code in libqtile/command/client.py 142 143 144 145 146 @property def commands ( self ) -> list [ str ]: \"\"\"Get the commands available on the current object\"\"\" command_call = self . _current_node . call ( \"commands\" ) return self . _command . execute ( command_call , (), {})","title":"commands()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.items","text":"Get the available items Source code in libqtile/command/client.py 148 149 150 151 def items ( self , name : str ) -> tuple [ bool , list [ str | int ]]: \"\"\"Get the available items\"\"\" items_call = self . _current_node . call ( \"items\" ) return self . _command . execute ( items_call , ( name ,), {})","title":"items()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.navigate","text":"Resolve the given object in the command graph Parameters: Name Type Description Default name str The name of the command graph object to resolve. required selector str | None If given, the selector to use to select the next object, and if None, then selects the default object. required Returns: Type Description CommandClient The client with the given command graph object resolved. Source code in libqtile/command/client.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def navigate ( self , name : str , selector : str | None ) -> CommandClient : \"\"\"Resolve the given object in the command graph Parameters ---------- name: str The name of the command graph object to resolve. selector: str | None If given, the selector to use to select the next object, and if None, then selects the default object. Returns ------- CommandClient The client with the given command graph object resolved. \"\"\" if name not in self . children : raise SelectError ( \"Not valid child\" , name , self . _current_node . selectors ) normalized_selector = _normalize_item ( name , selector ) if selector is not None else None if normalized_selector is not None : if not self . _command . has_item ( self . _current_node , name , normalized_selector ): raise SelectError ( \"Item not available in object\" , name , self . _current_node . selectors ) next_node = self . _current_node . navigate ( name , normalized_selector ) return self . __class__ ( self . _command , current_node = next_node )","title":"navigate()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.parent","text":"Get the parent of the current client Source code in libqtile/command/client.py 158 159 160 161 162 163 @property def parent ( self ) -> CommandClient : \"\"\"Get the parent of the current client\"\"\" if self . _current_node . parent is None : raise SelectError ( \"\" , \"\" , self . _current_node . selectors ) return self . __class__ ( self . _command , current_node = self . _current_node . parent )","title":"parent()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.CommandClient.root","text":"Get the root of the command graph Source code in libqtile/command/client.py 153 154 155 156 @property def root ( self ) -> CommandClient : \"\"\"Get the root of the command graph\"\"\" return self . __class__ ( self . _command )","title":"root()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient","text":"A command graph client that can be used to easily resolve elements interactively Exposes the command graph API in such a way that it can be traversed directly on this object. The command resolution for this object is done via the command interface. Parameters: Name Type Description Default command CommandInterface | None The object that is used to resolve command graph calls, as well as navigate the command graph. None current_node GraphType | None The current node that is pointed to in the command graph. If not specified, the command graph root is used. None Source code in libqtile/command/client.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def __init__ ( self , command : CommandInterface | None = None , * , current_node : GraphType | None = None ) -> None : \"\"\"An interactive client that resolves calls through the gives client Exposes the command graph API in such a way that it can be traversed directly on this object. The command resolution for this object is done via the command interface. Parameters ---------- command: CommandInterface The object that is used to resolve command graph calls, as well as navigate the command graph. current_node: CommandGraphNode The current node that is pointed to in the command graph. If not specified, the command graph root is used. \"\"\" if command is None : command = IPCCommandInterface ( Client ( find_sockfile ())) self . _command = command self . _current_node = current_node if current_node is not None else CommandGraphRoot ()","title":"InteractiveCommandClient"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient.__call__","text":"When the client has navigated to a command, execute it Source code in libqtile/command/client.py 194 195 196 197 198 199 def __call__ ( self , * args , ** kwargs ) -> Any : \"\"\"When the client has navigated to a command, execute it\"\"\" if not isinstance ( self . _current_node , CommandGraphCall ): raise SelectError ( \"Invalid call\" , \"\" , self . _current_node . selectors ) return self . _command . execute ( self . _current_node , args , kwargs )","title":"__call__()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient.__getattr__","text":"Get the child element of the currently selected object Resolve the element specified by the given name, either the child object, or the command on the current object. Parameters: Name Type Description Default name str The name of the element to resolve required","title":"__getattr__()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient.__getattr__--return","text":"InteractiveCommandClient The client navigated to the specified name. Will respresent either a command graph node (if the name is a valid child) or a command graph call (if the name is a valid command). Source code in libqtile/command/client.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def __getattr__ ( self , name : str ) -> InteractiveCommandClient : \"\"\"Get the child element of the currently selected object Resolve the element specified by the given name, either the child object, or the command on the current object. Parameters ---------- name: str The name of the element to resolve Return ------ InteractiveCommandClient The client navigated to the specified name. Will respresent either a command graph node (if the name is a valid child) or a command graph call (if the name is a valid command). \"\"\" # Python's help() command will try to look up __name__ and __origin__ so we # need to handle these explicitly otherwise they'll result in a SelectError # which help() does not expect. if name in [ \"__name__\" , \"__origin__\" ]: raise AttributeError if isinstance ( self . _current_node , CommandGraphCall ): raise SelectError ( \"Cannot select children of call\" , name , self . _current_node . selectors ) # we do not know if the name is a command to be executed, or an object # to navigate to if name not in self . _current_node . children : # we are going to resolve a command, check that the command is valid if not self . _command . has_command ( self . _current_node , name ): raise SelectError ( \"Not valid child or command\" , name , self . _current_node . selectors ) call_object = self . _current_node . call ( name ) return self . __class__ ( self . _command , current_node = call_object ) next_node = self . _current_node . navigate ( name , None ) return self . __class__ ( self . _command , current_node = next_node )","title":"Return"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient.__getitem__","text":"Get the selected element of the currently selected object From the current command graph object, select the instance with the given name. Parameters: Name Type Description Default name str | int The name, or index if it's of int type, of the item to resolve required","title":"__getitem__()"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient.__getitem__--return","text":"InteractiveCommandClient The current client, navigated to the specified command graph object. Source code in libqtile/command/client.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def __getitem__ ( self , name : str | int ) -> InteractiveCommandClient : \"\"\"Get the selected element of the currently selected object From the current command graph object, select the instance with the given name. Parameters ---------- name: str The name, or index if it's of int type, of the item to resolve Return ------ InteractiveCommandClient The current client, navigated to the specified command graph object. \"\"\" if isinstance ( self . _current_node , CommandGraphRoot ): raise KeyError ( \"Root node has no available items\" , name , self . _current_node . selectors ) if not isinstance ( self . _current_node , CommandGraphObject ): raise SelectError ( \"Unable to make selection on current node\" , str ( name ), self . _current_node . selectors , ) if self . _current_node . selector is not None : raise SelectError ( \"Selection already made\" , str ( name ), self . _current_node . selectors ) # check the selection is valid in the server-side qtile manager if not self . _command . has_item ( self . _current_node . parent , self . _current_node . object_type , name ): raise SelectError ( \"Item not available in object\" , str ( name ), self . _current_node . selectors ) next_node = self . _current_node . parent . navigate ( self . _current_node . object_type , name ) return self . __class__ ( self . _command , current_node = next_node )","title":"Return"},{"location":"reference/libqtile/command/client/#libqtile.command.client.InteractiveCommandClient.normalize_item","text":"Normalize the item according to Qtile._items(). Source code in libqtile/command/client.py 286 287 288 289 290 291 292 293 def normalize_item ( self , item : str ) -> str | int : \"Normalize the item according to Qtile._items().\" object_type = ( self . _current_node . object_type if isinstance ( self . _current_node , CommandGraphObject ) else None ) return _normalize_item ( object_type , item )","title":"normalize_item()"},{"location":"reference/libqtile/command/graph/","text":"The objects defining the nodes in the command graph and the navigation of the abstract command graph CommandGraphCall ( name , parent ) A call performed on a particular object in the command graph A terminal node in the command graph, specifying an actual command to execute on the selected graph element. Parameters: Name Type Description Default name str The name of the command to execute required parent CommandGraphNode The command graph node on which to execute the given command. required Source code in libqtile/command/graph.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __init__ ( self , name : str , parent : CommandGraphNode ) -> None : \"\"\"A command to be executed on the selected object A terminal node in the command graph, specifying an actual command to execute on the selected graph element. Parameters ---------- name: The name of the command to execute parent: The command graph node on which to execute the given command. \"\"\" self . _name = name self . _parent = parent name () property The name of the call to make Source code in libqtile/command/graph.py 94 95 96 97 @property def name ( self ) -> str : \"\"\"The name of the call to make\"\"\" return self . _name parent () property The parent of the current node Source code in libqtile/command/graph.py 104 105 106 107 @property def parent ( self ) -> CommandGraphNode : \"\"\"The parent of the current node\"\"\" return self . _parent selectors () property The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 99 100 101 102 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" return self . parent . selectors CommandGraphNode A container node in the command graph structure A command graph node which can contain other elements that it can link to. May also have commands that can be executed on itself. call ( name ) Execute the given call on the selected object Source code in libqtile/command/graph.py 70 71 72 def call ( self , name : str ) -> CommandGraphCall : \"\"\"Execute the given call on the selected object\"\"\" return CommandGraphCall ( name , self ) children () abstractmethod property The child objects that are contained within this object Source code in libqtile/command/graph.py 59 60 61 62 @property @abc . abstractmethod def children ( self ) -> list [ str ]: \"\"\"The child objects that are contained within this object\"\"\" navigate ( name , selector ) Navigate from the current node to the specified child Source code in libqtile/command/graph.py 64 65 66 67 68 def navigate ( self , name : str , selector : str | int | None ) -> CommandGraphNode : \"\"\"Navigate from the current node to the specified child\"\"\" if name in self . children : return _COMMAND_GRAPH_MAP [ name ]( selector , self ) raise KeyError ( \"Given node is not an object: {} \" . format ( name )) parent () abstractmethod property The parent of the current node Source code in libqtile/command/graph.py 54 55 56 57 @property @abc . abstractmethod def parent ( self ) -> CommandGraphNode | None : \"\"\"The parent of the current node\"\"\" selector () abstractmethod property The selector for the current node Source code in libqtile/command/graph.py 44 45 46 47 @property @abc . abstractmethod def selector ( self ) -> str | int | None : \"\"\"The selector for the current node\"\"\" selectors () abstractmethod property The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 49 50 51 52 @property @abc . abstractmethod def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" CommandGraphObject ( selector , parent ) Bases: CommandGraphNode An object in the command graph that contains a collection of objects Parameters: Name Type Description Default selector str | int | None The name of the selected element within the command graph. If not given, corresponds to the default selection of this type of object. required parent CommandGraphNode The container object that this object is the child of. required Source code in libqtile/command/graph.py 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , selector : str | int | None , parent : CommandGraphNode ) -> None : \"\"\"A container object in the command graph Parameters ---------- selector: str | None The name of the selected element within the command graph. If not given, corresponds to the default selection of this type of object. parent: CommandGraphNode The container object that this object is the child of. \"\"\" self . _selector = selector self . _parent = parent object_type () abstractmethod property The type of the current container object Source code in libqtile/command/graph.py 170 171 172 173 @property @abc . abstractmethod def object_type ( self ) -> str : \"\"\"The type of the current container object\"\"\" parent () property The parent of the current node Source code in libqtile/command/graph.py 165 166 167 168 @property def parent ( self ) -> CommandGraphNode : \"\"\"The parent of the current node\"\"\" return self . _parent selector () property The selector for the current node Source code in libqtile/command/graph.py 154 155 156 157 @property def selector ( self ) -> str | int | None : \"\"\"The selector for the current node\"\"\" return self . _selector selectors () property The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 159 160 161 162 163 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" selectors = self . parent . selectors + [( self . object_type , self . selector )] return selectors CommandGraphRoot Bases: CommandGraphNode The root node of the command graph Contains all of the elements connected to the root of the command graph. children () property All of the child elements in the root of the command graph Source code in libqtile/command/graph.py 131 132 133 134 @property def children ( self ) -> list [ str ]: \"\"\"All of the child elements in the root of the command graph\"\"\" return [ \"bar\" , \"group\" , \"layout\" , \"screen\" , \"widget\" , \"window\" , \"core\" ] parent () property The parent of the current node Source code in libqtile/command/graph.py 126 127 128 129 @property def parent ( self ) -> None : \"\"\"The parent of the current node\"\"\" return None selector () property The selector for the current node Source code in libqtile/command/graph.py 116 117 118 119 @property def selector ( self ) -> None : \"\"\"The selector for the current node\"\"\" return None selectors () property The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 121 122 123 124 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" return []","title":"graph"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphCall","text":"A call performed on a particular object in the command graph A terminal node in the command graph, specifying an actual command to execute on the selected graph element. Parameters: Name Type Description Default name str The name of the command to execute required parent CommandGraphNode The command graph node on which to execute the given command. required Source code in libqtile/command/graph.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __init__ ( self , name : str , parent : CommandGraphNode ) -> None : \"\"\"A command to be executed on the selected object A terminal node in the command graph, specifying an actual command to execute on the selected graph element. Parameters ---------- name: The name of the command to execute parent: The command graph node on which to execute the given command. \"\"\" self . _name = name self . _parent = parent","title":"CommandGraphCall"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphCall.name","text":"The name of the call to make Source code in libqtile/command/graph.py 94 95 96 97 @property def name ( self ) -> str : \"\"\"The name of the call to make\"\"\" return self . _name","title":"name()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphCall.parent","text":"The parent of the current node Source code in libqtile/command/graph.py 104 105 106 107 @property def parent ( self ) -> CommandGraphNode : \"\"\"The parent of the current node\"\"\" return self . _parent","title":"parent()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphCall.selectors","text":"The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 99 100 101 102 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" return self . parent . selectors","title":"selectors()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode","text":"A container node in the command graph structure A command graph node which can contain other elements that it can link to. May also have commands that can be executed on itself.","title":"CommandGraphNode"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode.call","text":"Execute the given call on the selected object Source code in libqtile/command/graph.py 70 71 72 def call ( self , name : str ) -> CommandGraphCall : \"\"\"Execute the given call on the selected object\"\"\" return CommandGraphCall ( name , self )","title":"call()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode.children","text":"The child objects that are contained within this object Source code in libqtile/command/graph.py 59 60 61 62 @property @abc . abstractmethod def children ( self ) -> list [ str ]: \"\"\"The child objects that are contained within this object\"\"\"","title":"children()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode.navigate","text":"Navigate from the current node to the specified child Source code in libqtile/command/graph.py 64 65 66 67 68 def navigate ( self , name : str , selector : str | int | None ) -> CommandGraphNode : \"\"\"Navigate from the current node to the specified child\"\"\" if name in self . children : return _COMMAND_GRAPH_MAP [ name ]( selector , self ) raise KeyError ( \"Given node is not an object: {} \" . format ( name ))","title":"navigate()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode.parent","text":"The parent of the current node Source code in libqtile/command/graph.py 54 55 56 57 @property @abc . abstractmethod def parent ( self ) -> CommandGraphNode | None : \"\"\"The parent of the current node\"\"\"","title":"parent()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode.selector","text":"The selector for the current node Source code in libqtile/command/graph.py 44 45 46 47 @property @abc . abstractmethod def selector ( self ) -> str | int | None : \"\"\"The selector for the current node\"\"\"","title":"selector()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphNode.selectors","text":"The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 49 50 51 52 @property @abc . abstractmethod def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\"","title":"selectors()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphObject","text":"Bases: CommandGraphNode An object in the command graph that contains a collection of objects Parameters: Name Type Description Default selector str | int | None The name of the selected element within the command graph. If not given, corresponds to the default selection of this type of object. required parent CommandGraphNode The container object that this object is the child of. required Source code in libqtile/command/graph.py 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , selector : str | int | None , parent : CommandGraphNode ) -> None : \"\"\"A container object in the command graph Parameters ---------- selector: str | None The name of the selected element within the command graph. If not given, corresponds to the default selection of this type of object. parent: CommandGraphNode The container object that this object is the child of. \"\"\" self . _selector = selector self . _parent = parent","title":"CommandGraphObject"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphObject.object_type","text":"The type of the current container object Source code in libqtile/command/graph.py 170 171 172 173 @property @abc . abstractmethod def object_type ( self ) -> str : \"\"\"The type of the current container object\"\"\"","title":"object_type()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphObject.parent","text":"The parent of the current node Source code in libqtile/command/graph.py 165 166 167 168 @property def parent ( self ) -> CommandGraphNode : \"\"\"The parent of the current node\"\"\" return self . _parent","title":"parent()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphObject.selector","text":"The selector for the current node Source code in libqtile/command/graph.py 154 155 156 157 @property def selector ( self ) -> str | int | None : \"\"\"The selector for the current node\"\"\" return self . _selector","title":"selector()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphObject.selectors","text":"The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 159 160 161 162 163 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" selectors = self . parent . selectors + [( self . object_type , self . selector )] return selectors","title":"selectors()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphRoot","text":"Bases: CommandGraphNode The root node of the command graph Contains all of the elements connected to the root of the command graph.","title":"CommandGraphRoot"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphRoot.children","text":"All of the child elements in the root of the command graph Source code in libqtile/command/graph.py 131 132 133 134 @property def children ( self ) -> list [ str ]: \"\"\"All of the child elements in the root of the command graph\"\"\" return [ \"bar\" , \"group\" , \"layout\" , \"screen\" , \"widget\" , \"window\" , \"core\" ]","title":"children()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphRoot.parent","text":"The parent of the current node Source code in libqtile/command/graph.py 126 127 128 129 @property def parent ( self ) -> None : \"\"\"The parent of the current node\"\"\" return None","title":"parent()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphRoot.selector","text":"The selector for the current node Source code in libqtile/command/graph.py 116 117 118 119 @property def selector ( self ) -> None : \"\"\"The selector for the current node\"\"\" return None","title":"selector()"},{"location":"reference/libqtile/command/graph/#libqtile.command.graph.CommandGraphRoot.selectors","text":"The selectors resolving the location of the node in the command graph Source code in libqtile/command/graph.py 121 122 123 124 @property def selectors ( self ) -> list [ SelectorType ]: \"\"\"The selectors resolving the location of the node in the command graph\"\"\" return []","title":"selectors()"},{"location":"reference/libqtile/command/interface/","text":"The interface to execute commands on the command graph CommandInterface Defines an interface which can be used to evaluate a given call on a command graph. The implementations of this may use, for example, an IPC call to access the running qtile instance remotely or directly access the qtile instance from within the same process, or it may return lazily evaluated results. execute ( call , args , kwargs ) abstractmethod Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters: Name Type Description Default call CommandGraphCall The call on the command graph that is to be performed. required args tuple The arguments to pass into the command graph call. required kwargs dict The keyword arguments to pass into the command graph call. required Source code in libqtile/command/interface.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @abstractmethod def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> Any : \"\"\"Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters ---------- call: CommandGraphCall The call on the command graph that is to be performed. args: The arguments to pass into the command graph call. kwargs: The keyword arguments to pass into the command graph call. \"\"\" has_command ( node , command ) abstractmethod Check if the given command exists Parameters: Name Type Description Default node CommandGraphNode The node to check for commands required command str The name of the command to check for required Returns: Type Description bool True if the command is resolved on the given node Source code in libqtile/command/interface.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abstractmethod def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Check if the given command exists Parameters ---------- node: CommandGraphNode The node to check for commands command: str The name of the command to check for Returns ------- bool True if the command is resolved on the given node \"\"\" has_item ( node , object_type , item ) abstractmethod Check if the given item exists Parameters: Name Type Description Default node CommandGraphNode The node to check for items required object_type str The type of object to check for items. required command The name of the item to check for required Returns: Type Description bool True if the item is resolved on the given node Source code in libqtile/command/interface.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @abstractmethod def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Check if the given item exists Parameters ---------- node: CommandGraphNode The node to check for items object_type: str The type of object to check for items. command: str The name of the item to check for Returns ------- bool True if the item is resolved on the given node \"\"\" IPCCommandInterface ( ipc_client ) Bases: CommandInterface Execute the resolved commands using the IPC connection to a running qtile instance Parameters: Name Type Description Default ipc_client ipc . Client The client that is to be used to resolve the calls. required Source code in libqtile/command/interface.py 207 208 209 210 211 212 213 214 215 def __init__ ( self , ipc_client : ipc . Client ): \"\"\"Build a command object which resolves commands through IPC calls Parameters ---------- ipc_client: ipc.Client The client that is to be used to resolve the calls. \"\"\" self . _client = ipc_client execute ( call , args , kwargs ) Execute the given call, returning the result of the execution Executes the given command over the given IPC client. Returns the result of the execution. Parameters: Name Type Description Default call CommandGraphCall The call on the command graph that is to be performed. required args tuple The arguments to pass into the command graph call. required kwargs dict The keyword arguments to pass into the command graph call. required Source code in libqtile/command/interface.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> Any : \"\"\"Execute the given call, returning the result of the execution Executes the given command over the given IPC client. Returns the result of the execution. Parameters ---------- call: CommandGraphCall The call on the command graph that is to be performed. args: The arguments to pass into the command graph call. kwargs: The keyword arguments to pass into the command graph call. \"\"\" status , result = self . _client . send (( call . parent . selectors , call . name , args , kwargs )) if status == SUCCESS : return result if status == ERROR : raise CommandError ( result ) raise CommandException ( result ) has_command ( node , command ) Check if the given command exists Resolves the allowed commands over the IPC interface, and returns a boolean indicating of the given command is valid. Parameters: Name Type Description Default node CommandGraphNode The node to check for commands required command str The name of the command to check for required Returns: Type Description bool True if the command is resolved on the given node Source code in libqtile/command/interface.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Check if the given command exists Resolves the allowed commands over the IPC interface, and returns a boolean indicating of the given command is valid. Parameters ---------- node: CommandGraphNode The node to check for commands command: str The name of the command to check for Returns ------- bool True if the command is resolved on the given node \"\"\" cmd_call = node . call ( \"commands\" ) commands = self . execute ( cmd_call , (), {}) return command in commands has_item ( node , object_type , item ) Check if the given item exists Resolves the available commands for the given command node of the given command type. Performs the resolution of the items through the given IPC client. Parameters: Name Type Description Default node CommandGraphNode The node to check for items required object_type str The type of object to check for items. required command The name of the item to check for required Returns: Type Description bool True if the item is resolved on the given node Source code in libqtile/command/interface.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Check if the given item exists Resolves the available commands for the given command node of the given command type. Performs the resolution of the items through the given IPC client. Parameters ---------- node: CommandGraphNode The node to check for items object_type: str The type of object to check for items. command: str The name of the item to check for Returns ------- bool True if the item is resolved on the given node \"\"\" items_call = node . call ( \"items\" ) _ , items = self . execute ( items_call , ( object_type ,), {}) return items is not None and item in items IPCCommandServer ( qtile ) Execute the object commands for the calls that are sent to it sets up the IPC server such that it will receive and send messages to and from the IPCCommandInterface. Source code in libqtile/command/interface.py 290 291 292 293 294 295 296 def __init__ ( self , qtile ) -> None : \"\"\"Wrapper around the ipc server for communitacing with the IPCCommandInterface sets up the IPC server such that it will receive and send messages to and from the IPCCommandInterface. \"\"\" self . qtile = qtile call ( data ) Receive and parse the given data Source code in libqtile/command/interface.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def call ( self , data : tuple [ list [ SelectorType ], str , tuple , dict ]) -> tuple [ int , Any ]: \"\"\"Receive and parse the given data\"\"\" selectors , name , args , kwargs = data try : obj = self . qtile . select ( selectors ) cmd = obj . command ( name ) except SelectError as err : sel_string = format_selectors ( selectors ) return ERROR , \"No object {} in path ' {} '\" . format ( err . name , sel_string ) if not cmd : return ERROR , \"No such command\" logger . debug ( \"Command: %s ( %s , %s )\" , name , args , kwargs ) try : # Check if method is bound if hasattr ( cmd , \"__self__\" ): return SUCCESS , cmd ( * args , ** kwargs ) else : # If not, pass object as first argument return SUCCESS , cmd ( obj , * args , ** kwargs ) except CommandError as err : return ERROR , err . args [ 0 ] except Exception : return EXCEPTION , traceback . format_exc () QtileCommandInterface ( command_object ) Bases: CommandInterface Execute the commands via the in process running qtile instance Parameters: Name Type Description Default command_object CommandObject The command object to use for resolving the commands and items against. required Source code in libqtile/command/interface.py 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , command_object : CommandObject ): \"\"\"A command object that directly resolves commands Parameters ---------- command_object: CommandObject The command object to use for resolving the commands and items against. \"\"\" self . _command_object = command_object execute ( call , args , kwargs ) Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters: Name Type Description Default call CommandGraphCall The call on the command graph that is to be performed. required args tuple The arguments to pass into the command graph call. required kwargs dict The keyword arguments to pass into the command graph call. required Source code in libqtile/command/interface.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> Any : \"\"\"Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters ---------- call: CommandGraphCall The call on the command graph that is to be performed. args: The arguments to pass into the command graph call. kwargs: The keyword arguments to pass into the command graph call. \"\"\" obj = self . _command_object . select ( call . selectors ) cmd = None try : cmd = obj . command ( call . name ) except SelectError : pass if cmd is None : return \"No such command.\" logger . debug ( \"Command: %s ( %s , %s )\" , call . name , args , kwargs ) return cmd ( self . _command_object , * args , ** kwargs ) has_command ( node , command ) Check if the given command exists Parameters: Name Type Description Default node CommandGraphNode The node to check for commands required command str The name of the command to check for required Returns: Type Description bool True if the command is resolved on the given node Source code in libqtile/command/interface.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Check if the given command exists Parameters ---------- node: CommandGraphNode The node to check for commands command: str The name of the command to check for Returns ------- bool True if the command is resolved on the given node \"\"\" obj = self . _command_object . select ( node . selectors ) cmd = obj . command ( command ) return cmd is not None has_item ( node , object_type , item ) Check if the given item exists Parameters: Name Type Description Default node CommandGraphNode The node to check for items required object_type str The type of object to check for items. required item str | int The name or index of the item to check for required Returns: Type Description bool True if the item is resolved on the given node Source code in libqtile/command/interface.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Check if the given item exists Parameters ---------- node: CommandGraphNode The node to check for items object_type: str The type of object to check for items. item: str The name or index of the item to check for Returns ------- bool True if the item is resolved on the given node \"\"\" try : self . _command_object . select ( node . selectors + [( object_type , item )]) except SelectError : return False return True format_selectors ( selectors ) Build the path to the selected command graph node Source code in libqtile/command/interface.py 46 47 48 49 50 51 52 53 54 def format_selectors ( selectors : list [ SelectorType ]) -> str : \"\"\"Build the path to the selected command graph node\"\"\" path_elements = [] for name , selector in selectors : if selector is not None : path_elements . append ( \" {} [ {} ]\" . format ( name , selector )) else : path_elements . append ( name ) return \".\" . join ( path_elements )","title":"interface"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.CommandInterface","text":"Defines an interface which can be used to evaluate a given call on a command graph. The implementations of this may use, for example, an IPC call to access the running qtile instance remotely or directly access the qtile instance from within the same process, or it may return lazily evaluated results.","title":"CommandInterface"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.CommandInterface.execute","text":"Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters: Name Type Description Default call CommandGraphCall The call on the command graph that is to be performed. required args tuple The arguments to pass into the command graph call. required kwargs dict The keyword arguments to pass into the command graph call. required Source code in libqtile/command/interface.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @abstractmethod def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> Any : \"\"\"Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters ---------- call: CommandGraphCall The call on the command graph that is to be performed. args: The arguments to pass into the command graph call. kwargs: The keyword arguments to pass into the command graph call. \"\"\"","title":"execute()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.CommandInterface.has_command","text":"Check if the given command exists Parameters: Name Type Description Default node CommandGraphNode The node to check for commands required command str The name of the command to check for required Returns: Type Description bool True if the command is resolved on the given node Source code in libqtile/command/interface.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abstractmethod def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Check if the given command exists Parameters ---------- node: CommandGraphNode The node to check for commands command: str The name of the command to check for Returns ------- bool True if the command is resolved on the given node \"\"\"","title":"has_command()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.CommandInterface.has_item","text":"Check if the given item exists Parameters: Name Type Description Default node CommandGraphNode The node to check for items required object_type str The type of object to check for items. required command The name of the item to check for required Returns: Type Description bool True if the item is resolved on the given node Source code in libqtile/command/interface.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @abstractmethod def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Check if the given item exists Parameters ---------- node: CommandGraphNode The node to check for items object_type: str The type of object to check for items. command: str The name of the item to check for Returns ------- bool True if the item is resolved on the given node \"\"\"","title":"has_item()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.IPCCommandInterface","text":"Bases: CommandInterface Execute the resolved commands using the IPC connection to a running qtile instance Parameters: Name Type Description Default ipc_client ipc . Client The client that is to be used to resolve the calls. required Source code in libqtile/command/interface.py 207 208 209 210 211 212 213 214 215 def __init__ ( self , ipc_client : ipc . Client ): \"\"\"Build a command object which resolves commands through IPC calls Parameters ---------- ipc_client: ipc.Client The client that is to be used to resolve the calls. \"\"\" self . _client = ipc_client","title":"IPCCommandInterface"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.IPCCommandInterface.execute","text":"Execute the given call, returning the result of the execution Executes the given command over the given IPC client. Returns the result of the execution. Parameters: Name Type Description Default call CommandGraphCall The call on the command graph that is to be performed. required args tuple The arguments to pass into the command graph call. required kwargs dict The keyword arguments to pass into the command graph call. required Source code in libqtile/command/interface.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> Any : \"\"\"Execute the given call, returning the result of the execution Executes the given command over the given IPC client. Returns the result of the execution. Parameters ---------- call: CommandGraphCall The call on the command graph that is to be performed. args: The arguments to pass into the command graph call. kwargs: The keyword arguments to pass into the command graph call. \"\"\" status , result = self . _client . send (( call . parent . selectors , call . name , args , kwargs )) if status == SUCCESS : return result if status == ERROR : raise CommandError ( result ) raise CommandException ( result )","title":"execute()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.IPCCommandInterface.has_command","text":"Check if the given command exists Resolves the allowed commands over the IPC interface, and returns a boolean indicating of the given command is valid. Parameters: Name Type Description Default node CommandGraphNode The node to check for commands required command str The name of the command to check for required Returns: Type Description bool True if the command is resolved on the given node Source code in libqtile/command/interface.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Check if the given command exists Resolves the allowed commands over the IPC interface, and returns a boolean indicating of the given command is valid. Parameters ---------- node: CommandGraphNode The node to check for commands command: str The name of the command to check for Returns ------- bool True if the command is resolved on the given node \"\"\" cmd_call = node . call ( \"commands\" ) commands = self . execute ( cmd_call , (), {}) return command in commands","title":"has_command()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.IPCCommandInterface.has_item","text":"Check if the given item exists Resolves the available commands for the given command node of the given command type. Performs the resolution of the items through the given IPC client. Parameters: Name Type Description Default node CommandGraphNode The node to check for items required object_type str The type of object to check for items. required command The name of the item to check for required Returns: Type Description bool True if the item is resolved on the given node Source code in libqtile/command/interface.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Check if the given item exists Resolves the available commands for the given command node of the given command type. Performs the resolution of the items through the given IPC client. Parameters ---------- node: CommandGraphNode The node to check for items object_type: str The type of object to check for items. command: str The name of the item to check for Returns ------- bool True if the item is resolved on the given node \"\"\" items_call = node . call ( \"items\" ) _ , items = self . execute ( items_call , ( object_type ,), {}) return items is not None and item in items","title":"has_item()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.IPCCommandServer","text":"Execute the object commands for the calls that are sent to it sets up the IPC server such that it will receive and send messages to and from the IPCCommandInterface. Source code in libqtile/command/interface.py 290 291 292 293 294 295 296 def __init__ ( self , qtile ) -> None : \"\"\"Wrapper around the ipc server for communitacing with the IPCCommandInterface sets up the IPC server such that it will receive and send messages to and from the IPCCommandInterface. \"\"\" self . qtile = qtile","title":"IPCCommandServer"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.IPCCommandServer.call","text":"Receive and parse the given data Source code in libqtile/command/interface.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def call ( self , data : tuple [ list [ SelectorType ], str , tuple , dict ]) -> tuple [ int , Any ]: \"\"\"Receive and parse the given data\"\"\" selectors , name , args , kwargs = data try : obj = self . qtile . select ( selectors ) cmd = obj . command ( name ) except SelectError as err : sel_string = format_selectors ( selectors ) return ERROR , \"No object {} in path ' {} '\" . format ( err . name , sel_string ) if not cmd : return ERROR , \"No such command\" logger . debug ( \"Command: %s ( %s , %s )\" , name , args , kwargs ) try : # Check if method is bound if hasattr ( cmd , \"__self__\" ): return SUCCESS , cmd ( * args , ** kwargs ) else : # If not, pass object as first argument return SUCCESS , cmd ( obj , * args , ** kwargs ) except CommandError as err : return ERROR , err . args [ 0 ] except Exception : return EXCEPTION , traceback . format_exc ()","title":"call()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.QtileCommandInterface","text":"Bases: CommandInterface Execute the commands via the in process running qtile instance Parameters: Name Type Description Default command_object CommandObject The command object to use for resolving the commands and items against. required Source code in libqtile/command/interface.py 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , command_object : CommandObject ): \"\"\"A command object that directly resolves commands Parameters ---------- command_object: CommandObject The command object to use for resolving the commands and items against. \"\"\" self . _command_object = command_object","title":"QtileCommandInterface"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.QtileCommandInterface.execute","text":"Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters: Name Type Description Default call CommandGraphCall The call on the command graph that is to be performed. required args tuple The arguments to pass into the command graph call. required kwargs dict The keyword arguments to pass into the command graph call. required Source code in libqtile/command/interface.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def execute ( self , call : CommandGraphCall , args : tuple , kwargs : dict ) -> Any : \"\"\"Execute the given call, returning the result of the execution Perform the given command graph call, calling the function with the given arguments and keyword arguments. Parameters ---------- call: CommandGraphCall The call on the command graph that is to be performed. args: The arguments to pass into the command graph call. kwargs: The keyword arguments to pass into the command graph call. \"\"\" obj = self . _command_object . select ( call . selectors ) cmd = None try : cmd = obj . command ( call . name ) except SelectError : pass if cmd is None : return \"No such command.\" logger . debug ( \"Command: %s ( %s , %s )\" , call . name , args , kwargs ) return cmd ( self . _command_object , * args , ** kwargs )","title":"execute()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.QtileCommandInterface.has_command","text":"Check if the given command exists Parameters: Name Type Description Default node CommandGraphNode The node to check for commands required command str The name of the command to check for required Returns: Type Description bool True if the command is resolved on the given node Source code in libqtile/command/interface.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def has_command ( self , node : CommandGraphNode , command : str ) -> bool : \"\"\"Check if the given command exists Parameters ---------- node: CommandGraphNode The node to check for commands command: str The name of the command to check for Returns ------- bool True if the command is resolved on the given node \"\"\" obj = self . _command_object . select ( node . selectors ) cmd = obj . command ( command ) return cmd is not None","title":"has_command()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.QtileCommandInterface.has_item","text":"Check if the given item exists Parameters: Name Type Description Default node CommandGraphNode The node to check for items required object_type str The type of object to check for items. required item str | int The name or index of the item to check for required Returns: Type Description bool True if the item is resolved on the given node Source code in libqtile/command/interface.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def has_item ( self , node : CommandGraphNode , object_type : str , item : str | int ) -> bool : \"\"\"Check if the given item exists Parameters ---------- node: CommandGraphNode The node to check for items object_type: str The type of object to check for items. item: str The name or index of the item to check for Returns ------- bool True if the item is resolved on the given node \"\"\" try : self . _command_object . select ( node . selectors + [( object_type , item )]) except SelectError : return False return True","title":"has_item()"},{"location":"reference/libqtile/command/interface/#libqtile.command.interface.format_selectors","text":"Build the path to the selected command graph node Source code in libqtile/command/interface.py 46 47 48 49 50 51 52 53 54 def format_selectors ( selectors : list [ SelectorType ]) -> str : \"\"\"Build the path to the selected command graph node\"\"\" path_elements = [] for name , selector in selectors : if selector is not None : path_elements . append ( \" {} [ {} ]\" . format ( name , selector )) else : path_elements . append ( name ) return \".\" . join ( path_elements )","title":"format_selectors()"},{"location":"reference/libqtile/core/","text":"","title":"core"},{"location":"reference/libqtile/core/lifecycle/","text":"","title":"lifecycle"},{"location":"reference/libqtile/core/loop/","text":"QtileEventLoopPolicy ( qtile ) Bases: asyncio . DefaultEventLoopPolicy Asyncio policy to ensure the main event loop is accessible even if get_event_loop() is called from a different thread. Source code in libqtile/core/loop.py 74 75 76 def __init__ ( self , qtile : Qtile ) -> None : asyncio . DefaultEventLoopPolicy . __init__ ( self ) self . qtile = qtile","title":"loop"},{"location":"reference/libqtile/core/loop/#libqtile.core.loop.QtileEventLoopPolicy","text":"Bases: asyncio . DefaultEventLoopPolicy Asyncio policy to ensure the main event loop is accessible even if get_event_loop() is called from a different thread. Source code in libqtile/core/loop.py 74 75 76 def __init__ ( self , qtile : Qtile ) -> None : asyncio . DefaultEventLoopPolicy . __init__ ( self ) self . qtile = qtile","title":"QtileEventLoopPolicy"},{"location":"reference/libqtile/core/manager/","text":"Qtile ( kore , config , no_spawn = False , state = None , socket_path = None ) Bases: CommandObject This object is the root of the command graph Source code in libqtile/core/manager.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __init__ ( self , kore : base . Core , config : Config , no_spawn : bool = False , state : str | None = None , socket_path : str | None = None , ) -> None : self . core = kore self . config = config self . no_spawn = no_spawn self . _state : QtileState | str | None = state self . socket_path = socket_path self . _drag : tuple | None = None self . mouse_map : dict [ int , list [ Mouse ]] = {} self . windows_map : dict [ int , base . WindowType ] = {} self . widgets_map : dict [ str , _Widget ] = {} self . renamed_widgets : list [ str ] self . groups_map : dict [ str , _Group ] = {} self . groups : list [ _Group ] = [] self . keys_map : dict [ tuple [ int , int ], Key | KeyChord ] = {} self . chord_stack : list [ KeyChord ] = [] self . screens : list [ Screen ] = [] libqtile . init ( self ) self . _stopped_event : asyncio . Event | None = None self . server = IPCCommandServer ( self ) add_rule ( match_args , rule_args , min_priorty = False ) Add a dgroup rule, returns rule_id needed to remove it Parameters match_args : config.Match arguments rule_args : config.Rule arguments min_priorty : If the rule is added with minimum priority (last) (default: False) Source code in libqtile/core/manager.py 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 @expose_command () def add_rule ( self , match_args : dict [ str , Any ], rule_args : dict [ str , Any ], min_priorty : bool = False , ) -> int | None : \"\"\"Add a dgroup rule, returns rule_id needed to remove it Parameters ========== match_args : config.Match arguments rule_args : config.Rule arguments min_priorty : If the rule is added with minimum priority (last) (default: False) \"\"\" if not self . dgroups : logger . warning ( \"No dgroups created\" ) return None match = Match ( ** match_args ) rule = Rule ([ match ], ** rule_args ) return self . dgroups . add_rule ( rule , min_priorty ) addgroup ( group , label = None , layout = None , layouts = None ) Add a group with the given name Source code in libqtile/core/manager.py 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 @expose_command () def addgroup ( self , group : str , label : str | None = None , layout : str | None = None , layouts : list [ Layout ] | None = None , ) -> bool : \"\"\"Add a group with the given name\"\"\" return self . add_group ( name = group , layout = layout , layouts = layouts , label = label ) async_loop () async Run the event loop Finalizes the Qtile instance on exit. Source code in libqtile/core/manager.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 async def async_loop ( self ) -> None : \"\"\"Run the event loop Finalizes the Qtile instance on exit. \"\"\" self . _eventloop = asyncio . get_running_loop () # Set the event loop policy to facilitate access to main event loop asyncio . set_event_loop_policy ( QtileEventLoopPolicy ( self )) self . _stopped_event = asyncio . Event () self . core . setup_listener ( self ) try : async with LoopContext ( { signal . SIGTERM : self . stop , signal . SIGINT : self . stop , signal . SIGHUP : self . stop , signal . SIGUSR1 : self . reload_config , signal . SIGUSR2 : self . restart , } ), ipc . Server ( self . _prepare_socket_path ( self . socket_path ), self . server . call , ): self . load_config ( initial = True ) await self . _stopped_event . wait () finally : self . finalize () self . core . remove_listener () call_later ( delay , func , * args ) Another event loop proxy, see call_soon . Source code in libqtile/core/manager.py 902 903 904 905 906 907 908 909 def call_later ( self , delay : int , func : Callable , * args : Any ) -> asyncio . TimerHandle : \"\"\"Another event loop proxy, see `call_soon`.\"\"\" def f () -> None : func ( * args ) self . core . flush () return self . _eventloop . call_later ( delay , f ) call_soon ( func , * args ) A wrapper for the event loop's call_soon which also flushes the core's event queue after func is called. Source code in libqtile/core/manager.py 883 884 885 886 887 888 889 890 891 def call_soon ( self , func : Callable , * args : Any ) -> asyncio . Handle : \"\"\"A wrapper for the event loop's call_soon which also flushes the core's event queue after func is called.\"\"\" def f () -> None : func ( * args ) self . core . flush () return self . _eventloop . call_soon ( f ) call_soon_threadsafe ( func , * args ) Another event loop proxy, see call_soon . Source code in libqtile/core/manager.py 893 894 895 896 897 898 899 900 def call_soon_threadsafe ( self , func : Callable , * args : Any ) -> asyncio . Handle : \"\"\"Another event loop proxy, see `call_soon`.\"\"\" def f () -> None : func ( * args ) self . core . flush () return self . _eventloop . call_soon_threadsafe ( f ) critical () Set log level to CRITICAL Source code in libqtile/core/manager.py 940 941 942 943 944 @expose_command () def critical ( self ) -> None : \"\"\"Set log level to CRITICAL\"\"\" logger . setLevel ( logging . CRITICAL ) logger . critical ( \"Switching to CRITICAL threshold\" ) debug () Set log level to DEBUG Source code in libqtile/core/manager.py 916 917 918 919 920 @expose_command () def debug ( self ) -> None : \"\"\"Set log level to DEBUG\"\"\" logger . setLevel ( logging . DEBUG ) logger . debug ( \"Switching to DEBUG threshold\" ) delgroup ( group ) Delete a group with the given name Source code in libqtile/core/manager.py 1558 1559 1560 1561 @expose_command () def delgroup ( self , group : str ) -> None : \"\"\"Delete a group with the given name\"\"\" self . delete_group ( group ) display_kb () Display table of key bindings Source code in libqtile/core/manager.py 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 @expose_command () def display_kb ( self ) -> str : \"\"\"Display table of key bindings\"\"\" class FormatTable : def __init__ ( self ) -> None : self . max_col_size : list [ int ] = [] self . rows : list [ list [ str ]] = [] def add ( self , row : list [ str ]) -> None : n = len ( row ) - len ( self . max_col_size ) if n > 0 : self . max_col_size += [ 0 ] * n for i , f in enumerate ( row ): if len ( f ) > self . max_col_size [ i ]: self . max_col_size [ i ] = len ( f ) self . rows . append ( row ) def getformat ( self ) -> tuple [ str , int ]: format_string = \" \" . join ( \"%- {0:d} s\" . format ( max_col_size + 2 ) for max_col_size in self . max_col_size ) return format_string + \" \\n \" , len ( self . max_col_size ) def expandlist ( self , list_ : list [ str ], n : int ) -> list [ str ]: if not list_ : return [ \"-\" * max_col_size for max_col_size in self . max_col_size ] n -= len ( list_ ) if n > 0 : list_ += [ \"\" ] * n return list_ def __str__ ( self ) -> str : format_ , n = self . getformat () return \"\" . join ( format_ % tuple ( self . expandlist ( row , n )) for row in self . rows ) result = FormatTable () result . add ([ \"Mode\" , \"KeySym\" , \"Mod\" , \"Command\" , \"Desc\" ]) result . add ([]) rows = [] def walk_binding ( k : Key | KeyChord , mode : str ) -> None : nonlocal rows modifiers , name = \", \" . join ( k . modifiers ), k . key if isinstance ( k , Key ): if not k . commands : return allargs = \", \" . join ( [ value . __name__ if callable ( value ) else repr ( value ) for value in k . commands [ 0 ] . args ] + [ \" %s = %s \" % ( keyword , repr ( value )) for keyword , value in k . commands [ 0 ] . kwargs . items () ] ) rows . append ( [ mode , name , modifiers , \" {:s} ( {:s} )\" . format ( k . commands [ 0 ] . name , allargs ), k . desc , ] ) return if isinstance ( k , KeyChord ): new_mode_s = k . name if k . name else \"<unnamed>\" new_mode = ( k . name if mode == \"<root>\" else \" {} > {} \" . format ( mode , k . name if k . name else \"_\" ) ) rows . append ([ mode , name , modifiers , \"\" , \"Enter {:s} mode\" . format ( new_mode_s )]) for s in k . submappings : walk_binding ( s , new_mode ) return raise TypeError ( \"Unexpected type: {} \" . format ( type ( k ))) for k in self . config . keys : walk_binding ( k , \"<root>\" ) rows . sort () for row in rows : result . add ( row ) return str ( result ) error () Set log level to ERROR Source code in libqtile/core/manager.py 934 935 936 937 938 @expose_command () def error ( self ) -> None : \"\"\"Set log level to ERROR\"\"\" logger . setLevel ( logging . ERROR ) logger . error ( \"Switching to ERROR threshold\" ) find_closest_screen ( x , y ) If find_screen returns None, then this basically extends a screen vertically and horizontally and see if x,y lies in the band. Only works if it can find a SINGLE closest screen, else we revert to _find_closest_closest. Useful when dragging a window out of a screen onto another but having leftmost corner above viewport. Source code in libqtile/core/manager.py 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 def find_closest_screen ( self , x : int , y : int ) -> Screen : \"\"\" If find_screen returns None, then this basically extends a screen vertically and horizontally and see if x,y lies in the band. Only works if it can find a SINGLE closest screen, else we revert to _find_closest_closest. Useful when dragging a window out of a screen onto another but having leftmost corner above viewport. \"\"\" normal = self . find_screen ( x , y ) if normal is not None : return normal x_match = [] y_match = [] for i in self . screens : if i . x <= x <= i . x + i . width : x_match . append ( i ) if i . y <= y <= i . y + i . height : y_match . append ( i ) if len ( x_match ) == 1 : return x_match [ 0 ] if len ( y_match ) == 1 : return y_match [ 0 ] return self . _find_closest_closest ( x , y , x_match + y_match ) find_screen ( x , y ) Find a screen based on the x and y offset Source code in libqtile/core/manager.py 671 672 673 674 675 676 677 678 679 def find_screen ( self , x : int , y : int ) -> Screen | None : \"\"\"Find a screen based on the x and y offset\"\"\" result = [] for i in self . screens : if i . x <= x <= i . x + i . width and i . y <= y <= i . y + i . height : result . append ( i ) if len ( result ) == 1 : return result [ 0 ] return None findwindow ( prompt = 'window' , widget = 'prompt' ) Launch prompt widget to find a window of the given name Parameters prompt : Text with which to prompt user (default: \"window\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 @expose_command () def findwindow ( self , prompt : str = \"window\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to find a window of the given name Parameters ========== prompt : Text with which to prompt user (default: \"window\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" mb = self . widgets_map . get ( widget ) if not mb : logger . error ( \"No widget named ' %s ' present.\" , widget ) return mb . start_input ( prompt , self . find_window , \"window\" , strict_completer = True ) focus_screen ( n , warp = True ) Have Qtile move to screen and put focus there Source code in libqtile/core/manager.py 802 803 804 805 806 807 808 809 810 811 812 813 814 def focus_screen ( self , n : int , warp : bool = True ) -> None : \"\"\"Have Qtile move to screen and put focus there\"\"\" if n >= len ( self . screens ): return old = self . current_screen self . current_screen = self . screens [ n ] if old != self . current_screen : hook . fire ( \"current_screen_change\" ) hook . fire ( \"setgroup\" ) old . group . layout_all () self . current_group . focus ( self . current_window , warp ) if self . current_window is None and warp : self . warp_to_screen () free_reserved_space ( reserved_space , screen ) Free up space that has previously been reserved at the edge(s) of a screen. Source code in libqtile/core/manager.py 625 626 627 628 629 630 631 632 633 634 def free_reserved_space ( self , reserved_space : tuple [ int , int , int , int ], # [left, right, top, bottom] screen : Screen , ) -> None : \"\"\" Free up space that has previously been reserved at the edge(s) of a screen. \"\"\" # mypy can't work out that the new tuple is also length 4 (see mypy #7509) self . reserve_space ( tuple ( - i for i in reserved_space ), screen ) # type: ignore get_groups () Return a dictionary containing information for all groups Examples get_groups() Source code in libqtile/core/manager.py 961 962 963 964 965 966 967 968 969 970 971 @expose_command () def get_groups ( self ) -> dict [ str , dict [ str , Any ]]: \"\"\" Return a dictionary containing information for all groups Examples ======== get_groups() \"\"\" return { i . name : i . info () for i in self . groups } get_screens () Return a list of dictionaries providing information on all screens Source code in libqtile/core/manager.py 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 @expose_command () def get_screens ( self ) -> list [ dict [ str , Any ]]: \"\"\"Return a list of dictionaries providing information on all screens\"\"\" lst = [ dict ( index = i . index , group = i . group . name if i . group is not None else None , x = i . x , y = i . y , width = i . width , height = i . height , gaps = dict ( top = i . top . geometry () if i . top else None , bottom = i . bottom . geometry () if i . bottom else None , left = i . left . geometry () if i . left else None , right = i . right . geometry () if i . right else None , ), ) for i in self . screens ] return lst get_state () Get pickled state for restarting qtile Source code in libqtile/core/manager.py 1628 1629 1630 1631 1632 1633 1634 1635 @expose_command () def get_state ( self ) -> str : \"\"\"Get pickled state for restarting qtile\"\"\" buf = io . BytesIO () self . dump_state ( buf ) state = buf . getvalue () . decode ( errors = \"backslashreplace\" ) logger . debug ( \"State = %s \" , state ) return state get_test_data () Returns any content arbitrarily set in the self.test_data attribute. Useful in tests. Source code in libqtile/core/manager.py 1662 1663 1664 1665 1666 1667 1668 @expose_command () def get_test_data ( self ) -> Any : \"\"\" Returns any content arbitrarily set in the self.test_data attribute. Useful in tests. \"\"\" return self . test_data grab_button ( button ) Grab the given mouse button event Source code in libqtile/core/manager.py 492 493 494 495 496 497 498 499 500 501 def grab_button ( self , button : Mouse ) -> None : \"\"\"Grab the given mouse button event\"\"\" try : button . modmask = self . core . grab_button ( button ) except utils . QtileError : logger . warning ( \"Unknown modifier(s): %s \" , button . modifiers ) return if button . button_code not in self . mouse_map : self . mouse_map [ button . button_code ] = [] self . mouse_map [ button . button_code ] . append ( button ) grab_key ( key ) Grab the given key event Source code in libqtile/core/manager.py 437 438 439 440 def grab_key ( self , key : Key | KeyChord ) -> None : \"\"\"Grab the given key event\"\"\" keysym , mask_key = self . core . grab_key ( key ) self . keys_map [( keysym , mask_key )] = key grab_keys () Re-grab all of the keys configured in the key map Useful when a keyboard mapping event is received. Source code in libqtile/core/manager.py 428 429 430 431 432 433 434 435 def grab_keys ( self ) -> None : \"\"\"Re-grab all of the keys configured in the key map Useful when a keyboard mapping event is received. \"\"\" self . core . ungrab_keys () for key in self . keys_map . values (): self . grab_key ( key ) hide_show_bar ( position = 'all' ) Toggle visibility of a given bar Parameters position : one of: \"top\", \"bottom\", \"left\", \"right\", or \"all\" (default: \"all\") Source code in libqtile/core/manager.py 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 @expose_command () def hide_show_bar ( self , position : Literal [ \"top\" , \"bottom\" , \"left\" , \"right\" , \"all\" ] = \"all\" , ) -> None : \"\"\"Toggle visibility of a given bar Parameters ========== position : one of: \"top\", \"bottom\", \"left\", \"right\", or \"all\" (default: \"all\") \"\"\" if position in [ \"top\" , \"bottom\" , \"left\" , \"right\" ]: bar = getattr ( self . current_screen , position ) if bar : bar . show ( not bar . is_show ()) self . current_group . layout_all () else : logger . warning ( \"Not found bar in position ' %s ' for hide/show.\" , position ) elif position == \"all\" : screen = self . current_screen is_show = None for bar in [ screen . left , screen . right , screen . top , screen . bottom ]: if bar : if is_show is None : is_show = not bar . is_show () bar . show ( is_show ) if is_show is not None : self . current_group . layout_all () else : logger . warning ( \"Not found bar for hide/show.\" ) else : logger . warning ( \"Invalid position value: %s \" , position ) info () Set log level to INFO Source code in libqtile/core/manager.py 922 923 924 925 926 @expose_command () def info ( self ) -> None : \"\"\"Set log level to INFO\"\"\" logger . setLevel ( logging . INFO ) logger . info ( \"Switching to INFO threshold\" ) internal_windows () Return info for each internal window (bars, for example) Source code in libqtile/core/manager.py 1311 1312 1313 1314 @expose_command () def internal_windows ( self ) -> list [ dict [ str , Any ]]: \"\"\"Return info for each internal window (bars, for example)\"\"\" return [ i . info () for i in self . windows_map . values () if isinstance ( i , base . Internal )] labelgroup ( prompt = 'label' , widget = 'prompt' ) Launch prompt widget to label the current group Parameters prompt : Text with which to prompt user (default: \"label\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 @expose_command () def labelgroup ( self , prompt : str = \"label\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to label the current group Parameters ========== prompt : Text with which to prompt user (default: \"label\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" def f ( name : str ) -> None : self . current_group . set_label ( name or None ) try : mb = self . widgets_map [ widget ] mb . start_input ( prompt , f , allow_empty_input = True ) except KeyError : logger . error ( \"No widget named ' %s ' present.\" , widget ) list_widgets () List of all addressible widget names Source code in libqtile/core/manager.py 1060 1061 1062 1063 @expose_command () def list_widgets ( self ) -> list [ str ]: \"\"\"List of all addressible widget names\"\"\" return list ( self . widgets_map . keys ()) move_to_group ( group ) Create a group if it doesn't exist and move the current window there Source code in libqtile/core/manager.py 816 817 818 819 820 821 def move_to_group ( self , group : str ) -> None : \"\"\"Create a group if it doesn't exist and move the current window there\"\"\" if self . current_window and group : self . add_group ( group ) self . current_window . togroup ( group ) next_layout ( name = None ) Switch to the next layout. Parameters name : Group name. If not specified, the current group is assumed Source code in libqtile/core/manager.py 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 @expose_command () def next_layout ( self , name : str | None = None ) -> None : \"\"\" Switch to the next layout. Parameters ========== name : Group name. If not specified, the current group is assumed \"\"\" if name is not None : group = self . groups_map [ name ] else : group = self . current_group group . use_next_layout () next_screen () Move to next screen Source code in libqtile/core/manager.py 1292 1293 1294 1295 @expose_command () def next_screen ( self ) -> None : \"\"\"Move to next screen\"\"\" self . focus_screen (( self . screens . index ( self . current_screen ) + 1 ) % len ( self . screens )) next_urgent () Focus next window with urgent hint Source code in libqtile/core/manager.py 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 @expose_command () def next_urgent ( self ) -> None : \"\"\"Focus next window with urgent hint\"\"\" try : nxt = [ w for w in self . windows_map . values () if w . urgent ][ 0 ] assert isinstance ( nxt , base . Window ) if nxt . group : nxt . group . toscreen () nxt . group . focus ( nxt ) else : self . current_screen . group . add ( nxt ) self . current_screen . group . focus ( nxt ) except IndexError : pass # no window had urgent set pause () Drops into pdb Source code in libqtile/core/manager.py 954 955 956 957 958 959 @expose_command () def pause ( self ) -> None : \"\"\"Drops into pdb\"\"\" import pdb pdb . set_trace () prev_layout ( name = None ) Switch to the previous layout. Parameters name : Group name. If not specified, the current group is assumed Source code in libqtile/core/manager.py 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 @expose_command () def prev_layout ( self , name : str | None = None ) -> None : \"\"\" Switch to the previous layout. Parameters ========== name : Group name. If not specified, the current group is assumed \"\"\" if name is not None : group = self . groups_map [ name ] else : group = self . current_group group . use_previous_layout () prev_screen () Move to the previous screen Source code in libqtile/core/manager.py 1297 1298 1299 1300 @expose_command () def prev_screen ( self ) -> None : \"\"\"Move to the previous screen\"\"\" self . focus_screen (( self . screens . index ( self . current_screen ) - 1 ) % len ( self . screens )) qtile_info () Returns a dictionary of info on the Qtile instance Source code in libqtile/core/manager.py 1316 1317 1318 1319 @expose_command () def qtile_info ( self ) -> dict : \"\"\"Returns a dictionary of info on the Qtile instance\"\"\" return {} qtilecmd ( prompt = 'command' , widget = 'prompt' , messenger = 'xmessage' ) Execute a Qtile command using the client syntax Tab completion aids navigation of the command tree Parameters prompt : Text to display at the prompt (default: \"command: \") widget : Name of the prompt widget (default: \"prompt\") messenger : Command to display output, set this to None to disable (default: \"xmessage\") Source code in libqtile/core/manager.py 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 @expose_command () def qtilecmd ( self , prompt : str = \"command\" , widget : str = \"prompt\" , messenger : str = \"xmessage\" , ) -> None : \"\"\"Execute a Qtile command using the client syntax Tab completion aids navigation of the command tree Parameters ========== prompt : Text to display at the prompt (default: \"command: \") widget : Name of the prompt widget (default: \"prompt\") messenger : Command to display output, set this to None to disable (default: \"xmessage\") \"\"\" def f ( cmd : str ) -> None : if cmd : # c here is used in eval() below q = QtileCommandInterface ( self ) c = InteractiveCommandClient ( q ) # noqa: F841 try : cmd_arg = str ( cmd ) . split ( \" \" ) except AttributeError : return cmd_len = len ( cmd_arg ) if cmd_len == 0 : logger . debug ( \"No command entered.\" ) return try : result = eval ( \"c. {0:s} \" . format ( cmd )) except ( CommandError , CommandException , AttributeError ): logger . exception ( \"Command errored:\" ) result = None if result is not None : from pprint import pformat message = pformat ( result ) if messenger : self . spawn ( ' {0:s} \" {1:s} \"' . format ( messenger , message )) logger . debug ( result ) mb = self . widgets_map [ widget ] if not mb : logger . error ( \"No widget named %s present.\" , widget ) return mb . start_input ( prompt , f , \"qshell\" ) reconfigure_screens ( ev = None ) This can be used to set up screens again during run time. Intended usage is to be called when the screen_change hook is fired, responding to changes in physical monitor setup by configuring qtile.screens accordingly. The ev kwarg is ignored; it is here in case this function is hooked directly to screen_change. Source code in libqtile/core/manager.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @expose_command () def reconfigure_screens ( self , ev : Any = None ) -> None : \"\"\" This can be used to set up screens again during run time. Intended usage is to be called when the screen_change hook is fired, responding to changes in physical monitor setup by configuring qtile.screens accordingly. The ev kwarg is ignored; it is here in case this function is hooked directly to screen_change. \"\"\" logger . info ( \"Reconfiguring screens.\" ) self . _process_screens () for group in self . groups : if group . screen : if group . screen in self . screens : group . layout_all () else : group . hide () hook . fire ( \"screens_reconfigured\" ) register_widget ( w ) Register a bar widget If a widget with the same name already exists, the new widget will be automatically renamed by appending numeric suffixes. For example, if the widget is named \"foo\", we will attempt \"foo_1\", \"foo_2\", and so on, until a free name is found. This naming convention is only used for qtile.widgets_map as every widget MUST be registered here to ensure that objects are finalised correctly. Widgets can still be accessed by their name when using lazy.screen.widget[name] or lazy.bar[\"top\"].widget[name] unless there are duplicate widgets in the bar/screen. A warning will be provided where renaming has occurred. Source code in libqtile/core/manager.py 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 def register_widget ( self , w : _Widget ) -> None : \"\"\" Register a bar widget If a widget with the same name already exists, the new widget will be automatically renamed by appending numeric suffixes. For example, if the widget is named \"foo\", we will attempt \"foo_1\", \"foo_2\", and so on, until a free name is found. This naming convention is only used for qtile.widgets_map as every widget MUST be registered here to ensure that objects are finalised correctly. Widgets can still be accessed by their name when using lazy.screen.widget[name] or lazy.bar[\"top\"].widget[name] unless there are duplicate widgets in the bar/screen. A warning will be provided where renaming has occurred. \"\"\" # Find unoccupied name by appending numeric suffixes name = w . name i = 0 while name in self . widgets_map : i += 1 name = f \" { w . name } _ { i } \" if name != w . name : self . renamed_widgets . append ( name ) self . widgets_map [ name ] = w reload_config () Reload the configuration file. Can also be triggered by sending Qtile a SIGUSR1 signal. Source code in libqtile/core/manager.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 @expose_command () def reload_config ( self ) -> None : \"\"\" Reload the configuration file. Can also be triggered by sending Qtile a SIGUSR1 signal. \"\"\" logger . debug ( \"Reloading the configuration file\" ) try : self . config . load () except Exception as error : logger . exception ( \"Configuration error:\" ) send_notification ( \"Configuration error\" , str ( error )) return self . _state = QtileState ( self , restart = False ) self . _finalize_configurables () hook . clear () self . ungrab_keys () self . chord_stack . clear () self . core . ungrab_buttons () self . mouse_map . clear () self . groups_map . clear () self . groups . clear () self . screens . clear () self . load_config () remove_rule ( rule_id ) Remove a dgroup rule by rule_id Source code in libqtile/core/manager.py 1589 1590 1591 1592 @expose_command () def remove_rule ( self , rule_id : int ) -> None : \"\"\"Remove a dgroup rule by rule_id\"\"\" self . dgroups . remove_rule ( rule_id ) reserve_space ( reserved_space , screen ) Reserve some space at the edge(s) of a screen. Source code in libqtile/core/manager.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def reserve_space ( self , reserved_space : tuple [ int , int , int , int ], # [left, right, top, bottom] screen : Screen , ) -> None : \"\"\" Reserve some space at the edge(s) of a screen. \"\"\" for i , pos in enumerate ([ \"left\" , \"right\" , \"top\" , \"bottom\" ]): if reserved_space [ i ]: gap = getattr ( screen , pos ) if isinstance ( gap , bar . Bar ): gap . adjust_for_strut ( reserved_space [ i ]) elif isinstance ( gap , bar . Gap ): gap . size += reserved_space [ i ] if gap . size <= 0 : setattr ( screen , pos , None ) else : setattr ( screen , pos , bar . Gap ( reserved_space [ i ])) screen . resize () restart () Restart Qtile. Can also be triggered by sending Qtile a SIGUSR2 signal. Source code in libqtile/core/manager.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 @expose_command () def restart ( self ) -> None : \"\"\"Restart Qtile. Can also be triggered by sending Qtile a SIGUSR2 signal. \"\"\" if not self . core . supports_restarting : raise CommandError ( f \"Backend does not support restarting: { self . core . name } \" ) try : self . config . load () except Exception as error : logger . exception ( \"Preventing restart because of a configuration error:\" ) send_notification ( \"Configuration error\" , str ( error . __context__ )) return hook . fire ( \"restart\" ) lifecycle . behavior = lifecycle . behavior . RESTART state_file = os . path . join ( tempfile . gettempdir (), \"qtile-state\" ) with open ( state_file , \"wb\" ) as f : self . dump_state ( f ) lifecycle . state_file = state_file self . _stop () run_extension ( extension ) Run extensions Source code in libqtile/core/manager.py 1670 1671 1672 1673 @expose_command () def run_extension ( self , extension : _Extension ) -> None : \"\"\"Run extensions\"\"\" extension . run () run_in_executor ( func , * args ) A wrapper for running a function in the event loop's default executor. Source code in libqtile/core/manager.py 911 912 913 914 def run_in_executor ( self , func : Callable , * args : Any ) -> asyncio . Future : \"\"\"A wrapper for running a function in the event loop's default executor.\"\"\" return self . _eventloop . run_in_executor ( None , func , * args ) shutdown () Quit Qtile Source code in libqtile/core/manager.py 1321 1322 1323 1324 @expose_command () def shutdown ( self ) -> None : \"\"\"Quit Qtile\"\"\" self . stop () simulate_keypress ( modifiers , key ) Simulates a keypress on the focused window. Parameters modifiers : A list of modifier specification strings. Modifiers can be one of \"shift\", \"lock\", \"control\" and \"mod1\" - \"mod5\". key : Key specification. Examples simulate_keypress([\"control\", \"mod2\"], \"k\") Source code in libqtile/core/manager.py 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 @expose_command () def simulate_keypress ( self , modifiers : list [ str ], key : str ) -> None : \"\"\"Simulates a keypress on the focused window. Parameters ========== modifiers : A list of modifier specification strings. Modifiers can be one of \"shift\", \"lock\", \"control\" and \"mod1\" - \"mod5\". key : Key specification. Examples ======== simulate_keypress([\"control\", \"mod2\"], \"k\") \"\"\" try : self . core . simulate_keypress ( modifiers , key ) except utils . QtileError as e : raise CommandError ( str ( e )) spawn ( cmd , shell = False ) Run cmd, in a shell or not (default). cmd may be a string or a list (similar to subprocess.Popen). Examples spawn(\"firefox\") spawn([\"xterm\", \"-T\", \"Temporary terminal\"]) Source code in libqtile/core/manager.py 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 @expose_command () def spawn ( self , cmd : str | list [ str ], shell : bool = False ) -> int : \"\"\" Run cmd, in a shell or not (default). cmd may be a string or a list (similar to subprocess.Popen). Examples ======== spawn(\"firefox\") spawn([\"xterm\", \"-T\", \"Temporary terminal\"]) \"\"\" if isinstance ( cmd , str ): args = shlex . split ( cmd ) else : args = list ( cmd ) cmd = subprocess . list2cmdline ( args ) to_lookup = args [ 0 ] if shell : args = [ \"/bin/sh\" , \"-c\" , cmd ] if shutil . which ( to_lookup ) is None : logger . error ( \"couldn't find ` %s `\" , to_lookup ) return - 1 r , w = os . pipe () pid = os . fork () if pid < 0 : os . close ( r ) os . close ( w ) return pid if pid == 0 : os . close ( r ) # close qtile's stdin, stdout, stderr so the called process doesn't # pollute our xsession-errors. os . close ( 0 ) os . close ( 1 ) os . close ( 2 ) pid2 = os . fork () if pid2 == 0 : os . close ( w ) try : # if qtile was installed in a virutal env, we don't # necessarily want to propagate that to children # applications, since it may change e.g. the behavior # of shells that spawn python applications del os . environ [ \"VIRTUAL_ENV\" ] except KeyError : pass # Open /dev/null as stdin, stdout, stderr try : fd = os . open ( os . devnull , os . O_RDWR ) except OSError : # This shouldn't happen, catch it just in case pass else : # For Python >=3.4, need to set file descriptor to inheritable try : os . set_inheritable ( fd , True ) except AttributeError : pass # Again, this shouldn't happen, but we should just check if fd > 0 : os . dup2 ( fd , 0 ) os . dup2 ( fd , 1 ) os . dup2 ( fd , 2 ) try : os . execvp ( args [ 0 ], args ) except OSError : # can't log here since we forked :( pass os . _exit ( 1 ) else : # Here it doesn't matter if fork failed or not, we just write # its return code and exit. os . write ( w , str ( pid2 ) . encode ()) os . close ( w ) # sys.exit raises SystemExit, which will then be caught by our # top level catchall and we'll end up with two qtiles; os._exit # actually calls exit. os . _exit ( 0 ) else : os . close ( w ) os . waitpid ( pid , 0 ) # 1024 bytes should be enough for any pid. :) pid = int ( os . read ( r , 1024 )) os . close ( r ) return pid spawncmd ( prompt = 'spawn' , widget = 'prompt' , command = ' %s ' , complete = 'cmd' , shell = True , aliases = None ) Spawn a command using a prompt widget, with tab-completion. Parameters prompt : Text with which to prompt user (default: \"spawn: \"). widget : Name of the prompt widget (default: \"prompt\"). command : command template (default: \"%s\"). complete : Tab completion function (default: \"cmd\") shell : Execute the command with /bin/sh (default: True) aliases : Dictionary mapping aliases to commands. If the entered command is a key in this dict, the command it maps to will be executed instead. Source code in libqtile/core/manager.py 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 @expose_command () def spawncmd ( self , prompt : str = \"spawn\" , widget : str = \"prompt\" , command : str = \" %s \" , complete : str = \"cmd\" , shell : bool = True , aliases : dict [ str , str ] | None = None , ) -> None : \"\"\"Spawn a command using a prompt widget, with tab-completion. Parameters ========== prompt : Text with which to prompt user (default: \"spawn: \"). widget : Name of the prompt widget (default: \"prompt\"). command : command template (default: \"%s\"). complete : Tab completion function (default: \"cmd\") shell : Execute the command with /bin/sh (default: True) aliases : Dictionary mapping aliases to commands. If the entered command is a key in this dict, the command it maps to will be executed instead. \"\"\" def f ( args : str ) -> None : if args : if aliases and args in aliases : args = aliases [ args ] self . spawn ( command % args , shell = shell ) try : mb = self . widgets_map [ widget ] mb . start_input ( prompt , f , complete ) except KeyError : logger . error ( \"No widget named ' %s ' present.\" , widget ) status () Return \"OK\" if Qtile is running Source code in libqtile/core/manager.py 1269 1270 1271 1272 @expose_command () def status ( self ) -> Literal [ \"OK\" ]: \"\"\"Return \"OK\" if Qtile is running\"\"\" return \"OK\" switch_groups ( namea , nameb ) Switch position of two groups by name Source code in libqtile/core/manager.py 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 @expose_command () def switch_groups ( self , namea : str , nameb : str ) -> None : \"\"\"Switch position of two groups by name\"\"\" if namea not in self . groups_map or nameb not in self . groups_map : return indexa = self . groups . index ( self . groups_map [ namea ]) indexb = self . groups . index ( self . groups_map [ nameb ]) self . groups [ indexa ], self . groups [ indexb ] = self . groups [ indexb ], self . groups [ indexa ] hook . fire ( \"setgroup\" ) # update window _NET_WM_DESKTOP for group in ( self . groups [ indexa ], self . groups [ indexb ]): for w in group . windows : w . group = group switchgroup ( prompt = 'group' , widget = 'prompt' ) Launch prompt widget to switch to a given group to the current screen Parameters prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 @expose_command () def switchgroup ( self , prompt : str = \"group\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to switch to a given group to the current screen Parameters ========== prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" def f ( group : str ) -> None : if group : try : self . groups_map [ group ] . toscreen () except KeyError : logger . warning ( \"No group named ' %s ' present.\" , group ) mb = self . widgets_map . get ( widget ) if not mb : logger . error ( \"No widget named ' %s ' present.\" , widget ) return mb . start_input ( prompt , f , \"group\" , strict_completer = True ) sync () Sync the backend's event queue. Should only be used for development. Source code in libqtile/core/manager.py 1274 1275 1276 1277 1278 1279 @expose_command () def sync ( self ) -> None : \"\"\" Sync the backend's event queue. Should only be used for development. \"\"\" self . core . flush () to_layout_index ( index , name = None ) Switch to the layout with the given index in self.layouts. Parameters index : Index of the layout in the list of layouts. name : Group name. If not specified, the current group is assumed. Source code in libqtile/core/manager.py 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 @expose_command () def to_layout_index ( self , index : str , name : str | None = None ) -> None : \"\"\" Switch to the layout with the given index in self.layouts. Parameters ========== index : Index of the layout in the list of layouts. name : Group name. If not specified, the current group is assumed. \"\"\" if name is not None : group = self . groups_map [ name ] else : group = self . current_group group . use_layout ( index ) to_screen ( n ) Warp focus to screen n, where n is a 0-based screen number Examples to_screen(0) Source code in libqtile/core/manager.py 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 @expose_command () def to_screen ( self , n : int ) -> None : \"\"\"Warp focus to screen n, where n is a 0-based screen number Examples ======== to_screen(0) \"\"\" self . focus_screen ( n ) togroup ( prompt = 'group' , widget = 'prompt' ) Launch prompt widget to move current window to a given group Parameters prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 @expose_command () def togroup ( self , prompt : str = \"group\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to move current window to a given group Parameters ========== prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" if not self . current_window : logger . warning ( \"No window to move\" ) return mb = self . widgets_map . get ( widget ) if not mb : logger . error ( \"No widget named ' %s ' present.\" , widget ) return mb . start_input ( prompt , self . move_to_group , \"group\" , strict_completer = True ) tracemalloc_dump () Dump tracemalloc snapshot Source code in libqtile/core/manager.py 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 @expose_command () def tracemalloc_dump ( self ) -> tuple [ bool , str ]: \"\"\"Dump tracemalloc snapshot\"\"\" import tracemalloc if not tracemalloc . is_tracing (): return False , \"Trace not started\" cache_directory = get_cache_dir () malloc_dump = os . path . join ( cache_directory , \"qtile_tracemalloc.dump\" ) tracemalloc . take_snapshot () . dump ( malloc_dump ) return True , malloc_dump tracemalloc_toggle () Toggle tracemalloc status Running tracemalloc is required for qtile top Source code in libqtile/core/manager.py 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 @expose_command () def tracemalloc_toggle ( self ) -> None : \"\"\"Toggle tracemalloc status Running tracemalloc is required for `qtile top` \"\"\" import tracemalloc if not tracemalloc . is_tracing (): tracemalloc . start () else : tracemalloc . stop () ungrab_all_chords () Leave all chord modes and grab the root bindings Source code in libqtile/core/manager.py 483 484 485 486 487 488 489 490 @expose_command () def ungrab_all_chords ( self ) -> None : \"\"\"Leave all chord modes and grab the root bindings\"\"\" hook . fire ( \"leave_chord\" ) self . ungrab_keys () self . chord_stack . clear () for key in self . config . keys : self . grab_key ( key ) ungrab_chord () Leave a chord mode Source code in libqtile/core/manager.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 @expose_command () def ungrab_chord ( self ) -> None : \"\"\"Leave a chord mode\"\"\" hook . fire ( \"leave_chord\" ) self . ungrab_keys () if not self . chord_stack : logger . debug ( \"ungrab_chord was called when no chord mode was active\" ) return # The first pop is necessary: Otherwise we would be stuck in a mode; # we could not leave it: the code below would re-enter the old mode. self . chord_stack . pop () # Find another named mode or load the root keybindings: while self . chord_stack : chord = self . chord_stack . pop () if chord . mode != \"\" : self . grab_chord ( chord ) break else : for key in self . config . keys : self . grab_key ( key ) ungrab_key ( key ) Ungrab a given key event Source code in libqtile/core/manager.py 442 443 444 445 def ungrab_key ( self , key : Key | KeyChord ) -> None : \"\"\"Ungrab a given key event\"\"\" keysym , mask_key = self . core . ungrab_key ( key ) self . keys_map . pop (( keysym , mask_key )) ungrab_keys () Ungrab all key events Source code in libqtile/core/manager.py 447 448 449 450 def ungrab_keys ( self ) -> None : \"\"\"Ungrab all key events\"\"\" self . core . ungrab_keys () self . keys_map . clear () warning () Set log level to WARNING Source code in libqtile/core/manager.py 928 929 930 931 932 @expose_command () def warning ( self ) -> None : \"\"\"Set log level to WARNING\"\"\" logger . setLevel ( logging . WARNING ) logger . warning ( \"Switching to WARNING threshold\" ) windows () Return info for each client window Source code in libqtile/core/manager.py 1302 1303 1304 1305 1306 1307 1308 1309 @expose_command () def windows ( self ) -> list [ dict [ str , Any ]]: \"\"\"Return info for each client window\"\"\" return [ i . info () for i in self . windows_map . values () if not isinstance ( i , ( base . Internal , _Widget )) and isinstance ( i , CommandObject ) ]","title":"manager"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile","text":"Bases: CommandObject This object is the root of the command graph Source code in libqtile/core/manager.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __init__ ( self , kore : base . Core , config : Config , no_spawn : bool = False , state : str | None = None , socket_path : str | None = None , ) -> None : self . core = kore self . config = config self . no_spawn = no_spawn self . _state : QtileState | str | None = state self . socket_path = socket_path self . _drag : tuple | None = None self . mouse_map : dict [ int , list [ Mouse ]] = {} self . windows_map : dict [ int , base . WindowType ] = {} self . widgets_map : dict [ str , _Widget ] = {} self . renamed_widgets : list [ str ] self . groups_map : dict [ str , _Group ] = {} self . groups : list [ _Group ] = [] self . keys_map : dict [ tuple [ int , int ], Key | KeyChord ] = {} self . chord_stack : list [ KeyChord ] = [] self . screens : list [ Screen ] = [] libqtile . init ( self ) self . _stopped_event : asyncio . Event | None = None self . server = IPCCommandServer ( self )","title":"Qtile"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.add_rule","text":"Add a dgroup rule, returns rule_id needed to remove it","title":"add_rule()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.add_rule--parameters","text":"match_args : config.Match arguments rule_args : config.Rule arguments min_priorty : If the rule is added with minimum priority (last) (default: False) Source code in libqtile/core/manager.py 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 @expose_command () def add_rule ( self , match_args : dict [ str , Any ], rule_args : dict [ str , Any ], min_priorty : bool = False , ) -> int | None : \"\"\"Add a dgroup rule, returns rule_id needed to remove it Parameters ========== match_args : config.Match arguments rule_args : config.Rule arguments min_priorty : If the rule is added with minimum priority (last) (default: False) \"\"\" if not self . dgroups : logger . warning ( \"No dgroups created\" ) return None match = Match ( ** match_args ) rule = Rule ([ match ], ** rule_args ) return self . dgroups . add_rule ( rule , min_priorty )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.addgroup","text":"Add a group with the given name Source code in libqtile/core/manager.py 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 @expose_command () def addgroup ( self , group : str , label : str | None = None , layout : str | None = None , layouts : list [ Layout ] | None = None , ) -> bool : \"\"\"Add a group with the given name\"\"\" return self . add_group ( name = group , layout = layout , layouts = layouts , label = label )","title":"addgroup()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.async_loop","text":"Run the event loop Finalizes the Qtile instance on exit. Source code in libqtile/core/manager.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 async def async_loop ( self ) -> None : \"\"\"Run the event loop Finalizes the Qtile instance on exit. \"\"\" self . _eventloop = asyncio . get_running_loop () # Set the event loop policy to facilitate access to main event loop asyncio . set_event_loop_policy ( QtileEventLoopPolicy ( self )) self . _stopped_event = asyncio . Event () self . core . setup_listener ( self ) try : async with LoopContext ( { signal . SIGTERM : self . stop , signal . SIGINT : self . stop , signal . SIGHUP : self . stop , signal . SIGUSR1 : self . reload_config , signal . SIGUSR2 : self . restart , } ), ipc . Server ( self . _prepare_socket_path ( self . socket_path ), self . server . call , ): self . load_config ( initial = True ) await self . _stopped_event . wait () finally : self . finalize () self . core . remove_listener ()","title":"async_loop()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.call_later","text":"Another event loop proxy, see call_soon . Source code in libqtile/core/manager.py 902 903 904 905 906 907 908 909 def call_later ( self , delay : int , func : Callable , * args : Any ) -> asyncio . TimerHandle : \"\"\"Another event loop proxy, see `call_soon`.\"\"\" def f () -> None : func ( * args ) self . core . flush () return self . _eventloop . call_later ( delay , f )","title":"call_later()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.call_soon","text":"A wrapper for the event loop's call_soon which also flushes the core's event queue after func is called. Source code in libqtile/core/manager.py 883 884 885 886 887 888 889 890 891 def call_soon ( self , func : Callable , * args : Any ) -> asyncio . Handle : \"\"\"A wrapper for the event loop's call_soon which also flushes the core's event queue after func is called.\"\"\" def f () -> None : func ( * args ) self . core . flush () return self . _eventloop . call_soon ( f )","title":"call_soon()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.call_soon_threadsafe","text":"Another event loop proxy, see call_soon . Source code in libqtile/core/manager.py 893 894 895 896 897 898 899 900 def call_soon_threadsafe ( self , func : Callable , * args : Any ) -> asyncio . Handle : \"\"\"Another event loop proxy, see `call_soon`.\"\"\" def f () -> None : func ( * args ) self . core . flush () return self . _eventloop . call_soon_threadsafe ( f )","title":"call_soon_threadsafe()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.critical","text":"Set log level to CRITICAL Source code in libqtile/core/manager.py 940 941 942 943 944 @expose_command () def critical ( self ) -> None : \"\"\"Set log level to CRITICAL\"\"\" logger . setLevel ( logging . CRITICAL ) logger . critical ( \"Switching to CRITICAL threshold\" )","title":"critical()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.debug","text":"Set log level to DEBUG Source code in libqtile/core/manager.py 916 917 918 919 920 @expose_command () def debug ( self ) -> None : \"\"\"Set log level to DEBUG\"\"\" logger . setLevel ( logging . DEBUG ) logger . debug ( \"Switching to DEBUG threshold\" )","title":"debug()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.delgroup","text":"Delete a group with the given name Source code in libqtile/core/manager.py 1558 1559 1560 1561 @expose_command () def delgroup ( self , group : str ) -> None : \"\"\"Delete a group with the given name\"\"\" self . delete_group ( group )","title":"delgroup()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.display_kb","text":"Display table of key bindings Source code in libqtile/core/manager.py 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 @expose_command () def display_kb ( self ) -> str : \"\"\"Display table of key bindings\"\"\" class FormatTable : def __init__ ( self ) -> None : self . max_col_size : list [ int ] = [] self . rows : list [ list [ str ]] = [] def add ( self , row : list [ str ]) -> None : n = len ( row ) - len ( self . max_col_size ) if n > 0 : self . max_col_size += [ 0 ] * n for i , f in enumerate ( row ): if len ( f ) > self . max_col_size [ i ]: self . max_col_size [ i ] = len ( f ) self . rows . append ( row ) def getformat ( self ) -> tuple [ str , int ]: format_string = \" \" . join ( \"%- {0:d} s\" . format ( max_col_size + 2 ) for max_col_size in self . max_col_size ) return format_string + \" \\n \" , len ( self . max_col_size ) def expandlist ( self , list_ : list [ str ], n : int ) -> list [ str ]: if not list_ : return [ \"-\" * max_col_size for max_col_size in self . max_col_size ] n -= len ( list_ ) if n > 0 : list_ += [ \"\" ] * n return list_ def __str__ ( self ) -> str : format_ , n = self . getformat () return \"\" . join ( format_ % tuple ( self . expandlist ( row , n )) for row in self . rows ) result = FormatTable () result . add ([ \"Mode\" , \"KeySym\" , \"Mod\" , \"Command\" , \"Desc\" ]) result . add ([]) rows = [] def walk_binding ( k : Key | KeyChord , mode : str ) -> None : nonlocal rows modifiers , name = \", \" . join ( k . modifiers ), k . key if isinstance ( k , Key ): if not k . commands : return allargs = \", \" . join ( [ value . __name__ if callable ( value ) else repr ( value ) for value in k . commands [ 0 ] . args ] + [ \" %s = %s \" % ( keyword , repr ( value )) for keyword , value in k . commands [ 0 ] . kwargs . items () ] ) rows . append ( [ mode , name , modifiers , \" {:s} ( {:s} )\" . format ( k . commands [ 0 ] . name , allargs ), k . desc , ] ) return if isinstance ( k , KeyChord ): new_mode_s = k . name if k . name else \"<unnamed>\" new_mode = ( k . name if mode == \"<root>\" else \" {} > {} \" . format ( mode , k . name if k . name else \"_\" ) ) rows . append ([ mode , name , modifiers , \"\" , \"Enter {:s} mode\" . format ( new_mode_s )]) for s in k . submappings : walk_binding ( s , new_mode ) return raise TypeError ( \"Unexpected type: {} \" . format ( type ( k ))) for k in self . config . keys : walk_binding ( k , \"<root>\" ) rows . sort () for row in rows : result . add ( row ) return str ( result )","title":"display_kb()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.error","text":"Set log level to ERROR Source code in libqtile/core/manager.py 934 935 936 937 938 @expose_command () def error ( self ) -> None : \"\"\"Set log level to ERROR\"\"\" logger . setLevel ( logging . ERROR ) logger . error ( \"Switching to ERROR threshold\" )","title":"error()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.find_closest_screen","text":"If find_screen returns None, then this basically extends a screen vertically and horizontally and see if x,y lies in the band. Only works if it can find a SINGLE closest screen, else we revert to _find_closest_closest. Useful when dragging a window out of a screen onto another but having leftmost corner above viewport. Source code in libqtile/core/manager.py 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 def find_closest_screen ( self , x : int , y : int ) -> Screen : \"\"\" If find_screen returns None, then this basically extends a screen vertically and horizontally and see if x,y lies in the band. Only works if it can find a SINGLE closest screen, else we revert to _find_closest_closest. Useful when dragging a window out of a screen onto another but having leftmost corner above viewport. \"\"\" normal = self . find_screen ( x , y ) if normal is not None : return normal x_match = [] y_match = [] for i in self . screens : if i . x <= x <= i . x + i . width : x_match . append ( i ) if i . y <= y <= i . y + i . height : y_match . append ( i ) if len ( x_match ) == 1 : return x_match [ 0 ] if len ( y_match ) == 1 : return y_match [ 0 ] return self . _find_closest_closest ( x , y , x_match + y_match )","title":"find_closest_screen()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.find_screen","text":"Find a screen based on the x and y offset Source code in libqtile/core/manager.py 671 672 673 674 675 676 677 678 679 def find_screen ( self , x : int , y : int ) -> Screen | None : \"\"\"Find a screen based on the x and y offset\"\"\" result = [] for i in self . screens : if i . x <= x <= i . x + i . width and i . y <= y <= i . y + i . height : result . append ( i ) if len ( result ) == 1 : return result [ 0 ] return None","title":"find_screen()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.findwindow","text":"Launch prompt widget to find a window of the given name","title":"findwindow()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.findwindow--parameters","text":"prompt : Text with which to prompt user (default: \"window\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 @expose_command () def findwindow ( self , prompt : str = \"window\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to find a window of the given name Parameters ========== prompt : Text with which to prompt user (default: \"window\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" mb = self . widgets_map . get ( widget ) if not mb : logger . error ( \"No widget named ' %s ' present.\" , widget ) return mb . start_input ( prompt , self . find_window , \"window\" , strict_completer = True )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.focus_screen","text":"Have Qtile move to screen and put focus there Source code in libqtile/core/manager.py 802 803 804 805 806 807 808 809 810 811 812 813 814 def focus_screen ( self , n : int , warp : bool = True ) -> None : \"\"\"Have Qtile move to screen and put focus there\"\"\" if n >= len ( self . screens ): return old = self . current_screen self . current_screen = self . screens [ n ] if old != self . current_screen : hook . fire ( \"current_screen_change\" ) hook . fire ( \"setgroup\" ) old . group . layout_all () self . current_group . focus ( self . current_window , warp ) if self . current_window is None and warp : self . warp_to_screen ()","title":"focus_screen()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.free_reserved_space","text":"Free up space that has previously been reserved at the edge(s) of a screen. Source code in libqtile/core/manager.py 625 626 627 628 629 630 631 632 633 634 def free_reserved_space ( self , reserved_space : tuple [ int , int , int , int ], # [left, right, top, bottom] screen : Screen , ) -> None : \"\"\" Free up space that has previously been reserved at the edge(s) of a screen. \"\"\" # mypy can't work out that the new tuple is also length 4 (see mypy #7509) self . reserve_space ( tuple ( - i for i in reserved_space ), screen ) # type: ignore","title":"free_reserved_space()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.get_groups","text":"Return a dictionary containing information for all groups","title":"get_groups()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.get_groups--examples","text":"get_groups() Source code in libqtile/core/manager.py 961 962 963 964 965 966 967 968 969 970 971 @expose_command () def get_groups ( self ) -> dict [ str , dict [ str , Any ]]: \"\"\" Return a dictionary containing information for all groups Examples ======== get_groups() \"\"\" return { i . name : i . info () for i in self . groups }","title":"Examples"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.get_screens","text":"Return a list of dictionaries providing information on all screens Source code in libqtile/core/manager.py 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 @expose_command () def get_screens ( self ) -> list [ dict [ str , Any ]]: \"\"\"Return a list of dictionaries providing information on all screens\"\"\" lst = [ dict ( index = i . index , group = i . group . name if i . group is not None else None , x = i . x , y = i . y , width = i . width , height = i . height , gaps = dict ( top = i . top . geometry () if i . top else None , bottom = i . bottom . geometry () if i . bottom else None , left = i . left . geometry () if i . left else None , right = i . right . geometry () if i . right else None , ), ) for i in self . screens ] return lst","title":"get_screens()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.get_state","text":"Get pickled state for restarting qtile Source code in libqtile/core/manager.py 1628 1629 1630 1631 1632 1633 1634 1635 @expose_command () def get_state ( self ) -> str : \"\"\"Get pickled state for restarting qtile\"\"\" buf = io . BytesIO () self . dump_state ( buf ) state = buf . getvalue () . decode ( errors = \"backslashreplace\" ) logger . debug ( \"State = %s \" , state ) return state","title":"get_state()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.get_test_data","text":"Returns any content arbitrarily set in the self.test_data attribute. Useful in tests. Source code in libqtile/core/manager.py 1662 1663 1664 1665 1666 1667 1668 @expose_command () def get_test_data ( self ) -> Any : \"\"\" Returns any content arbitrarily set in the self.test_data attribute. Useful in tests. \"\"\" return self . test_data","title":"get_test_data()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.grab_button","text":"Grab the given mouse button event Source code in libqtile/core/manager.py 492 493 494 495 496 497 498 499 500 501 def grab_button ( self , button : Mouse ) -> None : \"\"\"Grab the given mouse button event\"\"\" try : button . modmask = self . core . grab_button ( button ) except utils . QtileError : logger . warning ( \"Unknown modifier(s): %s \" , button . modifiers ) return if button . button_code not in self . mouse_map : self . mouse_map [ button . button_code ] = [] self . mouse_map [ button . button_code ] . append ( button )","title":"grab_button()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.grab_key","text":"Grab the given key event Source code in libqtile/core/manager.py 437 438 439 440 def grab_key ( self , key : Key | KeyChord ) -> None : \"\"\"Grab the given key event\"\"\" keysym , mask_key = self . core . grab_key ( key ) self . keys_map [( keysym , mask_key )] = key","title":"grab_key()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.grab_keys","text":"Re-grab all of the keys configured in the key map Useful when a keyboard mapping event is received. Source code in libqtile/core/manager.py 428 429 430 431 432 433 434 435 def grab_keys ( self ) -> None : \"\"\"Re-grab all of the keys configured in the key map Useful when a keyboard mapping event is received. \"\"\" self . core . ungrab_keys () for key in self . keys_map . values (): self . grab_key ( key )","title":"grab_keys()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.hide_show_bar","text":"Toggle visibility of a given bar","title":"hide_show_bar()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.hide_show_bar--parameters","text":"position : one of: \"top\", \"bottom\", \"left\", \"right\", or \"all\" (default: \"all\") Source code in libqtile/core/manager.py 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 @expose_command () def hide_show_bar ( self , position : Literal [ \"top\" , \"bottom\" , \"left\" , \"right\" , \"all\" ] = \"all\" , ) -> None : \"\"\"Toggle visibility of a given bar Parameters ========== position : one of: \"top\", \"bottom\", \"left\", \"right\", or \"all\" (default: \"all\") \"\"\" if position in [ \"top\" , \"bottom\" , \"left\" , \"right\" ]: bar = getattr ( self . current_screen , position ) if bar : bar . show ( not bar . is_show ()) self . current_group . layout_all () else : logger . warning ( \"Not found bar in position ' %s ' for hide/show.\" , position ) elif position == \"all\" : screen = self . current_screen is_show = None for bar in [ screen . left , screen . right , screen . top , screen . bottom ]: if bar : if is_show is None : is_show = not bar . is_show () bar . show ( is_show ) if is_show is not None : self . current_group . layout_all () else : logger . warning ( \"Not found bar for hide/show.\" ) else : logger . warning ( \"Invalid position value: %s \" , position )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.info","text":"Set log level to INFO Source code in libqtile/core/manager.py 922 923 924 925 926 @expose_command () def info ( self ) -> None : \"\"\"Set log level to INFO\"\"\" logger . setLevel ( logging . INFO ) logger . info ( \"Switching to INFO threshold\" )","title":"info()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.internal_windows","text":"Return info for each internal window (bars, for example) Source code in libqtile/core/manager.py 1311 1312 1313 1314 @expose_command () def internal_windows ( self ) -> list [ dict [ str , Any ]]: \"\"\"Return info for each internal window (bars, for example)\"\"\" return [ i . info () for i in self . windows_map . values () if isinstance ( i , base . Internal )]","title":"internal_windows()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.labelgroup","text":"Launch prompt widget to label the current group","title":"labelgroup()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.labelgroup--parameters","text":"prompt : Text with which to prompt user (default: \"label\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 @expose_command () def labelgroup ( self , prompt : str = \"label\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to label the current group Parameters ========== prompt : Text with which to prompt user (default: \"label\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" def f ( name : str ) -> None : self . current_group . set_label ( name or None ) try : mb = self . widgets_map [ widget ] mb . start_input ( prompt , f , allow_empty_input = True ) except KeyError : logger . error ( \"No widget named ' %s ' present.\" , widget )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.list_widgets","text":"List of all addressible widget names Source code in libqtile/core/manager.py 1060 1061 1062 1063 @expose_command () def list_widgets ( self ) -> list [ str ]: \"\"\"List of all addressible widget names\"\"\" return list ( self . widgets_map . keys ())","title":"list_widgets()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.move_to_group","text":"Create a group if it doesn't exist and move the current window there Source code in libqtile/core/manager.py 816 817 818 819 820 821 def move_to_group ( self , group : str ) -> None : \"\"\"Create a group if it doesn't exist and move the current window there\"\"\" if self . current_window and group : self . add_group ( group ) self . current_window . togroup ( group )","title":"move_to_group()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.next_layout","text":"Switch to the next layout.","title":"next_layout()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.next_layout--parameters","text":"name : Group name. If not specified, the current group is assumed Source code in libqtile/core/manager.py 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 @expose_command () def next_layout ( self , name : str | None = None ) -> None : \"\"\" Switch to the next layout. Parameters ========== name : Group name. If not specified, the current group is assumed \"\"\" if name is not None : group = self . groups_map [ name ] else : group = self . current_group group . use_next_layout ()","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.next_screen","text":"Move to next screen Source code in libqtile/core/manager.py 1292 1293 1294 1295 @expose_command () def next_screen ( self ) -> None : \"\"\"Move to next screen\"\"\" self . focus_screen (( self . screens . index ( self . current_screen ) + 1 ) % len ( self . screens ))","title":"next_screen()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.next_urgent","text":"Focus next window with urgent hint Source code in libqtile/core/manager.py 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 @expose_command () def next_urgent ( self ) -> None : \"\"\"Focus next window with urgent hint\"\"\" try : nxt = [ w for w in self . windows_map . values () if w . urgent ][ 0 ] assert isinstance ( nxt , base . Window ) if nxt . group : nxt . group . toscreen () nxt . group . focus ( nxt ) else : self . current_screen . group . add ( nxt ) self . current_screen . group . focus ( nxt ) except IndexError : pass # no window had urgent set","title":"next_urgent()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.pause","text":"Drops into pdb Source code in libqtile/core/manager.py 954 955 956 957 958 959 @expose_command () def pause ( self ) -> None : \"\"\"Drops into pdb\"\"\" import pdb pdb . set_trace ()","title":"pause()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.prev_layout","text":"Switch to the previous layout.","title":"prev_layout()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.prev_layout--parameters","text":"name : Group name. If not specified, the current group is assumed Source code in libqtile/core/manager.py 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 @expose_command () def prev_layout ( self , name : str | None = None ) -> None : \"\"\" Switch to the previous layout. Parameters ========== name : Group name. If not specified, the current group is assumed \"\"\" if name is not None : group = self . groups_map [ name ] else : group = self . current_group group . use_previous_layout ()","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.prev_screen","text":"Move to the previous screen Source code in libqtile/core/manager.py 1297 1298 1299 1300 @expose_command () def prev_screen ( self ) -> None : \"\"\"Move to the previous screen\"\"\" self . focus_screen (( self . screens . index ( self . current_screen ) - 1 ) % len ( self . screens ))","title":"prev_screen()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.qtile_info","text":"Returns a dictionary of info on the Qtile instance Source code in libqtile/core/manager.py 1316 1317 1318 1319 @expose_command () def qtile_info ( self ) -> dict : \"\"\"Returns a dictionary of info on the Qtile instance\"\"\" return {}","title":"qtile_info()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.qtilecmd","text":"Execute a Qtile command using the client syntax Tab completion aids navigation of the command tree","title":"qtilecmd()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.qtilecmd--parameters","text":"prompt : Text to display at the prompt (default: \"command: \") widget : Name of the prompt widget (default: \"prompt\") messenger : Command to display output, set this to None to disable (default: \"xmessage\") Source code in libqtile/core/manager.py 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 @expose_command () def qtilecmd ( self , prompt : str = \"command\" , widget : str = \"prompt\" , messenger : str = \"xmessage\" , ) -> None : \"\"\"Execute a Qtile command using the client syntax Tab completion aids navigation of the command tree Parameters ========== prompt : Text to display at the prompt (default: \"command: \") widget : Name of the prompt widget (default: \"prompt\") messenger : Command to display output, set this to None to disable (default: \"xmessage\") \"\"\" def f ( cmd : str ) -> None : if cmd : # c here is used in eval() below q = QtileCommandInterface ( self ) c = InteractiveCommandClient ( q ) # noqa: F841 try : cmd_arg = str ( cmd ) . split ( \" \" ) except AttributeError : return cmd_len = len ( cmd_arg ) if cmd_len == 0 : logger . debug ( \"No command entered.\" ) return try : result = eval ( \"c. {0:s} \" . format ( cmd )) except ( CommandError , CommandException , AttributeError ): logger . exception ( \"Command errored:\" ) result = None if result is not None : from pprint import pformat message = pformat ( result ) if messenger : self . spawn ( ' {0:s} \" {1:s} \"' . format ( messenger , message )) logger . debug ( result ) mb = self . widgets_map [ widget ] if not mb : logger . error ( \"No widget named %s present.\" , widget ) return mb . start_input ( prompt , f , \"qshell\" )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.reconfigure_screens","text":"This can be used to set up screens again during run time. Intended usage is to be called when the screen_change hook is fired, responding to changes in physical monitor setup by configuring qtile.screens accordingly. The ev kwarg is ignored; it is here in case this function is hooked directly to screen_change. Source code in libqtile/core/manager.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @expose_command () def reconfigure_screens ( self , ev : Any = None ) -> None : \"\"\" This can be used to set up screens again during run time. Intended usage is to be called when the screen_change hook is fired, responding to changes in physical monitor setup by configuring qtile.screens accordingly. The ev kwarg is ignored; it is here in case this function is hooked directly to screen_change. \"\"\" logger . info ( \"Reconfiguring screens.\" ) self . _process_screens () for group in self . groups : if group . screen : if group . screen in self . screens : group . layout_all () else : group . hide () hook . fire ( \"screens_reconfigured\" )","title":"reconfigure_screens()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.register_widget","text":"Register a bar widget If a widget with the same name already exists, the new widget will be automatically renamed by appending numeric suffixes. For example, if the widget is named \"foo\", we will attempt \"foo_1\", \"foo_2\", and so on, until a free name is found. This naming convention is only used for qtile.widgets_map as every widget MUST be registered here to ensure that objects are finalised correctly. Widgets can still be accessed by their name when using lazy.screen.widget[name] or lazy.bar[\"top\"].widget[name] unless there are duplicate widgets in the bar/screen. A warning will be provided where renaming has occurred. Source code in libqtile/core/manager.py 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 def register_widget ( self , w : _Widget ) -> None : \"\"\" Register a bar widget If a widget with the same name already exists, the new widget will be automatically renamed by appending numeric suffixes. For example, if the widget is named \"foo\", we will attempt \"foo_1\", \"foo_2\", and so on, until a free name is found. This naming convention is only used for qtile.widgets_map as every widget MUST be registered here to ensure that objects are finalised correctly. Widgets can still be accessed by their name when using lazy.screen.widget[name] or lazy.bar[\"top\"].widget[name] unless there are duplicate widgets in the bar/screen. A warning will be provided where renaming has occurred. \"\"\" # Find unoccupied name by appending numeric suffixes name = w . name i = 0 while name in self . widgets_map : i += 1 name = f \" { w . name } _ { i } \" if name != w . name : self . renamed_widgets . append ( name ) self . widgets_map [ name ] = w","title":"register_widget()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.reload_config","text":"Reload the configuration file. Can also be triggered by sending Qtile a SIGUSR1 signal. Source code in libqtile/core/manager.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 @expose_command () def reload_config ( self ) -> None : \"\"\" Reload the configuration file. Can also be triggered by sending Qtile a SIGUSR1 signal. \"\"\" logger . debug ( \"Reloading the configuration file\" ) try : self . config . load () except Exception as error : logger . exception ( \"Configuration error:\" ) send_notification ( \"Configuration error\" , str ( error )) return self . _state = QtileState ( self , restart = False ) self . _finalize_configurables () hook . clear () self . ungrab_keys () self . chord_stack . clear () self . core . ungrab_buttons () self . mouse_map . clear () self . groups_map . clear () self . groups . clear () self . screens . clear () self . load_config ()","title":"reload_config()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.remove_rule","text":"Remove a dgroup rule by rule_id Source code in libqtile/core/manager.py 1589 1590 1591 1592 @expose_command () def remove_rule ( self , rule_id : int ) -> None : \"\"\"Remove a dgroup rule by rule_id\"\"\" self . dgroups . remove_rule ( rule_id )","title":"remove_rule()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.reserve_space","text":"Reserve some space at the edge(s) of a screen. Source code in libqtile/core/manager.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def reserve_space ( self , reserved_space : tuple [ int , int , int , int ], # [left, right, top, bottom] screen : Screen , ) -> None : \"\"\" Reserve some space at the edge(s) of a screen. \"\"\" for i , pos in enumerate ([ \"left\" , \"right\" , \"top\" , \"bottom\" ]): if reserved_space [ i ]: gap = getattr ( screen , pos ) if isinstance ( gap , bar . Bar ): gap . adjust_for_strut ( reserved_space [ i ]) elif isinstance ( gap , bar . Gap ): gap . size += reserved_space [ i ] if gap . size <= 0 : setattr ( screen , pos , None ) else : setattr ( screen , pos , bar . Gap ( reserved_space [ i ])) screen . resize ()","title":"reserve_space()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.restart","text":"Restart Qtile. Can also be triggered by sending Qtile a SIGUSR2 signal. Source code in libqtile/core/manager.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 @expose_command () def restart ( self ) -> None : \"\"\"Restart Qtile. Can also be triggered by sending Qtile a SIGUSR2 signal. \"\"\" if not self . core . supports_restarting : raise CommandError ( f \"Backend does not support restarting: { self . core . name } \" ) try : self . config . load () except Exception as error : logger . exception ( \"Preventing restart because of a configuration error:\" ) send_notification ( \"Configuration error\" , str ( error . __context__ )) return hook . fire ( \"restart\" ) lifecycle . behavior = lifecycle . behavior . RESTART state_file = os . path . join ( tempfile . gettempdir (), \"qtile-state\" ) with open ( state_file , \"wb\" ) as f : self . dump_state ( f ) lifecycle . state_file = state_file self . _stop ()","title":"restart()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.run_extension","text":"Run extensions Source code in libqtile/core/manager.py 1670 1671 1672 1673 @expose_command () def run_extension ( self , extension : _Extension ) -> None : \"\"\"Run extensions\"\"\" extension . run ()","title":"run_extension()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.run_in_executor","text":"A wrapper for running a function in the event loop's default executor. Source code in libqtile/core/manager.py 911 912 913 914 def run_in_executor ( self , func : Callable , * args : Any ) -> asyncio . Future : \"\"\"A wrapper for running a function in the event loop's default executor.\"\"\" return self . _eventloop . run_in_executor ( None , func , * args )","title":"run_in_executor()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.shutdown","text":"Quit Qtile Source code in libqtile/core/manager.py 1321 1322 1323 1324 @expose_command () def shutdown ( self ) -> None : \"\"\"Quit Qtile\"\"\" self . stop ()","title":"shutdown()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.simulate_keypress","text":"Simulates a keypress on the focused window.","title":"simulate_keypress()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.simulate_keypress--parameters","text":"modifiers : A list of modifier specification strings. Modifiers can be one of \"shift\", \"lock\", \"control\" and \"mod1\" - \"mod5\". key : Key specification.","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.simulate_keypress--examples","text":"simulate_keypress([\"control\", \"mod2\"], \"k\") Source code in libqtile/core/manager.py 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 @expose_command () def simulate_keypress ( self , modifiers : list [ str ], key : str ) -> None : \"\"\"Simulates a keypress on the focused window. Parameters ========== modifiers : A list of modifier specification strings. Modifiers can be one of \"shift\", \"lock\", \"control\" and \"mod1\" - \"mod5\". key : Key specification. Examples ======== simulate_keypress([\"control\", \"mod2\"], \"k\") \"\"\" try : self . core . simulate_keypress ( modifiers , key ) except utils . QtileError as e : raise CommandError ( str ( e ))","title":"Examples"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.spawn","text":"Run cmd, in a shell or not (default). cmd may be a string or a list (similar to subprocess.Popen).","title":"spawn()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.spawn--examples","text":"spawn(\"firefox\") spawn([\"xterm\", \"-T\", \"Temporary terminal\"]) Source code in libqtile/core/manager.py 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 @expose_command () def spawn ( self , cmd : str | list [ str ], shell : bool = False ) -> int : \"\"\" Run cmd, in a shell or not (default). cmd may be a string or a list (similar to subprocess.Popen). Examples ======== spawn(\"firefox\") spawn([\"xterm\", \"-T\", \"Temporary terminal\"]) \"\"\" if isinstance ( cmd , str ): args = shlex . split ( cmd ) else : args = list ( cmd ) cmd = subprocess . list2cmdline ( args ) to_lookup = args [ 0 ] if shell : args = [ \"/bin/sh\" , \"-c\" , cmd ] if shutil . which ( to_lookup ) is None : logger . error ( \"couldn't find ` %s `\" , to_lookup ) return - 1 r , w = os . pipe () pid = os . fork () if pid < 0 : os . close ( r ) os . close ( w ) return pid if pid == 0 : os . close ( r ) # close qtile's stdin, stdout, stderr so the called process doesn't # pollute our xsession-errors. os . close ( 0 ) os . close ( 1 ) os . close ( 2 ) pid2 = os . fork () if pid2 == 0 : os . close ( w ) try : # if qtile was installed in a virutal env, we don't # necessarily want to propagate that to children # applications, since it may change e.g. the behavior # of shells that spawn python applications del os . environ [ \"VIRTUAL_ENV\" ] except KeyError : pass # Open /dev/null as stdin, stdout, stderr try : fd = os . open ( os . devnull , os . O_RDWR ) except OSError : # This shouldn't happen, catch it just in case pass else : # For Python >=3.4, need to set file descriptor to inheritable try : os . set_inheritable ( fd , True ) except AttributeError : pass # Again, this shouldn't happen, but we should just check if fd > 0 : os . dup2 ( fd , 0 ) os . dup2 ( fd , 1 ) os . dup2 ( fd , 2 ) try : os . execvp ( args [ 0 ], args ) except OSError : # can't log here since we forked :( pass os . _exit ( 1 ) else : # Here it doesn't matter if fork failed or not, we just write # its return code and exit. os . write ( w , str ( pid2 ) . encode ()) os . close ( w ) # sys.exit raises SystemExit, which will then be caught by our # top level catchall and we'll end up with two qtiles; os._exit # actually calls exit. os . _exit ( 0 ) else : os . close ( w ) os . waitpid ( pid , 0 ) # 1024 bytes should be enough for any pid. :) pid = int ( os . read ( r , 1024 )) os . close ( r ) return pid","title":"Examples"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.spawncmd","text":"Spawn a command using a prompt widget, with tab-completion.","title":"spawncmd()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.spawncmd--parameters","text":"prompt : Text with which to prompt user (default: \"spawn: \"). widget : Name of the prompt widget (default: \"prompt\"). command : command template (default: \"%s\"). complete : Tab completion function (default: \"cmd\") shell : Execute the command with /bin/sh (default: True) aliases : Dictionary mapping aliases to commands. If the entered command is a key in this dict, the command it maps to will be executed instead. Source code in libqtile/core/manager.py 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 @expose_command () def spawncmd ( self , prompt : str = \"spawn\" , widget : str = \"prompt\" , command : str = \" %s \" , complete : str = \"cmd\" , shell : bool = True , aliases : dict [ str , str ] | None = None , ) -> None : \"\"\"Spawn a command using a prompt widget, with tab-completion. Parameters ========== prompt : Text with which to prompt user (default: \"spawn: \"). widget : Name of the prompt widget (default: \"prompt\"). command : command template (default: \"%s\"). complete : Tab completion function (default: \"cmd\") shell : Execute the command with /bin/sh (default: True) aliases : Dictionary mapping aliases to commands. If the entered command is a key in this dict, the command it maps to will be executed instead. \"\"\" def f ( args : str ) -> None : if args : if aliases and args in aliases : args = aliases [ args ] self . spawn ( command % args , shell = shell ) try : mb = self . widgets_map [ widget ] mb . start_input ( prompt , f , complete ) except KeyError : logger . error ( \"No widget named ' %s ' present.\" , widget )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.status","text":"Return \"OK\" if Qtile is running Source code in libqtile/core/manager.py 1269 1270 1271 1272 @expose_command () def status ( self ) -> Literal [ \"OK\" ]: \"\"\"Return \"OK\" if Qtile is running\"\"\" return \"OK\"","title":"status()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.switch_groups","text":"Switch position of two groups by name Source code in libqtile/core/manager.py 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 @expose_command () def switch_groups ( self , namea : str , nameb : str ) -> None : \"\"\"Switch position of two groups by name\"\"\" if namea not in self . groups_map or nameb not in self . groups_map : return indexa = self . groups . index ( self . groups_map [ namea ]) indexb = self . groups . index ( self . groups_map [ nameb ]) self . groups [ indexa ], self . groups [ indexb ] = self . groups [ indexb ], self . groups [ indexa ] hook . fire ( \"setgroup\" ) # update window _NET_WM_DESKTOP for group in ( self . groups [ indexa ], self . groups [ indexb ]): for w in group . windows : w . group = group","title":"switch_groups()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.switchgroup","text":"Launch prompt widget to switch to a given group to the current screen","title":"switchgroup()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.switchgroup--parameters","text":"prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 @expose_command () def switchgroup ( self , prompt : str = \"group\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to switch to a given group to the current screen Parameters ========== prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" def f ( group : str ) -> None : if group : try : self . groups_map [ group ] . toscreen () except KeyError : logger . warning ( \"No group named ' %s ' present.\" , group ) mb = self . widgets_map . get ( widget ) if not mb : logger . error ( \"No widget named ' %s ' present.\" , widget ) return mb . start_input ( prompt , f , \"group\" , strict_completer = True )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.sync","text":"Sync the backend's event queue. Should only be used for development. Source code in libqtile/core/manager.py 1274 1275 1276 1277 1278 1279 @expose_command () def sync ( self ) -> None : \"\"\" Sync the backend's event queue. Should only be used for development. \"\"\" self . core . flush ()","title":"sync()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.to_layout_index","text":"Switch to the layout with the given index in self.layouts.","title":"to_layout_index()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.to_layout_index--parameters","text":"index : Index of the layout in the list of layouts. name : Group name. If not specified, the current group is assumed. Source code in libqtile/core/manager.py 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 @expose_command () def to_layout_index ( self , index : str , name : str | None = None ) -> None : \"\"\" Switch to the layout with the given index in self.layouts. Parameters ========== index : Index of the layout in the list of layouts. name : Group name. If not specified, the current group is assumed. \"\"\" if name is not None : group = self . groups_map [ name ] else : group = self . current_group group . use_layout ( index )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.to_screen","text":"Warp focus to screen n, where n is a 0-based screen number","title":"to_screen()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.to_screen--examples","text":"to_screen(0) Source code in libqtile/core/manager.py 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 @expose_command () def to_screen ( self , n : int ) -> None : \"\"\"Warp focus to screen n, where n is a 0-based screen number Examples ======== to_screen(0) \"\"\" self . focus_screen ( n )","title":"Examples"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.togroup","text":"Launch prompt widget to move current window to a given group","title":"togroup()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.togroup--parameters","text":"prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") Source code in libqtile/core/manager.py 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 @expose_command () def togroup ( self , prompt : str = \"group\" , widget : str = \"prompt\" ) -> None : \"\"\"Launch prompt widget to move current window to a given group Parameters ========== prompt : Text with which to prompt user (default: \"group\") widget : Name of the prompt widget (default: \"prompt\") \"\"\" if not self . current_window : logger . warning ( \"No window to move\" ) return mb = self . widgets_map . get ( widget ) if not mb : logger . error ( \"No widget named ' %s ' present.\" , widget ) return mb . start_input ( prompt , self . move_to_group , \"group\" , strict_completer = True )","title":"Parameters"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.tracemalloc_dump","text":"Dump tracemalloc snapshot Source code in libqtile/core/manager.py 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 @expose_command () def tracemalloc_dump ( self ) -> tuple [ bool , str ]: \"\"\"Dump tracemalloc snapshot\"\"\" import tracemalloc if not tracemalloc . is_tracing (): return False , \"Trace not started\" cache_directory = get_cache_dir () malloc_dump = os . path . join ( cache_directory , \"qtile_tracemalloc.dump\" ) tracemalloc . take_snapshot () . dump ( malloc_dump ) return True , malloc_dump","title":"tracemalloc_dump()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.tracemalloc_toggle","text":"Toggle tracemalloc status Running tracemalloc is required for qtile top Source code in libqtile/core/manager.py 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 @expose_command () def tracemalloc_toggle ( self ) -> None : \"\"\"Toggle tracemalloc status Running tracemalloc is required for `qtile top` \"\"\" import tracemalloc if not tracemalloc . is_tracing (): tracemalloc . start () else : tracemalloc . stop ()","title":"tracemalloc_toggle()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.ungrab_all_chords","text":"Leave all chord modes and grab the root bindings Source code in libqtile/core/manager.py 483 484 485 486 487 488 489 490 @expose_command () def ungrab_all_chords ( self ) -> None : \"\"\"Leave all chord modes and grab the root bindings\"\"\" hook . fire ( \"leave_chord\" ) self . ungrab_keys () self . chord_stack . clear () for key in self . config . keys : self . grab_key ( key )","title":"ungrab_all_chords()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.ungrab_chord","text":"Leave a chord mode Source code in libqtile/core/manager.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 @expose_command () def ungrab_chord ( self ) -> None : \"\"\"Leave a chord mode\"\"\" hook . fire ( \"leave_chord\" ) self . ungrab_keys () if not self . chord_stack : logger . debug ( \"ungrab_chord was called when no chord mode was active\" ) return # The first pop is necessary: Otherwise we would be stuck in a mode; # we could not leave it: the code below would re-enter the old mode. self . chord_stack . pop () # Find another named mode or load the root keybindings: while self . chord_stack : chord = self . chord_stack . pop () if chord . mode != \"\" : self . grab_chord ( chord ) break else : for key in self . config . keys : self . grab_key ( key )","title":"ungrab_chord()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.ungrab_key","text":"Ungrab a given key event Source code in libqtile/core/manager.py 442 443 444 445 def ungrab_key ( self , key : Key | KeyChord ) -> None : \"\"\"Ungrab a given key event\"\"\" keysym , mask_key = self . core . ungrab_key ( key ) self . keys_map . pop (( keysym , mask_key ))","title":"ungrab_key()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.ungrab_keys","text":"Ungrab all key events Source code in libqtile/core/manager.py 447 448 449 450 def ungrab_keys ( self ) -> None : \"\"\"Ungrab all key events\"\"\" self . core . ungrab_keys () self . keys_map . clear ()","title":"ungrab_keys()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.warning","text":"Set log level to WARNING Source code in libqtile/core/manager.py 928 929 930 931 932 @expose_command () def warning ( self ) -> None : \"\"\"Set log level to WARNING\"\"\" logger . setLevel ( logging . WARNING ) logger . warning ( \"Switching to WARNING threshold\" )","title":"warning()"},{"location":"reference/libqtile/core/manager/#libqtile.core.manager.Qtile.windows","text":"Return info for each client window Source code in libqtile/core/manager.py 1302 1303 1304 1305 1306 1307 1308 1309 @expose_command () def windows ( self ) -> list [ dict [ str , Any ]]: \"\"\"Return info for each client window\"\"\" return [ i . info () for i in self . windows_map . values () if not isinstance ( i , ( base . Internal , _Widget )) and isinstance ( i , CommandObject ) ]","title":"windows()"},{"location":"reference/libqtile/core/state/","text":"QtileState ( qtile , restart = True ) Represents the state of the Qtile object This is used for restoring state across restarts or config reloads. If restart is True, the current set of groups will be saved in the state. This is useful when restarting for Qtile version updates rather than reloading the config. ScratchPad groups are saved for both reloading and restarting. Source code in libqtile/core/state.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , qtile : Qtile , restart : bool = True ) -> None : self . groups = [] self . screens = {} self . current_screen = 0 self . scratchpads = {} self . orphans : list [ int ] = [] self . restart = restart # True when restarting, False when config reloading for group in qtile . groups : if isinstance ( group , ScratchPad ): self . scratchpads [ group . name ] = group . get_state () elif restart : self . groups . append (( group . name , group . layout . name , group . label )) for index , screen in enumerate ( qtile . screens ): self . screens [ index ] = screen . group . name if screen == qtile . current_screen : self . current_screen = index apply ( qtile ) Rearrange the windows in the specified Qtile object according to this QtileState. Source code in libqtile/core/state.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def apply ( self , qtile : Qtile ) -> None : \"\"\" Rearrange the windows in the specified Qtile object according to this QtileState. \"\"\" for ( group , layout , label ) in self . groups : try : qtile . groups_map [ group ] . layout = layout qtile . groups_map [ group ] . label = label except KeyError : qtile . add_group ( group , layout , label = label ) for ( screen , group ) in self . screens . items (): try : group = qtile . groups_map [ group ] qtile . screens [ screen ] . set_group ( group ) except ( KeyError , IndexError ): pass # group or screen missing for group in qtile . groups : if isinstance ( group , ScratchPad ) and group . name in self . scratchpads : orphans = group . restore_state ( self . scratchpads . pop ( group . name ), self . restart ) self . orphans . extend ( orphans ) for sp_state in self . scratchpads . values (): for _ , wid , _ in sp_state : self . orphans . append ( wid ) if self . orphans : if self . restart : hook . subscribe . client_new ( self . handle_orphan_dropdowns ) else : for wid in self . orphans : win = qtile . windows_map [ wid ] if isinstance ( win , Window ): win . group = qtile . current_group qtile . focus_screen ( self . current_screen ) handle_orphan_dropdowns ( client ) Remove any windows from now non-existent scratchpad groups. Source code in libqtile/core/state.py 100 101 102 103 104 105 106 107 108 109 110 def handle_orphan_dropdowns ( self , client : Window | Static ) -> None : \"\"\" Remove any windows from now non-existent scratchpad groups. \"\"\" client_wid = client . wid if client_wid in self . orphans : self . orphans . remove ( client_wid ) if isinstance ( client , Window ): client . group = None if not self . orphans : hook . unsubscribe . client_new ( self . handle_orphan_dropdowns )","title":"state"},{"location":"reference/libqtile/core/state/#libqtile.core.state.QtileState","text":"Represents the state of the Qtile object This is used for restoring state across restarts or config reloads. If restart is True, the current set of groups will be saved in the state. This is useful when restarting for Qtile version updates rather than reloading the config. ScratchPad groups are saved for both reloading and restarting. Source code in libqtile/core/state.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , qtile : Qtile , restart : bool = True ) -> None : self . groups = [] self . screens = {} self . current_screen = 0 self . scratchpads = {} self . orphans : list [ int ] = [] self . restart = restart # True when restarting, False when config reloading for group in qtile . groups : if isinstance ( group , ScratchPad ): self . scratchpads [ group . name ] = group . get_state () elif restart : self . groups . append (( group . name , group . layout . name , group . label )) for index , screen in enumerate ( qtile . screens ): self . screens [ index ] = screen . group . name if screen == qtile . current_screen : self . current_screen = index","title":"QtileState"},{"location":"reference/libqtile/core/state/#libqtile.core.state.QtileState.apply","text":"Rearrange the windows in the specified Qtile object according to this QtileState. Source code in libqtile/core/state.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def apply ( self , qtile : Qtile ) -> None : \"\"\" Rearrange the windows in the specified Qtile object according to this QtileState. \"\"\" for ( group , layout , label ) in self . groups : try : qtile . groups_map [ group ] . layout = layout qtile . groups_map [ group ] . label = label except KeyError : qtile . add_group ( group , layout , label = label ) for ( screen , group ) in self . screens . items (): try : group = qtile . groups_map [ group ] qtile . screens [ screen ] . set_group ( group ) except ( KeyError , IndexError ): pass # group or screen missing for group in qtile . groups : if isinstance ( group , ScratchPad ) and group . name in self . scratchpads : orphans = group . restore_state ( self . scratchpads . pop ( group . name ), self . restart ) self . orphans . extend ( orphans ) for sp_state in self . scratchpads . values (): for _ , wid , _ in sp_state : self . orphans . append ( wid ) if self . orphans : if self . restart : hook . subscribe . client_new ( self . handle_orphan_dropdowns ) else : for wid in self . orphans : win = qtile . windows_map [ wid ] if isinstance ( win , Window ): win . group = qtile . current_group qtile . focus_screen ( self . current_screen )","title":"apply()"},{"location":"reference/libqtile/core/state/#libqtile.core.state.QtileState.handle_orphan_dropdowns","text":"Remove any windows from now non-existent scratchpad groups. Source code in libqtile/core/state.py 100 101 102 103 104 105 106 107 108 109 110 def handle_orphan_dropdowns ( self , client : Window | Static ) -> None : \"\"\" Remove any windows from now non-existent scratchpad groups. \"\"\" client_wid = client . wid if client_wid in self . orphans : self . orphans . remove ( client_wid ) if isinstance ( client , Window ): client . group = None if not self . orphans : hook . unsubscribe . client_new ( self . handle_orphan_dropdowns )","title":"handle_orphan_dropdowns()"},{"location":"reference/libqtile/extension/","text":"","title":"extension"},{"location":"reference/libqtile/extension/base/","text":"RunCommand ( ** config ) Bases: _Extension Run an arbitrary command. Mostly useful as a superclass for more specific extensions that need to interact with the qtile object. Also consider simply using lazy.spawn() or writing a client <http://docs.qtile.org/en/latest/manual/commands/scripting.html> _. Source code in libqtile/extension/base.py 106 107 108 109 def __init__ ( self , ** config ): _Extension . __init__ ( self , ** config ) self . add_defaults ( RunCommand . defaults ) self . configured_command = None run () An extension can inherit this class, define configured_command and use the process object by overriding this method and using super(): .. code-block:: python def _configure(self, qtile): Superclass._configure(self, qtile) self.configured_command = \"foo --bar\" def run(self): process = super(Subclass, self).run() Source code in libqtile/extension/base.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def run ( self ): \"\"\" An extension can inherit this class, define configured_command and use the process object by overriding this method and using super(): .. code-block:: python def _configure(self, qtile): Superclass._configure(self, qtile) self.configured_command = \"foo --bar\" def run(self): process = super(Subclass, self).run() \"\"\" if self . configured_command : if isinstance ( self . configured_command , str ): self . configured_command = shlex . split ( self . configured_command ) # Else assume that self.configured_command is already a sequence else : self . configured_command = self . command return Popen ( self . configured_command , stdout = PIPE , stdin = PIPE )","title":"base"},{"location":"reference/libqtile/extension/base/#libqtile.extension.base.RunCommand","text":"Bases: _Extension Run an arbitrary command. Mostly useful as a superclass for more specific extensions that need to interact with the qtile object. Also consider simply using lazy.spawn() or writing a client <http://docs.qtile.org/en/latest/manual/commands/scripting.html> _. Source code in libqtile/extension/base.py 106 107 108 109 def __init__ ( self , ** config ): _Extension . __init__ ( self , ** config ) self . add_defaults ( RunCommand . defaults ) self . configured_command = None","title":"RunCommand"},{"location":"reference/libqtile/extension/base/#libqtile.extension.base.RunCommand.run","text":"An extension can inherit this class, define configured_command and use the process object by overriding this method and using super(): .. code-block:: python def _configure(self, qtile): Superclass._configure(self, qtile) self.configured_command = \"foo --bar\" def run(self): process = super(Subclass, self).run() Source code in libqtile/extension/base.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def run ( self ): \"\"\" An extension can inherit this class, define configured_command and use the process object by overriding this method and using super(): .. code-block:: python def _configure(self, qtile): Superclass._configure(self, qtile) self.configured_command = \"foo --bar\" def run(self): process = super(Subclass, self).run() \"\"\" if self . configured_command : if isinstance ( self . configured_command , str ): self . configured_command = shlex . split ( self . configured_command ) # Else assume that self.configured_command is already a sequence else : self . configured_command = self . command return Popen ( self . configured_command , stdout = PIPE , stdin = PIPE )","title":"run()"},{"location":"reference/libqtile/extension/command_set/","text":"CommandSet ( ** config ) Bases: Dmenu Give list of commands to be executed in dmenu style. ex. manage mocp deamon: .. code-block:: python Key([mod], 'm', lazy.run_extension(extension.CommandSet( commands={ 'play/pause': '[ $(mocp -i | wc -l) -lt 2 ] && mocp -p || mocp -G', 'next': 'mocp -f', 'previous': 'mocp -r', 'quit': 'mocp -x', 'open': 'urxvt -e mocp', 'shuffle': 'mocp -t shuffle', 'repeat': 'mocp -t repeat', }, pre_commands=['[ $(mocp -i | wc -l) -lt 1 ] && mocp -S'], **Theme.dmenu))), Source code in libqtile/extension/command_set.py 52 53 54 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( CommandSet . defaults )","title":"command_set"},{"location":"reference/libqtile/extension/command_set/#libqtile.extension.command_set.CommandSet","text":"Bases: Dmenu Give list of commands to be executed in dmenu style. ex. manage mocp deamon: .. code-block:: python Key([mod], 'm', lazy.run_extension(extension.CommandSet( commands={ 'play/pause': '[ $(mocp -i | wc -l) -lt 2 ] && mocp -p || mocp -G', 'next': 'mocp -f', 'previous': 'mocp -r', 'quit': 'mocp -x', 'open': 'urxvt -e mocp', 'shuffle': 'mocp -t shuffle', 'repeat': 'mocp -t repeat', }, pre_commands=['[ $(mocp -i | wc -l) -lt 1 ] && mocp -S'], **Theme.dmenu))), Source code in libqtile/extension/command_set.py 52 53 54 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( CommandSet . defaults )","title":"CommandSet"},{"location":"reference/libqtile/extension/dmenu/","text":"Dmenu ( ** config ) Bases: base . RunCommand Python wrapper for dmenu http://tools.suckless.org/dmenu/ Source code in libqtile/extension/dmenu.py 50 51 52 def __init__ ( self , ** config ): base . RunCommand . __init__ ( self , ** config ) self . add_defaults ( Dmenu . defaults ) DmenuRun ( ** config ) Bases: Dmenu Special case to run applications. config.py should have something like: .. code-block:: python from libqtile import extension keys = [ Key(['mod4'], 'r', lazy.run_extension(extension.DmenuRun( dmenu_prompt=\">\", dmenu_font=\"Andika-8\", background=\"#15181a\", foreground=\"#00ff00\", selected_background=\"#079822\", selected_foreground=\"#fff\", dmenu_height=24, # Only supported by some dmenu forks ))), ] Source code in libqtile/extension/dmenu.py 136 137 138 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( DmenuRun . defaults ) J4DmenuDesktop ( ** config ) Bases: Dmenu Python wrapper for j4-dmenu-desktop https://github.com/enkore/j4-dmenu-desktop Source code in libqtile/extension/dmenu.py 160 161 162 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( J4DmenuDesktop . defaults )","title":"dmenu"},{"location":"reference/libqtile/extension/dmenu/#libqtile.extension.dmenu.Dmenu","text":"Bases: base . RunCommand Python wrapper for dmenu http://tools.suckless.org/dmenu/ Source code in libqtile/extension/dmenu.py 50 51 52 def __init__ ( self , ** config ): base . RunCommand . __init__ ( self , ** config ) self . add_defaults ( Dmenu . defaults )","title":"Dmenu"},{"location":"reference/libqtile/extension/dmenu/#libqtile.extension.dmenu.DmenuRun","text":"Bases: Dmenu Special case to run applications. config.py should have something like: .. code-block:: python from libqtile import extension keys = [ Key(['mod4'], 'r', lazy.run_extension(extension.DmenuRun( dmenu_prompt=\">\", dmenu_font=\"Andika-8\", background=\"#15181a\", foreground=\"#00ff00\", selected_background=\"#079822\", selected_foreground=\"#fff\", dmenu_height=24, # Only supported by some dmenu forks ))), ] Source code in libqtile/extension/dmenu.py 136 137 138 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( DmenuRun . defaults )","title":"DmenuRun"},{"location":"reference/libqtile/extension/dmenu/#libqtile.extension.dmenu.J4DmenuDesktop","text":"Bases: Dmenu Python wrapper for j4-dmenu-desktop https://github.com/enkore/j4-dmenu-desktop Source code in libqtile/extension/dmenu.py 160 161 162 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( J4DmenuDesktop . defaults )","title":"J4DmenuDesktop"},{"location":"reference/libqtile/extension/window_list/","text":"WindowList ( ** config ) Bases: Dmenu Give vertical list of all open windows in dmenu. Switch to selected. Source code in libqtile/extension/window_list.py 41 42 43 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( WindowList . defaults )","title":"window_list"},{"location":"reference/libqtile/extension/window_list/#libqtile.extension.window_list.WindowList","text":"Bases: Dmenu Give vertical list of all open windows in dmenu. Switch to selected. Source code in libqtile/extension/window_list.py 41 42 43 def __init__ ( self , ** config ): Dmenu . __init__ ( self , ** config ) self . add_defaults ( WindowList . defaults )","title":"WindowList"},{"location":"reference/libqtile/interactive/","text":"","title":"interactive"},{"location":"reference/libqtile/interactive/iqshell_install/","text":"","title":"iqshell_install"},{"location":"reference/libqtile/interactive/iqshell_kernel/","text":"","title":"iqshell_kernel"},{"location":"reference/libqtile/layout/","text":"","title":"layout"},{"location":"reference/libqtile/layout/base/","text":"Layout ( ** config ) Bases: CommandObject , configurable . Configurable This class defines the API that should be exposed by all layouts Source code in libqtile/layout/base.py 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , ** config ): # name is a little odd; we can't resolve it until the class is defined # (i.e., we can't figure it out to define it in Layout.defaults), so # we resolve it here instead. if \"name\" not in config : config [ \"name\" ] = self . __class__ . __name__ . lower () CommandObject . __init__ ( self ) configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( Layout . defaults ) add_client ( client ) abstractmethod Called whenever a window is added to the group Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring. Source code in libqtile/layout/base.py 110 111 112 113 114 115 116 117 118 @abstractmethod def add_client ( self , client ): \"\"\"Called whenever a window is added to the group Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring. \"\"\" pass blur () Called whenever focus is gone from this layout Source code in libqtile/layout/base.py 101 102 103 def blur ( self ): \"\"\"Called whenever focus is gone from this layout\"\"\" pass clone ( group ) Duplicate a layout Make a copy of this layout. This is done to provide each group with a unique instance of every layout. Parameters group: Group to attach new layout instance to. Source code in libqtile/layout/base.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def clone ( self , group ): \"\"\"Duplicate a layout Make a copy of this layout. This is done to provide each group with a unique instance of every layout. Parameters ========== group: Group to attach new layout instance to. \"\"\" c = copy . copy ( self ) c . group = group return c configure ( client , screen_rect ) abstractmethod Configure the layout This method should: - Configure the dimensions and borders of a window using the `.place()` method. - Call either `.hide()` or `.unhide()` on the window. Source code in libqtile/layout/base.py 132 133 134 135 136 137 138 139 140 141 142 @abstractmethod def configure ( self , client , screen_rect ): \"\"\"Configure the layout This method should: - Configure the dimensions and borders of a window using the `.place()` method. - Call either `.hide()` or `.unhide()` on the window. \"\"\" pass focus ( client ) Called whenever the focus changes Source code in libqtile/layout/base.py 97 98 99 def focus ( self , client ): \"\"\"Called whenever the focus changes\"\"\" pass focus_first () abstractmethod Called when the first client in Layout shall be focused. This method should: - Return the first client in Layout, if any. - Not focus the client itself, this is done by caller. Source code in libqtile/layout/base.py 144 145 146 147 148 149 150 151 152 @abstractmethod def focus_first ( self ): \"\"\"Called when the first client in Layout shall be focused. This method should: - Return the first client in Layout, if any. - Not focus the client itself, this is done by caller. \"\"\" pass focus_last () abstractmethod Called when the last client in Layout shall be focused. This method should: - Return the last client in Layout, if any. - Not focus the client itself, this is done by caller. Source code in libqtile/layout/base.py 154 155 156 157 158 159 160 161 162 @abstractmethod def focus_last ( self ): \"\"\"Called when the last client in Layout shall be focused. This method should: - Return the last client in Layout, if any. - Not focus the client itself, this is done by caller. \"\"\" pass focus_next ( win ) abstractmethod Called when the next client in Layout shall be focused. This method should: - Return the next client in Layout, if any. - Return None if the next client would be the first client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle. Parameters win: The currently focused client. Source code in libqtile/layout/base.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @abstractmethod def focus_next ( self , win ): \"\"\"Called when the next client in Layout shall be focused. This method should: - Return the next client in Layout, if any. - Return None if the next client would be the first client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle. Parameters ========== win: The currently focused client. \"\"\" pass focus_previous ( win ) abstractmethod Called when the previous client in Layout shall be focused. This method should: - Return the previous client in Layout, if any. - Return None if the previous client would be the last client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle. Parameters win: The currently focused client. Source code in libqtile/layout/base.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @abstractmethod def focus_previous ( self , win ): \"\"\"Called when the previous client in Layout shall be focused. This method should: - Return the previous client in Layout, if any. - Return None if the previous client would be the last client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle. Parameters ========== win: The currently focused client. \"\"\" pass hide () Called when layout is being hidden Source code in libqtile/layout/base.py 93 94 95 def hide ( self ): \"\"\"Called when layout is being hidden\"\"\" pass info () Returns a dictionary of layout information Source code in libqtile/layout/base.py 105 106 107 108 @expose_command () def info ( self ): \"\"\"Returns a dictionary of layout information\"\"\" return dict ( name = self . name , group = self . group . name if self . group else None ) remove ( client ) abstractmethod Called whenever a window is removed from the group Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window. Returns the \"next\" window that should gain focus or None. Source code in libqtile/layout/base.py 120 121 122 123 124 125 126 127 128 129 130 @abstractmethod def remove ( self , client ): \"\"\"Called whenever a window is removed from the group Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window. Returns the \"next\" window that should gain focus or None. \"\"\" pass show ( screen_rect ) Called when layout is being shown Source code in libqtile/layout/base.py 89 90 91 def show ( self , screen_rect ): \"\"\"Called when layout is being shown\"\"\" pass","title":"base"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout","text":"Bases: CommandObject , configurable . Configurable This class defines the API that should be exposed by all layouts Source code in libqtile/layout/base.py 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , ** config ): # name is a little odd; we can't resolve it until the class is defined # (i.e., we can't figure it out to define it in Layout.defaults), so # we resolve it here instead. if \"name\" not in config : config [ \"name\" ] = self . __class__ . __name__ . lower () CommandObject . __init__ ( self ) configurable . Configurable . __init__ ( self , ** config ) self . add_defaults ( Layout . defaults )","title":"Layout"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.add_client","text":"Called whenever a window is added to the group Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring. Source code in libqtile/layout/base.py 110 111 112 113 114 115 116 117 118 @abstractmethod def add_client ( self , client ): \"\"\"Called whenever a window is added to the group Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring. \"\"\" pass","title":"add_client()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.blur","text":"Called whenever focus is gone from this layout Source code in libqtile/layout/base.py 101 102 103 def blur ( self ): \"\"\"Called whenever focus is gone from this layout\"\"\" pass","title":"blur()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.clone","text":"Duplicate a layout Make a copy of this layout. This is done to provide each group with a unique instance of every layout.","title":"clone()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.clone--parameters","text":"group: Group to attach new layout instance to. Source code in libqtile/layout/base.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def clone ( self , group ): \"\"\"Duplicate a layout Make a copy of this layout. This is done to provide each group with a unique instance of every layout. Parameters ========== group: Group to attach new layout instance to. \"\"\" c = copy . copy ( self ) c . group = group return c","title":"Parameters"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.configure","text":"Configure the layout This method should: - Configure the dimensions and borders of a window using the `.place()` method. - Call either `.hide()` or `.unhide()` on the window. Source code in libqtile/layout/base.py 132 133 134 135 136 137 138 139 140 141 142 @abstractmethod def configure ( self , client , screen_rect ): \"\"\"Configure the layout This method should: - Configure the dimensions and borders of a window using the `.place()` method. - Call either `.hide()` or `.unhide()` on the window. \"\"\" pass","title":"configure()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus","text":"Called whenever the focus changes Source code in libqtile/layout/base.py 97 98 99 def focus ( self , client ): \"\"\"Called whenever the focus changes\"\"\" pass","title":"focus()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus_first","text":"Called when the first client in Layout shall be focused. This method should: - Return the first client in Layout, if any. - Not focus the client itself, this is done by caller. Source code in libqtile/layout/base.py 144 145 146 147 148 149 150 151 152 @abstractmethod def focus_first ( self ): \"\"\"Called when the first client in Layout shall be focused. This method should: - Return the first client in Layout, if any. - Not focus the client itself, this is done by caller. \"\"\" pass","title":"focus_first()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus_last","text":"Called when the last client in Layout shall be focused. This method should: - Return the last client in Layout, if any. - Not focus the client itself, this is done by caller. Source code in libqtile/layout/base.py 154 155 156 157 158 159 160 161 162 @abstractmethod def focus_last ( self ): \"\"\"Called when the last client in Layout shall be focused. This method should: - Return the last client in Layout, if any. - Not focus the client itself, this is done by caller. \"\"\" pass","title":"focus_last()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus_next","text":"Called when the next client in Layout shall be focused. This method should: - Return the next client in Layout, if any. - Return None if the next client would be the first client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.","title":"focus_next()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus_next--parameters","text":"win: The currently focused client. Source code in libqtile/layout/base.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @abstractmethod def focus_next ( self , win ): \"\"\"Called when the next client in Layout shall be focused. This method should: - Return the next client in Layout, if any. - Return None if the next client would be the first client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle. Parameters ========== win: The currently focused client. \"\"\" pass","title":"Parameters"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus_previous","text":"Called when the previous client in Layout shall be focused. This method should: - Return the previous client in Layout, if any. - Return None if the previous client would be the last client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.","title":"focus_previous()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.focus_previous--parameters","text":"win: The currently focused client. Source code in libqtile/layout/base.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @abstractmethod def focus_previous ( self , win ): \"\"\"Called when the previous client in Layout shall be focused. This method should: - Return the previous client in Layout, if any. - Return None if the previous client would be the last client. - Not focus the client itself, this is done by caller. Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle. Parameters ========== win: The currently focused client. \"\"\" pass","title":"Parameters"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.hide","text":"Called when layout is being hidden Source code in libqtile/layout/base.py 93 94 95 def hide ( self ): \"\"\"Called when layout is being hidden\"\"\" pass","title":"hide()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.info","text":"Returns a dictionary of layout information Source code in libqtile/layout/base.py 105 106 107 108 @expose_command () def info ( self ): \"\"\"Returns a dictionary of layout information\"\"\" return dict ( name = self . name , group = self . group . name if self . group else None )","title":"info()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.remove","text":"Called whenever a window is removed from the group Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window. Returns the \"next\" window that should gain focus or None. Source code in libqtile/layout/base.py 120 121 122 123 124 125 126 127 128 129 130 @abstractmethod def remove ( self , client ): \"\"\"Called whenever a window is removed from the group Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window. Returns the \"next\" window that should gain focus or None. \"\"\" pass","title":"remove()"},{"location":"reference/libqtile/layout/base/#libqtile.layout.base.Layout.show","text":"Called when layout is being shown Source code in libqtile/layout/base.py 89 90 91 def show ( self , screen_rect ): \"\"\"Called when layout is being shown\"\"\" pass","title":"show()"},{"location":"reference/libqtile/layout/bsp/","text":"Bsp ( ** config ) Bases: Layout This layout is inspired by bspwm, but it does not try to copy its features. The first client occupies the entire screen space. When a new client is created, the selected space is partitioned in 2 and the new client occupies one of those subspaces, leaving the old client with the other. The partition can be either horizontal or vertical according to the dimensions of the current space: if its width/height ratio is above a pre-configured value, the subspaces are created side-by-side, otherwise, they are created on top of each other. The partition direction can be freely toggled. All subspaces can be resized and clients can be shuffled around. All clients are organized at the leaves of a full binary tree. An example key configuration is:: Key([mod], \"j\", lazy.layout.down()), Key([mod], \"k\", lazy.layout.up()), Key([mod], \"h\", lazy.layout.left()), Key([mod], \"l\", lazy.layout.right()), Key([mod, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([mod, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([mod, \"shift\"], \"h\", lazy.layout.shuffle_left()), Key([mod, \"shift\"], \"l\", lazy.layout.shuffle_right()), Key([mod, \"mod1\"], \"j\", lazy.layout.flip_down()), Key([mod, \"mod1\"], \"k\", lazy.layout.flip_up()), Key([mod, \"mod1\"], \"h\", lazy.layout.flip_left()), Key([mod, \"mod1\"], \"l\", lazy.layout.flip_right()), Key([mod, \"control\"], \"j\", lazy.layout.grow_down()), Key([mod, \"control\"], \"k\", lazy.layout.grow_up()), Key([mod, \"control\"], \"h\", lazy.layout.grow_left()), Key([mod, \"control\"], \"l\", lazy.layout.grow_right()), Key([mod, \"shift\"], \"n\", lazy.layout.normalize()), Key([mod], \"Return\", lazy.layout.toggle_split()), Source code in libqtile/layout/bsp.py 174 175 176 177 178 179 180 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( Bsp . defaults ) self . root = _BspNode () self . current = self . root if self . margin_on_single is None : self . margin_on_single = self . margin","title":"bsp"},{"location":"reference/libqtile/layout/bsp/#libqtile.layout.bsp.Bsp","text":"Bases: Layout This layout is inspired by bspwm, but it does not try to copy its features. The first client occupies the entire screen space. When a new client is created, the selected space is partitioned in 2 and the new client occupies one of those subspaces, leaving the old client with the other. The partition can be either horizontal or vertical according to the dimensions of the current space: if its width/height ratio is above a pre-configured value, the subspaces are created side-by-side, otherwise, they are created on top of each other. The partition direction can be freely toggled. All subspaces can be resized and clients can be shuffled around. All clients are organized at the leaves of a full binary tree. An example key configuration is:: Key([mod], \"j\", lazy.layout.down()), Key([mod], \"k\", lazy.layout.up()), Key([mod], \"h\", lazy.layout.left()), Key([mod], \"l\", lazy.layout.right()), Key([mod, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([mod, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([mod, \"shift\"], \"h\", lazy.layout.shuffle_left()), Key([mod, \"shift\"], \"l\", lazy.layout.shuffle_right()), Key([mod, \"mod1\"], \"j\", lazy.layout.flip_down()), Key([mod, \"mod1\"], \"k\", lazy.layout.flip_up()), Key([mod, \"mod1\"], \"h\", lazy.layout.flip_left()), Key([mod, \"mod1\"], \"l\", lazy.layout.flip_right()), Key([mod, \"control\"], \"j\", lazy.layout.grow_down()), Key([mod, \"control\"], \"k\", lazy.layout.grow_up()), Key([mod, \"control\"], \"h\", lazy.layout.grow_left()), Key([mod, \"control\"], \"l\", lazy.layout.grow_right()), Key([mod, \"shift\"], \"n\", lazy.layout.normalize()), Key([mod], \"Return\", lazy.layout.toggle_split()), Source code in libqtile/layout/bsp.py 174 175 176 177 178 179 180 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( Bsp . defaults ) self . root = _BspNode () self . current = self . root if self . margin_on_single is None : self . margin_on_single = self . margin","title":"Bsp"},{"location":"reference/libqtile/layout/columns/","text":"Columns ( ** config ) Bases: Layout Extension of the Stack layout. The screen is split into columns, which can be dynamically added or removed. Each column can present its windows in 2 modes: split or stacked. In split mode, all windows are presented simultaneously, spliting the column space. In stacked mode, only a single window is presented from the stack of windows. Columns and windows can be resized and windows can be shuffled around. This layout can also emulate wmii's default layout via: layout.Columns(num_columns=1, insert_position=1) Or the \"Vertical\", and \"Max\", depending on the default parameters. An example key configuration is:: Key([mod], \"j\", lazy.layout.down()), Key([mod], \"k\", lazy.layout.up()), Key([mod], \"h\", lazy.layout.left()), Key([mod], \"l\", lazy.layout.right()), Key([mod, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([mod, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([mod, \"shift\"], \"h\", lazy.layout.shuffle_left()), Key([mod, \"shift\"], \"l\", lazy.layout.shuffle_right()), Key([mod, \"control\"], \"j\", lazy.layout.grow_down()), Key([mod, \"control\"], \"k\", lazy.layout.grow_up()), Key([mod, \"control\"], \"h\", lazy.layout.grow_left()), Key([mod, \"control\"], \"l\", lazy.layout.grow_right()), Key([mod, \"shift\", \"control\"], \"h\", lazy.layout.swap_column_left()), Key([mod, \"shift\", \"control\"], \"l\", lazy.layout.swap_column_right()), Key([mod], \"Return\", lazy.layout.toggle_split()), Key([mod], \"n\", lazy.layout.normalize()), Source code in libqtile/layout/columns.py 156 157 158 159 160 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( Columns . defaults ) self . columns = [ _Column ( self . split , self . insert_position )] self . current = 0 focus_first () Returns first client in first column of layout Source code in libqtile/layout/columns.py 292 293 294 295 def focus_first ( self ): \"\"\"Returns first client in first column of layout\"\"\" if self . columns : return self . columns [ 0 ] . focus_first () focus_last () Returns last client in last column of layout Source code in libqtile/layout/columns.py 297 298 299 300 def focus_last ( self ): \"\"\"Returns last client in last column of layout\"\"\" if self . columns : return self . columns [ - 1 ] . focus_last () focus_next ( win ) Returns the next client after 'win' in layout, or None if there is no such client Source code in libqtile/layout/columns.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def focus_next ( self , win ): \"\"\"Returns the next client after 'win' in layout, or None if there is no such client\"\"\" # First: try to get next window in column of win (self.columns is non-empty) # pylint: disable=undefined-loop-variable for idx , col in enumerate ( self . columns ): if win in col : nxt = col . focus_next ( win ) if nxt : return nxt else : break # if there was no next, get first client from next column if idx + 1 < len ( self . columns ): return self . columns [ idx + 1 ] . focus_first () focus_previous ( win ) Returns the client previous to 'win' in layout. or None if there is no such client Source code in libqtile/layout/columns.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def focus_previous ( self , win ): \"\"\"Returns the client previous to 'win' in layout. or None if there is no such client\"\"\" # First: try to focus previous client in column (self.columns is non-empty) # pylint: disable=undefined-loop-variable for idx , col in enumerate ( self . columns ): if win in col : prev = col . focus_previous ( win ) if prev : return prev else : break # If there was no previous, get last from previous column if idx > 0 : return self . columns [ idx - 1 ] . focus_last ()","title":"columns"},{"location":"reference/libqtile/layout/columns/#libqtile.layout.columns.Columns","text":"Bases: Layout Extension of the Stack layout. The screen is split into columns, which can be dynamically added or removed. Each column can present its windows in 2 modes: split or stacked. In split mode, all windows are presented simultaneously, spliting the column space. In stacked mode, only a single window is presented from the stack of windows. Columns and windows can be resized and windows can be shuffled around. This layout can also emulate wmii's default layout via: layout.Columns(num_columns=1, insert_position=1) Or the \"Vertical\", and \"Max\", depending on the default parameters. An example key configuration is:: Key([mod], \"j\", lazy.layout.down()), Key([mod], \"k\", lazy.layout.up()), Key([mod], \"h\", lazy.layout.left()), Key([mod], \"l\", lazy.layout.right()), Key([mod, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([mod, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([mod, \"shift\"], \"h\", lazy.layout.shuffle_left()), Key([mod, \"shift\"], \"l\", lazy.layout.shuffle_right()), Key([mod, \"control\"], \"j\", lazy.layout.grow_down()), Key([mod, \"control\"], \"k\", lazy.layout.grow_up()), Key([mod, \"control\"], \"h\", lazy.layout.grow_left()), Key([mod, \"control\"], \"l\", lazy.layout.grow_right()), Key([mod, \"shift\", \"control\"], \"h\", lazy.layout.swap_column_left()), Key([mod, \"shift\", \"control\"], \"l\", lazy.layout.swap_column_right()), Key([mod], \"Return\", lazy.layout.toggle_split()), Key([mod], \"n\", lazy.layout.normalize()), Source code in libqtile/layout/columns.py 156 157 158 159 160 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( Columns . defaults ) self . columns = [ _Column ( self . split , self . insert_position )] self . current = 0","title":"Columns"},{"location":"reference/libqtile/layout/columns/#libqtile.layout.columns.Columns.focus_first","text":"Returns first client in first column of layout Source code in libqtile/layout/columns.py 292 293 294 295 def focus_first ( self ): \"\"\"Returns first client in first column of layout\"\"\" if self . columns : return self . columns [ 0 ] . focus_first ()","title":"focus_first()"},{"location":"reference/libqtile/layout/columns/#libqtile.layout.columns.Columns.focus_last","text":"Returns last client in last column of layout Source code in libqtile/layout/columns.py 297 298 299 300 def focus_last ( self ): \"\"\"Returns last client in last column of layout\"\"\" if self . columns : return self . columns [ - 1 ] . focus_last ()","title":"focus_last()"},{"location":"reference/libqtile/layout/columns/#libqtile.layout.columns.Columns.focus_next","text":"Returns the next client after 'win' in layout, or None if there is no such client Source code in libqtile/layout/columns.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def focus_next ( self , win ): \"\"\"Returns the next client after 'win' in layout, or None if there is no such client\"\"\" # First: try to get next window in column of win (self.columns is non-empty) # pylint: disable=undefined-loop-variable for idx , col in enumerate ( self . columns ): if win in col : nxt = col . focus_next ( win ) if nxt : return nxt else : break # if there was no next, get first client from next column if idx + 1 < len ( self . columns ): return self . columns [ idx + 1 ] . focus_first ()","title":"focus_next()"},{"location":"reference/libqtile/layout/columns/#libqtile.layout.columns.Columns.focus_previous","text":"Returns the client previous to 'win' in layout. or None if there is no such client Source code in libqtile/layout/columns.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def focus_previous ( self , win ): \"\"\"Returns the client previous to 'win' in layout. or None if there is no such client\"\"\" # First: try to focus previous client in column (self.columns is non-empty) # pylint: disable=undefined-loop-variable for idx , col in enumerate ( self . columns ): if win in col : prev = col . focus_previous ( win ) if prev : return prev else : break # If there was no previous, get last from previous column if idx > 0 : return self . columns [ idx - 1 ] . focus_last ()","title":"focus_previous()"},{"location":"reference/libqtile/layout/floating/","text":"Floating ( float_rules = None , no_reposition_rules = None , ** config ) Bases: Layout Floating layout, which does nothing with windows but handles focus order Match objects:: from libqtile.config import Match Match(title=WM_NAME, wm_class=WM_CLASS, role=WM_WINDOW_ROLE) When a new window is opened its match method is called with each of these rules. If one matches, the window will float. The following will float GIMP and Skype:: from libqtile.config import Match float_rules=[Match(wm_class=\"skype\"), Match(wm_class=\"gimp\")] The following Match will float all windows that are transient windows for a parent window: Match(func=lambda c: bool(c.is_transient_for())) Specify these in the floating_layout in your config. Floating layout will try to center most of floating windows by default, but if you don't want this to happen for certain windows that are centered by mistake, you can use no_reposition_rules option to specify them and layout will rely on windows to position themselves in correct location on the screen. Source code in libqtile/layout/floating.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , float_rules : list [ Match ] | None = None , no_reposition_rules = None , ** config ): \"\"\" If you have certain apps that you always want to float you can provide ``float_rules`` to do so. ``float_rules`` are a list of Match objects:: from libqtile.config import Match Match(title=WM_NAME, wm_class=WM_CLASS, role=WM_WINDOW_ROLE) When a new window is opened its ``match`` method is called with each of these rules. If one matches, the window will float. The following will float GIMP and Skype:: from libqtile.config import Match float_rules=[Match(wm_class=\"skype\"), Match(wm_class=\"gimp\")] The following ``Match`` will float all windows that are transient windows for a parent window: Match(func=lambda c: bool(c.is_transient_for())) Specify these in the ``floating_layout`` in your config. Floating layout will try to center most of floating windows by default, but if you don't want this to happen for certain windows that are centered by mistake, you can use ``no_reposition_rules`` option to specify them and layout will rely on windows to position themselves in correct location on the screen. \"\"\" Layout . __init__ ( self , ** config ) self . clients : list [ Window ] = [] self . focused = None self . group = None if float_rules is None : float_rules = self . default_float_rules self . float_rules = float_rules self . no_reposition_rules = no_reposition_rules or [] self . add_defaults ( Floating . defaults ) compute_client_position ( client , screen_rect ) recompute client.x and client.y, returning whether or not to place this client above other windows or not Source code in libqtile/layout/floating.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def compute_client_position ( self , client , screen_rect ): \"\"\"recompute client.x and client.y, returning whether or not to place this client above other windows or not\"\"\" above = True if client . has_user_set_position () and not self . on_screen ( client , screen_rect ): # move to screen client . x = screen_rect . x + client . x client . y = screen_rect . y + client . y if not client . has_user_set_position () or not self . on_screen ( client , screen_rect ): # client has not been properly placed before or it is off screen transient_for = client . is_transient_for () if transient_for is not None : # if transient for a window, place in the center of the window center_x = transient_for . x + transient_for . width / 2 center_y = transient_for . y + transient_for . height / 2 above = False else : center_x = screen_rect . x + screen_rect . width / 2 center_y = screen_rect . y + screen_rect . height / 2 x = center_x - client . width / 2 y = center_y - client . height / 2 # don't go off the right... x = min ( x , screen_rect . x + screen_rect . width - client . width ) # or left... x = max ( x , screen_rect . x ) # or bottom... y = min ( y , screen_rect . y + screen_rect . height - client . height ) # or top y = max ( y , screen_rect . y ) client . x = int ( round ( x )) client . y = int ( round ( y )) return above find_clients ( group ) Find all clients belonging to a given group Source code in libqtile/layout/floating.py 117 118 119 def find_clients ( self , group ): \"\"\"Find all clients belonging to a given group\"\"\" return [ c for c in self . clients if c . group is group ] match ( win ) Used to default float some windows Source code in libqtile/layout/floating.py 113 114 115 def match ( self , win ): \"\"\"Used to default float some windows\"\"\" return any ( win . match ( rule ) for rule in self . float_rules ) to_screen ( group , new_screen ) Adjust offsets of clients within current screen Source code in libqtile/layout/floating.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def to_screen ( self , group , new_screen ): \"\"\"Adjust offsets of clients within current screen\"\"\" for win in self . find_clients ( group ): if win . maximized : win . maximized = True elif win . fullscreen : win . fullscreen = True else : # If the window hasn't been floated before, it will be configured in # .configure() if win . float_x is not None and win . float_y is not None : # By default, place window at same offset from top corner new_x = new_screen . x + win . float_x new_y = new_screen . y + win . float_y # make sure window isn't off screen left/right... new_x = min ( new_x , new_screen . x + new_screen . width - win . width ) new_x = max ( new_x , new_screen . x ) # and up/down new_y = min ( new_y , new_screen . y + new_screen . height - win . height ) new_y = max ( new_y , new_screen . y ) win . x = new_x win . y = new_y win . group = new_screen . group","title":"floating"},{"location":"reference/libqtile/layout/floating/#libqtile.layout.floating.Floating","text":"Bases: Layout Floating layout, which does nothing with windows but handles focus order Match objects:: from libqtile.config import Match Match(title=WM_NAME, wm_class=WM_CLASS, role=WM_WINDOW_ROLE) When a new window is opened its match method is called with each of these rules. If one matches, the window will float. The following will float GIMP and Skype:: from libqtile.config import Match float_rules=[Match(wm_class=\"skype\"), Match(wm_class=\"gimp\")] The following Match will float all windows that are transient windows for a parent window: Match(func=lambda c: bool(c.is_transient_for())) Specify these in the floating_layout in your config. Floating layout will try to center most of floating windows by default, but if you don't want this to happen for certain windows that are centered by mistake, you can use no_reposition_rules option to specify them and layout will rely on windows to position themselves in correct location on the screen. Source code in libqtile/layout/floating.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , float_rules : list [ Match ] | None = None , no_reposition_rules = None , ** config ): \"\"\" If you have certain apps that you always want to float you can provide ``float_rules`` to do so. ``float_rules`` are a list of Match objects:: from libqtile.config import Match Match(title=WM_NAME, wm_class=WM_CLASS, role=WM_WINDOW_ROLE) When a new window is opened its ``match`` method is called with each of these rules. If one matches, the window will float. The following will float GIMP and Skype:: from libqtile.config import Match float_rules=[Match(wm_class=\"skype\"), Match(wm_class=\"gimp\")] The following ``Match`` will float all windows that are transient windows for a parent window: Match(func=lambda c: bool(c.is_transient_for())) Specify these in the ``floating_layout`` in your config. Floating layout will try to center most of floating windows by default, but if you don't want this to happen for certain windows that are centered by mistake, you can use ``no_reposition_rules`` option to specify them and layout will rely on windows to position themselves in correct location on the screen. \"\"\" Layout . __init__ ( self , ** config ) self . clients : list [ Window ] = [] self . focused = None self . group = None if float_rules is None : float_rules = self . default_float_rules self . float_rules = float_rules self . no_reposition_rules = no_reposition_rules or [] self . add_defaults ( Floating . defaults )","title":"Floating"},{"location":"reference/libqtile/layout/floating/#libqtile.layout.floating.Floating.compute_client_position","text":"recompute client.x and client.y, returning whether or not to place this client above other windows or not Source code in libqtile/layout/floating.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def compute_client_position ( self , client , screen_rect ): \"\"\"recompute client.x and client.y, returning whether or not to place this client above other windows or not\"\"\" above = True if client . has_user_set_position () and not self . on_screen ( client , screen_rect ): # move to screen client . x = screen_rect . x + client . x client . y = screen_rect . y + client . y if not client . has_user_set_position () or not self . on_screen ( client , screen_rect ): # client has not been properly placed before or it is off screen transient_for = client . is_transient_for () if transient_for is not None : # if transient for a window, place in the center of the window center_x = transient_for . x + transient_for . width / 2 center_y = transient_for . y + transient_for . height / 2 above = False else : center_x = screen_rect . x + screen_rect . width / 2 center_y = screen_rect . y + screen_rect . height / 2 x = center_x - client . width / 2 y = center_y - client . height / 2 # don't go off the right... x = min ( x , screen_rect . x + screen_rect . width - client . width ) # or left... x = max ( x , screen_rect . x ) # or bottom... y = min ( y , screen_rect . y + screen_rect . height - client . height ) # or top y = max ( y , screen_rect . y ) client . x = int ( round ( x )) client . y = int ( round ( y )) return above","title":"compute_client_position()"},{"location":"reference/libqtile/layout/floating/#libqtile.layout.floating.Floating.find_clients","text":"Find all clients belonging to a given group Source code in libqtile/layout/floating.py 117 118 119 def find_clients ( self , group ): \"\"\"Find all clients belonging to a given group\"\"\" return [ c for c in self . clients if c . group is group ]","title":"find_clients()"},{"location":"reference/libqtile/layout/floating/#libqtile.layout.floating.Floating.match","text":"Used to default float some windows Source code in libqtile/layout/floating.py 113 114 115 def match ( self , win ): \"\"\"Used to default float some windows\"\"\" return any ( win . match ( rule ) for rule in self . float_rules )","title":"match()"},{"location":"reference/libqtile/layout/floating/#libqtile.layout.floating.Floating.to_screen","text":"Adjust offsets of clients within current screen Source code in libqtile/layout/floating.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def to_screen ( self , group , new_screen ): \"\"\"Adjust offsets of clients within current screen\"\"\" for win in self . find_clients ( group ): if win . maximized : win . maximized = True elif win . fullscreen : win . fullscreen = True else : # If the window hasn't been floated before, it will be configured in # .configure() if win . float_x is not None and win . float_y is not None : # By default, place window at same offset from top corner new_x = new_screen . x + win . float_x new_y = new_screen . y + win . float_y # make sure window isn't off screen left/right... new_x = min ( new_x , new_screen . x + new_screen . width - win . width ) new_x = max ( new_x , new_screen . x ) # and up/down new_y = min ( new_y , new_screen . y + new_screen . height - win . height ) new_y = max ( new_y , new_screen . y ) win . x = new_x win . y = new_y win . group = new_screen . group","title":"to_screen()"},{"location":"reference/libqtile/layout/matrix/","text":"Matrix ( _columns = None , ** config ) Bases: _SimpleLayoutBase This layout divides the screen into a matrix of equally sized cells and places one window in each cell. The number of columns is configurable and can also be changed interactively. Source code in libqtile/layout/matrix.py 51 52 53 54 55 56 57 58 59 def __init__ ( self , _columns : int | None = None , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Matrix . defaults ) if _columns : logger . warning ( \"The use of a positional argument in Matrix is deprecated. \" \"Please update your config to use columns=...\" ) self . columns = _columns add () Increase number of columns Source code in libqtile/layout/matrix.py 188 189 190 191 192 @expose_command () def add ( self ): \"\"\"Increase number of columns\"\"\" self . columns += 1 self . group . layout_all () add_client ( client ) Add client to Layout. Note that for Matrix the clients are appended at end of list. If needed a new row in matrix is created Source code in libqtile/layout/matrix.py 98 99 100 101 102 def add_client ( self , client ): \"\"\"Add client to Layout. Note that for Matrix the clients are appended at end of list. If needed a new row in matrix is created\"\"\" return self . clients . append ( client ) column () property Calc column index of current client Source code in libqtile/layout/matrix.py 71 72 73 74 @property def column ( self ): \"\"\"Calc column index of current client\"\"\" return self . clients . current_index % self . columns delete () Decrease number of columns Source code in libqtile/layout/matrix.py 182 183 184 185 186 @expose_command () def delete ( self ): \"\"\"Decrease number of columns\"\"\" self . columns -= 1 self . group . layout_all () down () Switch to the next window in current column Source code in libqtile/layout/matrix.py 177 178 179 180 @expose_command () def down ( self ): \"\"\"Switch to the next window in current column\"\"\" self . vertical_traversal ( + 1 ) get_column ( column ) Get all clients in given column Source code in libqtile/layout/matrix.py 93 94 95 96 def get_column ( self , column ): \"\"\"Get all clients in given column\"\"\" assert column < self . columns return [ self . clients [ i ] for i in range ( column , len ( self . clients ), self . columns )] get_row ( row ) Get all clients in given row Source code in libqtile/layout/matrix.py 88 89 90 91 def get_row ( self , row ): \"\"\"Get all clients in given row\"\"\" assert row < self . rows return self . clients [ row * self . columns : row * self . columns + self . columns ] horizontal_traversal ( direction ) Internal method for determining left or right client. Negative direction is to left Source code in libqtile/layout/matrix.py 142 143 144 145 146 147 148 149 150 def horizontal_traversal ( self , direction ): \"\"\" Internal method for determining left or right client. Negative direction is to left \"\"\" column , row = self . column , self . row column = ( column + direction ) % len ( self . get_row ( row )) self . clients . current_index = row * self . columns + column self . group . focus ( self . clients . current_client ) left () Switch to the next window on current row Source code in libqtile/layout/matrix.py 162 163 164 165 @expose_command () def left ( self ): \"\"\"Switch to the next window on current row\"\"\" self . horizontal_traversal ( - 1 ) right () Switch to the next window on current row Source code in libqtile/layout/matrix.py 167 168 169 170 @expose_command () def right ( self ): \"\"\"Switch to the next window on current row\"\"\" self . horizontal_traversal ( + 1 ) row () property Calc row index of current client Source code in libqtile/layout/matrix.py 66 67 68 69 @property def row ( self ): \"\"\"Calc row index of current client\"\"\" return self . clients . current_index // self . columns rows () property Calc current number of rows, basd on number of clients and columns Source code in libqtile/layout/matrix.py 61 62 63 64 @property def rows ( self ): \"\"\"Calc current number of rows, basd on number of clients and columns\"\"\" return int ( math . ceil ( len ( self . clients ) / self . columns )) up () Switch to the previous window in current column Source code in libqtile/layout/matrix.py 172 173 174 175 @expose_command () def up ( self ): \"\"\"Switch to the previous window in current column\"\"\" self . vertical_traversal ( - 1 ) vertical_traversal ( direction ) internal method for determining above or below client. Negative direction is to top Source code in libqtile/layout/matrix.py 152 153 154 155 156 157 158 159 160 def vertical_traversal ( self , direction ): \"\"\" internal method for determining above or below client. Negative direction is to top \"\"\" column , row = self . column , self . row row = ( row + direction ) % len ( self . get_column ( column )) self . clients . current_index = row * self . columns + column self . group . focus ( self . clients . current_client )","title":"matrix"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix","text":"Bases: _SimpleLayoutBase This layout divides the screen into a matrix of equally sized cells and places one window in each cell. The number of columns is configurable and can also be changed interactively. Source code in libqtile/layout/matrix.py 51 52 53 54 55 56 57 58 59 def __init__ ( self , _columns : int | None = None , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Matrix . defaults ) if _columns : logger . warning ( \"The use of a positional argument in Matrix is deprecated. \" \"Please update your config to use columns=...\" ) self . columns = _columns","title":"Matrix"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.add","text":"Increase number of columns Source code in libqtile/layout/matrix.py 188 189 190 191 192 @expose_command () def add ( self ): \"\"\"Increase number of columns\"\"\" self . columns += 1 self . group . layout_all ()","title":"add()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.add_client","text":"Add client to Layout. Note that for Matrix the clients are appended at end of list. If needed a new row in matrix is created Source code in libqtile/layout/matrix.py 98 99 100 101 102 def add_client ( self , client ): \"\"\"Add client to Layout. Note that for Matrix the clients are appended at end of list. If needed a new row in matrix is created\"\"\" return self . clients . append ( client )","title":"add_client()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.column","text":"Calc column index of current client Source code in libqtile/layout/matrix.py 71 72 73 74 @property def column ( self ): \"\"\"Calc column index of current client\"\"\" return self . clients . current_index % self . columns","title":"column()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.delete","text":"Decrease number of columns Source code in libqtile/layout/matrix.py 182 183 184 185 186 @expose_command () def delete ( self ): \"\"\"Decrease number of columns\"\"\" self . columns -= 1 self . group . layout_all ()","title":"delete()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.down","text":"Switch to the next window in current column Source code in libqtile/layout/matrix.py 177 178 179 180 @expose_command () def down ( self ): \"\"\"Switch to the next window in current column\"\"\" self . vertical_traversal ( + 1 )","title":"down()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.get_column","text":"Get all clients in given column Source code in libqtile/layout/matrix.py 93 94 95 96 def get_column ( self , column ): \"\"\"Get all clients in given column\"\"\" assert column < self . columns return [ self . clients [ i ] for i in range ( column , len ( self . clients ), self . columns )]","title":"get_column()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.get_row","text":"Get all clients in given row Source code in libqtile/layout/matrix.py 88 89 90 91 def get_row ( self , row ): \"\"\"Get all clients in given row\"\"\" assert row < self . rows return self . clients [ row * self . columns : row * self . columns + self . columns ]","title":"get_row()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.horizontal_traversal","text":"Internal method for determining left or right client. Negative direction is to left Source code in libqtile/layout/matrix.py 142 143 144 145 146 147 148 149 150 def horizontal_traversal ( self , direction ): \"\"\" Internal method for determining left or right client. Negative direction is to left \"\"\" column , row = self . column , self . row column = ( column + direction ) % len ( self . get_row ( row )) self . clients . current_index = row * self . columns + column self . group . focus ( self . clients . current_client )","title":"horizontal_traversal()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.left","text":"Switch to the next window on current row Source code in libqtile/layout/matrix.py 162 163 164 165 @expose_command () def left ( self ): \"\"\"Switch to the next window on current row\"\"\" self . horizontal_traversal ( - 1 )","title":"left()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.right","text":"Switch to the next window on current row Source code in libqtile/layout/matrix.py 167 168 169 170 @expose_command () def right ( self ): \"\"\"Switch to the next window on current row\"\"\" self . horizontal_traversal ( + 1 )","title":"right()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.row","text":"Calc row index of current client Source code in libqtile/layout/matrix.py 66 67 68 69 @property def row ( self ): \"\"\"Calc row index of current client\"\"\" return self . clients . current_index // self . columns","title":"row()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.rows","text":"Calc current number of rows, basd on number of clients and columns Source code in libqtile/layout/matrix.py 61 62 63 64 @property def rows ( self ): \"\"\"Calc current number of rows, basd on number of clients and columns\"\"\" return int ( math . ceil ( len ( self . clients ) / self . columns ))","title":"rows()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.up","text":"Switch to the previous window in current column Source code in libqtile/layout/matrix.py 172 173 174 175 @expose_command () def up ( self ): \"\"\"Switch to the previous window in current column\"\"\" self . vertical_traversal ( - 1 )","title":"up()"},{"location":"reference/libqtile/layout/matrix/#libqtile.layout.matrix.Matrix.vertical_traversal","text":"internal method for determining above or below client. Negative direction is to top Source code in libqtile/layout/matrix.py 152 153 154 155 156 157 158 159 160 def vertical_traversal ( self , direction ): \"\"\" internal method for determining above or below client. Negative direction is to top \"\"\" column , row = self . column , self . row row = ( row + direction ) % len ( self . get_column ( column )) self . clients . current_index = row * self . columns + column self . group . focus ( self . clients . current_client )","title":"vertical_traversal()"},{"location":"reference/libqtile/layout/max/","text":"Max ( ** config ) Bases: _SimpleLayoutBase Maximized layout A simple layout that only displays one window at a time, filling the screen_rect. This is suitable for use on laptops and other devices with small screens. Conceptually, the windows are managed as a stack, with commands to switch to next and previous windows in the stack. Source code in libqtile/layout/max.py 42 43 44 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Max . defaults )","title":"max"},{"location":"reference/libqtile/layout/max/#libqtile.layout.max.Max","text":"Bases: _SimpleLayoutBase Maximized layout A simple layout that only displays one window at a time, filling the screen_rect. This is suitable for use on laptops and other devices with small screens. Conceptually, the windows are managed as a stack, with commands to switch to next and previous windows in the stack. Source code in libqtile/layout/max.py 42 43 44 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Max . defaults )","title":"Max"},{"location":"reference/libqtile/layout/ratiotile/","text":"GridInfo ( ratio , num_windows , width , height ) Calculates sizes for grids gi = GridInfo(.5, 5, 600, 480) gi.calc() (1, 5, 1) gi.get_sizes() [(0, 0, 120, 480), (120, 0, 120, 480), (240, 0, 120, 480), (360, 0, 120, 480), (480, 0, 120, 480)] gi = GridInfo(6, 5, 600, 480) gi.get_sizes() [(0, 0, 600, 96), (0, 96, 600, 96), (0, 192, 600, 96), (0, 288, 600, 96), (0, 384, 600, 96)] gi = GridInfo(1, 5, 600, 480) gi.get_sizes() [(0, 0, 200, 240), (200, 0, 200, 240), (400, 0, 200, 240), (0, 240, 300, 240), (200, 240, 200, 240)] foo = GridInfo(1.6, 7, 400,370) foo.get_sizes(500,580) Source code in libqtile/layout/ratiotile.py 62 63 64 65 66 67 68 def __init__ ( self , ratio , num_windows , width , height ): self . ratio = ratio self . num_windows = num_windows self . width = width self . height = height self . num_rows = 0 self . num_cols = 0 calc ( num_windows , width , height ) returns (rows, cols, orientation) tuple given input Source code in libqtile/layout/ratiotile.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def calc ( self , num_windows , width , height ): \"\"\"returns (rows, cols, orientation) tuple given input\"\"\" best_ratio = None best_rows_cols_orientation = None for rows , cols , orientation in self . _possible_grids ( num_windows ): sample_width = width / cols sample_height = height / rows sample_ratio = sample_width / sample_height diff = abs ( sample_ratio - self . ratio ) if best_ratio is None or diff < best_ratio : best_ratio = diff best_rows_cols_orientation = ( rows , cols , orientation ) return best_rows_cols_orientation get_sizes_advanced ( total_width , total_height , xoffset = 0 , yoffset = 0 ) after every row/column recalculate remaining area Source code in libqtile/layout/ratiotile.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def get_sizes_advanced ( self , total_width , total_height , xoffset = 0 , yoffset = 0 ): \"\"\"after every row/column recalculate remaining area\"\"\" results = [] width = total_width height = total_height while len ( results ) < self . num_windows : remaining = self . num_windows - len ( results ) orien , sizes = self . _get_row_or_col ( remaining , width , height , xoffset , yoffset ) results . extend ( sizes ) if orien == ROWCOL : # adjust height/yoffset height -= sizes [ - 1 ][ - 1 ] yoffset += sizes [ - 1 ][ - 1 ] else : width -= sizes [ - 1 ][ - 2 ] xoffset += sizes [ - 1 ][ - 2 ] return results RatioTile ( ** config ) Bases: _SimpleLayoutBase Tries to tile all windows in the width/height ratio passed in Source code in libqtile/layout/ratiotile.py 214 215 216 217 218 219 220 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( RatioTile . defaults ) self . dirty = True # need to recalculate self . layout_info = [] self . last_size = None self . last_screen = None","title":"ratiotile"},{"location":"reference/libqtile/layout/ratiotile/#libqtile.layout.ratiotile.GridInfo","text":"Calculates sizes for grids gi = GridInfo(.5, 5, 600, 480) gi.calc() (1, 5, 1) gi.get_sizes() [(0, 0, 120, 480), (120, 0, 120, 480), (240, 0, 120, 480), (360, 0, 120, 480), (480, 0, 120, 480)] gi = GridInfo(6, 5, 600, 480) gi.get_sizes() [(0, 0, 600, 96), (0, 96, 600, 96), (0, 192, 600, 96), (0, 288, 600, 96), (0, 384, 600, 96)] gi = GridInfo(1, 5, 600, 480) gi.get_sizes() [(0, 0, 200, 240), (200, 0, 200, 240), (400, 0, 200, 240), (0, 240, 300, 240), (200, 240, 200, 240)] foo = GridInfo(1.6, 7, 400,370) foo.get_sizes(500,580) Source code in libqtile/layout/ratiotile.py 62 63 64 65 66 67 68 def __init__ ( self , ratio , num_windows , width , height ): self . ratio = ratio self . num_windows = num_windows self . width = width self . height = height self . num_rows = 0 self . num_cols = 0","title":"GridInfo"},{"location":"reference/libqtile/layout/ratiotile/#libqtile.layout.ratiotile.GridInfo.calc","text":"returns (rows, cols, orientation) tuple given input Source code in libqtile/layout/ratiotile.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def calc ( self , num_windows , width , height ): \"\"\"returns (rows, cols, orientation) tuple given input\"\"\" best_ratio = None best_rows_cols_orientation = None for rows , cols , orientation in self . _possible_grids ( num_windows ): sample_width = width / cols sample_height = height / rows sample_ratio = sample_width / sample_height diff = abs ( sample_ratio - self . ratio ) if best_ratio is None or diff < best_ratio : best_ratio = diff best_rows_cols_orientation = ( rows , cols , orientation ) return best_rows_cols_orientation","title":"calc()"},{"location":"reference/libqtile/layout/ratiotile/#libqtile.layout.ratiotile.GridInfo.get_sizes_advanced","text":"after every row/column recalculate remaining area Source code in libqtile/layout/ratiotile.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def get_sizes_advanced ( self , total_width , total_height , xoffset = 0 , yoffset = 0 ): \"\"\"after every row/column recalculate remaining area\"\"\" results = [] width = total_width height = total_height while len ( results ) < self . num_windows : remaining = self . num_windows - len ( results ) orien , sizes = self . _get_row_or_col ( remaining , width , height , xoffset , yoffset ) results . extend ( sizes ) if orien == ROWCOL : # adjust height/yoffset height -= sizes [ - 1 ][ - 1 ] yoffset += sizes [ - 1 ][ - 1 ] else : width -= sizes [ - 1 ][ - 2 ] xoffset += sizes [ - 1 ][ - 2 ] return results","title":"get_sizes_advanced()"},{"location":"reference/libqtile/layout/ratiotile/#libqtile.layout.ratiotile.RatioTile","text":"Bases: _SimpleLayoutBase Tries to tile all windows in the width/height ratio passed in Source code in libqtile/layout/ratiotile.py 214 215 216 217 218 219 220 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( RatioTile . defaults ) self . dirty = True # need to recalculate self . layout_info = [] self . last_size = None self . last_screen = None","title":"RatioTile"},{"location":"reference/libqtile/layout/slice/","text":"Slice layout. Serves as example of delegating layouts (or sublayouts) Single () Bases: Layout Layout with single window Just like Max but asserts that window is the one Source code in libqtile/layout/slice.py 40 41 42 43 def __init__ ( self ): Layout . __init__ ( self ) self . window = None self . focused = False empty () Is the layout empty Returns True if the layout empty (and is willing to accept windows) Source code in libqtile/layout/slice.py 67 68 69 70 71 72 def empty ( self ): \"\"\"Is the layout empty Returns True if the layout empty (and is willing to accept windows) \"\"\" return self . window is None Slice ( ** config ) Bases: Layout Slice layout This layout cuts piece of screen_rect and places a single window on that piece, and delegates other window placement to other layout Source code in libqtile/layout/slice.py 118 119 120 121 122 def __init__ ( self , ** config ): self . layouts = {} Layout . __init__ ( self , ** config ) self . add_defaults ( Slice . defaults ) self . _slice = Single () __getattr__ ( name ) Delegate unimplemented command calls to active layout. For exposed commands that don't exist on the Slice class, this looks for an implementation on the active layout. Source code in libqtile/layout/slice.py 253 254 255 256 257 258 259 260 261 262 263 def __getattr__ ( self , name ): \"\"\"Delegate unimplemented command calls to active layout. For exposed commands that don't exist on the Slice class, this looks for an implementation on the active layout. \"\"\" if \"fallback\" in self . __dict__ : cmd = self . command ( name ) if cmd : return cmd return super () . __getattr__ ( name ) delegate_layout ( windows , mapping ) Delegates layouting actual windows Parameters windows: windows to layout mapping: mapping from layout to ScreenRect for each layout Source code in libqtile/layout/slice.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def delegate_layout ( self , windows , mapping ): \"\"\"Delegates layouting actual windows Parameters =========== windows: windows to layout mapping: mapping from layout to ScreenRect for each layout \"\"\" grouped = {} for w in windows : lay = self . layouts [ w ] if lay in grouped : grouped [ lay ] . append ( w ) else : grouped [ lay ] = [ w ] for lay , wins in grouped . items (): lay . layout ( wins , mapping [ lay ])","title":"slice"},{"location":"reference/libqtile/layout/slice/#libqtile.layout.slice.Single","text":"Bases: Layout Layout with single window Just like Max but asserts that window is the one Source code in libqtile/layout/slice.py 40 41 42 43 def __init__ ( self ): Layout . __init__ ( self ) self . window = None self . focused = False","title":"Single"},{"location":"reference/libqtile/layout/slice/#libqtile.layout.slice.Single.empty","text":"Is the layout empty Returns True if the layout empty (and is willing to accept windows) Source code in libqtile/layout/slice.py 67 68 69 70 71 72 def empty ( self ): \"\"\"Is the layout empty Returns True if the layout empty (and is willing to accept windows) \"\"\" return self . window is None","title":"empty()"},{"location":"reference/libqtile/layout/slice/#libqtile.layout.slice.Slice","text":"Bases: Layout Slice layout This layout cuts piece of screen_rect and places a single window on that piece, and delegates other window placement to other layout Source code in libqtile/layout/slice.py 118 119 120 121 122 def __init__ ( self , ** config ): self . layouts = {} Layout . __init__ ( self , ** config ) self . add_defaults ( Slice . defaults ) self . _slice = Single ()","title":"Slice"},{"location":"reference/libqtile/layout/slice/#libqtile.layout.slice.Slice.__getattr__","text":"Delegate unimplemented command calls to active layout. For exposed commands that don't exist on the Slice class, this looks for an implementation on the active layout. Source code in libqtile/layout/slice.py 253 254 255 256 257 258 259 260 261 262 263 def __getattr__ ( self , name ): \"\"\"Delegate unimplemented command calls to active layout. For exposed commands that don't exist on the Slice class, this looks for an implementation on the active layout. \"\"\" if \"fallback\" in self . __dict__ : cmd = self . command ( name ) if cmd : return cmd return super () . __getattr__ ( name )","title":"__getattr__()"},{"location":"reference/libqtile/layout/slice/#libqtile.layout.slice.Slice.delegate_layout","text":"Delegates layouting actual windows","title":"delegate_layout()"},{"location":"reference/libqtile/layout/slice/#libqtile.layout.slice.Slice.delegate_layout--parameters","text":"windows: windows to layout mapping: mapping from layout to ScreenRect for each layout Source code in libqtile/layout/slice.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def delegate_layout ( self , windows , mapping ): \"\"\"Delegates layouting actual windows Parameters =========== windows: windows to layout mapping: mapping from layout to ScreenRect for each layout \"\"\" grouped = {} for w in windows : lay = self . layouts [ w ] if lay in grouped : grouped [ lay ] . append ( w ) else : grouped [ lay ] = [ w ] for lay , wins in grouped . items (): lay . layout ( wins , mapping [ lay ])","title":"Parameters"},{"location":"reference/libqtile/layout/spiral/","text":"Spiral ( ** config ) Bases: _SimpleLayoutBase A mathematical layout. Renders windows in a spiral form by splitting the screen based on a selected ratio. The direction of the split is changed every time in a defined order resulting in a spiral formation. The main window can be sized with lazy.layout.grow_main() and lazy.layout.shrink_main() . All other windows are sized by lazy.layout.increase_ratio() and lazy.layout.decrease_ratio() . NB if main_pane_ratio is not set then it will also be adjusted according to ratio . However, as soon shrink_main() or grow_main() have been called once then the master pane will only change size following further calls to those methods. Users are able to choose the location of the main (i.e. largest) pane and the direction of the rotation. Some examples: main_pane=\"left\", clockwise=True :: ---------------------- |1 |2 | | | | | | | | |----------| | |5 |6 |3 | | |-----| | | |4 | | ---------------------- main_pane=\"top\", clockwise=False :: ---------------------- |1 | | | | | |--------------------| |2 |5 |4 | | |----------| | |3 | ---------------------- Source code in libqtile/layout/spiral.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Spiral . defaults ) self . dirty = True # need to recalculate self . layout_info = [] self . last_size = None self . last_screen = None self . initial_ratio = self . ratio self . initial_main_pane_ratio = self . main_pane_ratio self . main_pane = self . main_pane . lower () if self . main_pane not in [ \"top\" , \"left\" , \"bottom\" , \"right\" ]: logger . warning ( \"Unknown main_pane location: %s . Defaulting to 'left'.\" , self . main_pane ) self . main_pane = \"left\" # Calculate the order of transformations required based on position of main pane # and rotation direction # Lists are longer so we can pick any side and have the next 4 transformations if self . clockwise : order = [ \"left\" , \"top\" , \"right\" , \"bottom\" , \"left\" , \"top\" , \"right\" ] else : order = [ \"left\" , \"bottom\" , \"right\" , \"top\" , \"left\" , \"bottom\" , \"right\" ] idx = order . index ( self . main_pane ) self . splits = order [ idx : idx + 4 ] decrease_ratio () Decrease spiral ratio. Source code in libqtile/layout/spiral.py 381 382 383 384 @expose_command () def decrease_ratio ( self ): \"\"\"Decrease spiral ratio.\"\"\" self . _set_ratio ( \"ratio\" , self . ratio - self . ratio_increment ) get_spiral ( x , y , width , height ) Calculates positions of windows in the spiral. Returns a list of tuples (x, y, w, h) for positioning windows. Source code in libqtile/layout/spiral.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def get_spiral ( self , x , y , width , height ) -> list [ Rect ]: \"\"\" Calculates positions of windows in the spiral. Returns a list of tuples (x, y, w, h) for positioning windows. \"\"\" num_windows = len ( self . clients ) direction = 0 spiral = [] rect = ( x , y , width , height ) for c in range ( num_windows ): if c == 0 and self . main_pane_ratio is not None : self . split_ratio = self . main_pane_ratio else : self . split_ratio = self . ratio # If there's another window to draw after this one then we need to # split the current rect, if not, the window can take the full rect split = c < ( num_windows - 1 ) if not split : spiral . append ( rect ) continue # Get the dimensions of the window and remaining rect # Calls self.split_[direction name] win , new_rect = getattr ( self , f \"split_ { self . splits [ direction ] } \" )( rect ) # If the window would have negative/zero dimensions then it can't be displayed if self . has_invalid_size ( win ): # Use the available rect from before the split spiral . append ( rect ) break spiral . append ( win ) direction = ( direction + 1 ) % 4 rect = new_rect return spiral grow_main () Grow the main window. Source code in libqtile/layout/spiral.py 399 400 401 402 403 404 405 @expose_command () def grow_main ( self ): \"\"\"Grow the main window.\"\"\" if self . main_pane_ratio is None : self . main_pane_ratio = self . ratio self . _set_ratio ( \"main_pane_ratio\" , self . main_pane_ratio + self . ratio_increment ) has_invalid_size ( win ) Checks if window would have an invalid size. A window that would have negative height or width (after adjusting for margins and borders) will return True. Source code in libqtile/layout/spiral.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def has_invalid_size ( self , win : Rect ) -> bool : \"\"\" Checks if window would have an invalid size. A window that would have negative height or width (after adjusting for margins and borders) will return True. \"\"\" if isinstance ( self . margin , int ): margin = [ self . margin ] * 4 else : margin = self . margin return any ( [ win [ 2 ] <= margin [ 1 ] + margin [ 3 ] + 2 * self . border_width , win [ 3 ] <= margin [ 0 ] + margin [ 2 ] + 2 * self . border_width , ] ) increase_ratio () Increase spiral ratio. Source code in libqtile/layout/spiral.py 386 387 388 389 @expose_command () def increase_ratio ( self ): \"\"\"Increase spiral ratio.\"\"\" self . _set_ratio ( \"ratio\" , self . ratio + self . ratio_increment ) reset () Reset ratios to values set in config. Source code in libqtile/layout/spiral.py 417 418 419 420 421 422 @expose_command () def reset ( self ): \"\"\"Reset ratios to values set in config.\"\"\" self . ratio = self . initial_ratio self . main_pane_ratio = self . initial_main_pane_ratio self . group . layout_all () set_master_ratio ( ratio ) Set the ratio for the main window. Source code in libqtile/layout/spiral.py 412 413 414 415 @expose_command () def set_master_ratio ( self , ratio : float | str ): \"\"\"Set the ratio for the main window.\"\"\" self . _set_ratio ( \"main_pane_ratio\" , ratio ) set_ratio ( ratio ) Set the ratio for all windows. Source code in libqtile/layout/spiral.py 407 408 409 410 @expose_command () def set_ratio ( self , ratio : float | str ): \"\"\"Set the ratio for all windows.\"\"\" self . _set_ratio ( \"ratio\" , ratio ) shrink_main () Shrink the main window. Source code in libqtile/layout/spiral.py 391 392 393 394 395 396 397 @expose_command () def shrink_main ( self ): \"\"\"Shrink the main window.\"\"\" if self . main_pane_ratio is None : self . main_pane_ratio = self . ratio self . _set_ratio ( \"main_pane_ratio\" , self . main_pane_ratio - self . ratio_increment )","title":"spiral"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral","text":"Bases: _SimpleLayoutBase A mathematical layout. Renders windows in a spiral form by splitting the screen based on a selected ratio. The direction of the split is changed every time in a defined order resulting in a spiral formation. The main window can be sized with lazy.layout.grow_main() and lazy.layout.shrink_main() . All other windows are sized by lazy.layout.increase_ratio() and lazy.layout.decrease_ratio() . NB if main_pane_ratio is not set then it will also be adjusted according to ratio . However, as soon shrink_main() or grow_main() have been called once then the master pane will only change size following further calls to those methods. Users are able to choose the location of the main (i.e. largest) pane and the direction of the rotation. Some examples: main_pane=\"left\", clockwise=True :: ---------------------- |1 |2 | | | | | | | | |----------| | |5 |6 |3 | | |-----| | | |4 | | ---------------------- main_pane=\"top\", clockwise=False :: ---------------------- |1 | | | | | |--------------------| |2 |5 |4 | | |----------| | |3 | ---------------------- Source code in libqtile/layout/spiral.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Spiral . defaults ) self . dirty = True # need to recalculate self . layout_info = [] self . last_size = None self . last_screen = None self . initial_ratio = self . ratio self . initial_main_pane_ratio = self . main_pane_ratio self . main_pane = self . main_pane . lower () if self . main_pane not in [ \"top\" , \"left\" , \"bottom\" , \"right\" ]: logger . warning ( \"Unknown main_pane location: %s . Defaulting to 'left'.\" , self . main_pane ) self . main_pane = \"left\" # Calculate the order of transformations required based on position of main pane # and rotation direction # Lists are longer so we can pick any side and have the next 4 transformations if self . clockwise : order = [ \"left\" , \"top\" , \"right\" , \"bottom\" , \"left\" , \"top\" , \"right\" ] else : order = [ \"left\" , \"bottom\" , \"right\" , \"top\" , \"left\" , \"bottom\" , \"right\" ] idx = order . index ( self . main_pane ) self . splits = order [ idx : idx + 4 ]","title":"Spiral"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.decrease_ratio","text":"Decrease spiral ratio. Source code in libqtile/layout/spiral.py 381 382 383 384 @expose_command () def decrease_ratio ( self ): \"\"\"Decrease spiral ratio.\"\"\" self . _set_ratio ( \"ratio\" , self . ratio - self . ratio_increment )","title":"decrease_ratio()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.get_spiral","text":"Calculates positions of windows in the spiral. Returns a list of tuples (x, y, w, h) for positioning windows. Source code in libqtile/layout/spiral.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def get_spiral ( self , x , y , width , height ) -> list [ Rect ]: \"\"\" Calculates positions of windows in the spiral. Returns a list of tuples (x, y, w, h) for positioning windows. \"\"\" num_windows = len ( self . clients ) direction = 0 spiral = [] rect = ( x , y , width , height ) for c in range ( num_windows ): if c == 0 and self . main_pane_ratio is not None : self . split_ratio = self . main_pane_ratio else : self . split_ratio = self . ratio # If there's another window to draw after this one then we need to # split the current rect, if not, the window can take the full rect split = c < ( num_windows - 1 ) if not split : spiral . append ( rect ) continue # Get the dimensions of the window and remaining rect # Calls self.split_[direction name] win , new_rect = getattr ( self , f \"split_ { self . splits [ direction ] } \" )( rect ) # If the window would have negative/zero dimensions then it can't be displayed if self . has_invalid_size ( win ): # Use the available rect from before the split spiral . append ( rect ) break spiral . append ( win ) direction = ( direction + 1 ) % 4 rect = new_rect return spiral","title":"get_spiral()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.grow_main","text":"Grow the main window. Source code in libqtile/layout/spiral.py 399 400 401 402 403 404 405 @expose_command () def grow_main ( self ): \"\"\"Grow the main window.\"\"\" if self . main_pane_ratio is None : self . main_pane_ratio = self . ratio self . _set_ratio ( \"main_pane_ratio\" , self . main_pane_ratio + self . ratio_increment )","title":"grow_main()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.has_invalid_size","text":"Checks if window would have an invalid size. A window that would have negative height or width (after adjusting for margins and borders) will return True. Source code in libqtile/layout/spiral.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def has_invalid_size ( self , win : Rect ) -> bool : \"\"\" Checks if window would have an invalid size. A window that would have negative height or width (after adjusting for margins and borders) will return True. \"\"\" if isinstance ( self . margin , int ): margin = [ self . margin ] * 4 else : margin = self . margin return any ( [ win [ 2 ] <= margin [ 1 ] + margin [ 3 ] + 2 * self . border_width , win [ 3 ] <= margin [ 0 ] + margin [ 2 ] + 2 * self . border_width , ] )","title":"has_invalid_size()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.increase_ratio","text":"Increase spiral ratio. Source code in libqtile/layout/spiral.py 386 387 388 389 @expose_command () def increase_ratio ( self ): \"\"\"Increase spiral ratio.\"\"\" self . _set_ratio ( \"ratio\" , self . ratio + self . ratio_increment )","title":"increase_ratio()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.reset","text":"Reset ratios to values set in config. Source code in libqtile/layout/spiral.py 417 418 419 420 421 422 @expose_command () def reset ( self ): \"\"\"Reset ratios to values set in config.\"\"\" self . ratio = self . initial_ratio self . main_pane_ratio = self . initial_main_pane_ratio self . group . layout_all ()","title":"reset()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.set_master_ratio","text":"Set the ratio for the main window. Source code in libqtile/layout/spiral.py 412 413 414 415 @expose_command () def set_master_ratio ( self , ratio : float | str ): \"\"\"Set the ratio for the main window.\"\"\" self . _set_ratio ( \"main_pane_ratio\" , ratio )","title":"set_master_ratio()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.set_ratio","text":"Set the ratio for all windows. Source code in libqtile/layout/spiral.py 407 408 409 410 @expose_command () def set_ratio ( self , ratio : float | str ): \"\"\"Set the ratio for all windows.\"\"\" self . _set_ratio ( \"ratio\" , ratio )","title":"set_ratio()"},{"location":"reference/libqtile/layout/spiral/#libqtile.layout.spiral.Spiral.shrink_main","text":"Shrink the main window. Source code in libqtile/layout/spiral.py 391 392 393 394 395 396 397 @expose_command () def shrink_main ( self ): \"\"\"Shrink the main window.\"\"\" if self . main_pane_ratio is None : self . main_pane_ratio = self . ratio self . _set_ratio ( \"main_pane_ratio\" , self . main_pane_ratio - self . ratio_increment )","title":"shrink_main()"},{"location":"reference/libqtile/layout/stack/","text":"Stack ( ** config ) Bases: Layout A layout composed of stacks of windows The stack layout divides the screen_rect horizontally into a set of stacks. Commands allow you to switch between stacks, to next and previous windows within a stack, and to split a stack to show all windows in the stack, or unsplit it to show only the current window. Unlike the columns layout the number of stacks is fixed. Source code in libqtile/layout/stack.py 67 68 69 70 71 72 73 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( Stack . defaults ) if self . num_stacks <= 0 : # Catch stupid mistakes early and generate a useful message raise ValueError ( \"num_stacks must be at least 1\" ) self . stacks = [ _WinStack ( autosplit = self . autosplit ) for i in range ( self . num_stacks )] add () Add another stack to the layout Source code in libqtile/layout/stack.py 294 295 296 297 298 299 300 301 @expose_command () def add ( self ): \"\"\"Add another stack to the layout\"\"\" newstack = _WinStack ( autosplit = self . autosplit ) if self . autosplit : newstack . split = True self . stacks . append ( newstack ) self . group . layout_all () client_to_next () Send the current client to the next stack Source code in libqtile/layout/stack.py 320 321 322 323 @expose_command () def client_to_next ( self ): \"\"\"Send the current client to the next stack\"\"\" return self . client_to_stack ( self . current_stack_offset + 1 ) client_to_previous () Send the current client to the previous stack Source code in libqtile/layout/stack.py 325 326 327 328 @expose_command () def client_to_previous ( self ): \"\"\"Send the current client to the previous stack\"\"\" return self . client_to_stack ( self . current_stack_offset - 1 ) client_to_stack ( n ) Send the current client to stack n, where n is an integer offset. If is too large or less than 0, it is wrapped modulo the number of stacks. Source code in libqtile/layout/stack.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 @expose_command () def client_to_stack ( self , n ): \"\"\" Send the current client to stack n, where n is an integer offset. If is too large or less than 0, it is wrapped modulo the number of stacks. \"\"\" if not self . current_stack : return next = n % len ( self . stacks ) win = self . current_stack . cw self . current_stack . remove ( win ) self . stacks [ next ] . add_client ( win ) self . stacks [ next ] . focus ( win ) self . group . layout_all () delete () Delete the current stack from the layout Source code in libqtile/layout/stack.py 289 290 291 292 @expose_command () def delete ( self ): \"\"\"Delete the current stack from the layout\"\"\" self . delete_current_stack () down () Switch to the next window in this stack Source code in libqtile/layout/stack.py 265 266 267 268 269 @expose_command () def down ( self ): \"\"\"Switch to the next window in this stack\"\"\" self . current_stack . current_index += 1 self . group . focus ( self . current_stack . cw , False ) next () Focus next stack Source code in libqtile/layout/stack.py 310 311 312 313 @expose_command () def next ( self ): \"\"\"Focus next stack\"\"\" return self . next_stack () previous () Focus previous stack Source code in libqtile/layout/stack.py 315 316 317 318 @expose_command () def previous ( self ): \"\"\"Focus previous stack\"\"\" return self . previous_stack () rotate () Rotate order of the stacks Source code in libqtile/layout/stack.py 303 304 305 306 307 308 @expose_command () def rotate ( self ): \"\"\"Rotate order of the stacks\"\"\" if self . stacks : self . stacks . insert ( 0 , self . stacks . pop ()) self . group . layout_all () shuffle_down () Shuffle the order of this stack down Source code in libqtile/layout/stack.py 283 284 285 286 287 @expose_command () def shuffle_down ( self ): \"\"\"Shuffle the order of this stack down\"\"\" self . current_stack . shuffle_down () self . group . layout_all () shuffle_up () Shuffle the order of this stack up Source code in libqtile/layout/stack.py 277 278 279 280 281 @expose_command () def shuffle_up ( self ): \"\"\"Shuffle the order of this stack up\"\"\" self . current_stack . shuffle_up () self . group . layout_all () toggle_split () Toggle vertical split on the current stack Source code in libqtile/layout/stack.py 259 260 261 262 263 @expose_command () def toggle_split ( self ): \"\"\"Toggle vertical split on the current stack\"\"\" self . current_stack . toggle_split () self . group . layout_all () up () Switch to the previous window in this stack Source code in libqtile/layout/stack.py 271 272 273 274 275 @expose_command () def up ( self ): \"\"\"Switch to the previous window in this stack\"\"\" self . current_stack . current_index -= 1 self . group . focus ( self . current_stack . cw , False )","title":"stack"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack","text":"Bases: Layout A layout composed of stacks of windows The stack layout divides the screen_rect horizontally into a set of stacks. Commands allow you to switch between stacks, to next and previous windows within a stack, and to split a stack to show all windows in the stack, or unsplit it to show only the current window. Unlike the columns layout the number of stacks is fixed. Source code in libqtile/layout/stack.py 67 68 69 70 71 72 73 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( Stack . defaults ) if self . num_stacks <= 0 : # Catch stupid mistakes early and generate a useful message raise ValueError ( \"num_stacks must be at least 1\" ) self . stacks = [ _WinStack ( autosplit = self . autosplit ) for i in range ( self . num_stacks )]","title":"Stack"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.add","text":"Add another stack to the layout Source code in libqtile/layout/stack.py 294 295 296 297 298 299 300 301 @expose_command () def add ( self ): \"\"\"Add another stack to the layout\"\"\" newstack = _WinStack ( autosplit = self . autosplit ) if self . autosplit : newstack . split = True self . stacks . append ( newstack ) self . group . layout_all ()","title":"add()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.client_to_next","text":"Send the current client to the next stack Source code in libqtile/layout/stack.py 320 321 322 323 @expose_command () def client_to_next ( self ): \"\"\"Send the current client to the next stack\"\"\" return self . client_to_stack ( self . current_stack_offset + 1 )","title":"client_to_next()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.client_to_previous","text":"Send the current client to the previous stack Source code in libqtile/layout/stack.py 325 326 327 328 @expose_command () def client_to_previous ( self ): \"\"\"Send the current client to the previous stack\"\"\" return self . client_to_stack ( self . current_stack_offset - 1 )","title":"client_to_previous()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.client_to_stack","text":"Send the current client to stack n, where n is an integer offset. If is too large or less than 0, it is wrapped modulo the number of stacks. Source code in libqtile/layout/stack.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 @expose_command () def client_to_stack ( self , n ): \"\"\" Send the current client to stack n, where n is an integer offset. If is too large or less than 0, it is wrapped modulo the number of stacks. \"\"\" if not self . current_stack : return next = n % len ( self . stacks ) win = self . current_stack . cw self . current_stack . remove ( win ) self . stacks [ next ] . add_client ( win ) self . stacks [ next ] . focus ( win ) self . group . layout_all ()","title":"client_to_stack()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.delete","text":"Delete the current stack from the layout Source code in libqtile/layout/stack.py 289 290 291 292 @expose_command () def delete ( self ): \"\"\"Delete the current stack from the layout\"\"\" self . delete_current_stack ()","title":"delete()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.down","text":"Switch to the next window in this stack Source code in libqtile/layout/stack.py 265 266 267 268 269 @expose_command () def down ( self ): \"\"\"Switch to the next window in this stack\"\"\" self . current_stack . current_index += 1 self . group . focus ( self . current_stack . cw , False )","title":"down()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.next","text":"Focus next stack Source code in libqtile/layout/stack.py 310 311 312 313 @expose_command () def next ( self ): \"\"\"Focus next stack\"\"\" return self . next_stack ()","title":"next()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.previous","text":"Focus previous stack Source code in libqtile/layout/stack.py 315 316 317 318 @expose_command () def previous ( self ): \"\"\"Focus previous stack\"\"\" return self . previous_stack ()","title":"previous()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.rotate","text":"Rotate order of the stacks Source code in libqtile/layout/stack.py 303 304 305 306 307 308 @expose_command () def rotate ( self ): \"\"\"Rotate order of the stacks\"\"\" if self . stacks : self . stacks . insert ( 0 , self . stacks . pop ()) self . group . layout_all ()","title":"rotate()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.shuffle_down","text":"Shuffle the order of this stack down Source code in libqtile/layout/stack.py 283 284 285 286 287 @expose_command () def shuffle_down ( self ): \"\"\"Shuffle the order of this stack down\"\"\" self . current_stack . shuffle_down () self . group . layout_all ()","title":"shuffle_down()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.shuffle_up","text":"Shuffle the order of this stack up Source code in libqtile/layout/stack.py 277 278 279 280 281 @expose_command () def shuffle_up ( self ): \"\"\"Shuffle the order of this stack up\"\"\" self . current_stack . shuffle_up () self . group . layout_all ()","title":"shuffle_up()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.toggle_split","text":"Toggle vertical split on the current stack Source code in libqtile/layout/stack.py 259 260 261 262 263 @expose_command () def toggle_split ( self ): \"\"\"Toggle vertical split on the current stack\"\"\" self . current_stack . toggle_split () self . group . layout_all ()","title":"toggle_split()"},{"location":"reference/libqtile/layout/stack/#libqtile.layout.stack.Stack.up","text":"Switch to the previous window in this stack Source code in libqtile/layout/stack.py 271 272 273 274 275 @expose_command () def up ( self ): \"\"\"Switch to the previous window in this stack\"\"\" self . current_stack . current_index -= 1 self . group . focus ( self . current_stack . cw , False )","title":"up()"},{"location":"reference/libqtile/layout/tile/","text":"Tile ( ** config ) Bases: _SimpleLayoutBase A layout with two stacks of windows dividing the screen The Tile layout divides the screen_rect horizontally into two stacks. The maximum amount of \"master\" windows can be configured; surplus windows will be displayed in the slave stack on the right. Within their stacks, the windows will be tiled vertically. The windows can be rotated in their entirety by calling up() or down() or, if shift_windows is set to True, individually. Source code in libqtile/layout/tile.py 100 101 102 103 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Tile . defaults ) self . _initial_ratio = self . ratio","title":"tile"},{"location":"reference/libqtile/layout/tile/#libqtile.layout.tile.Tile","text":"Bases: _SimpleLayoutBase A layout with two stacks of windows dividing the screen The Tile layout divides the screen_rect horizontally into two stacks. The maximum amount of \"master\" windows can be configured; surplus windows will be displayed in the slave stack on the right. Within their stacks, the windows will be tiled vertically. The windows can be rotated in their entirety by calling up() or down() or, if shift_windows is set to True, individually. Source code in libqtile/layout/tile.py 100 101 102 103 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Tile . defaults ) self . _initial_ratio = self . ratio","title":"Tile"},{"location":"reference/libqtile/layout/tree/","text":"Root ( sections , default_section = None ) Bases: TreeNode Source code in libqtile/layout/tree.py 150 151 152 153 154 155 156 157 158 def __init__ ( self , sections , default_section = None ): super () . __init__ () self . sections = {} for section in sections : self . add_section ( section ) if default_section is None : self . def_section = self . children [ 0 ] else : self . def_section = self . sections [ default_section ] add_client ( win , hint = None ) Add a new window Adds a new Window to the tree. The location of the new node is controlled by looking: * `hint` kwarg - place the node next to this node * win.tree_section - place the window in the given section, by name * default section - fallback to default section (first section, if not otherwise set) Source code in libqtile/layout/tree.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def add_client ( self , win , hint = None ): \"\"\"Add a new window Adds a new `Window` to the tree. The location of the new node is controlled by looking: * `hint` kwarg - place the node next to this node * win.tree_section - place the window in the given section, by name * default section - fallback to default section (first section, if not otherwise set) \"\"\" parent = None if hint is not None : parent = hint . parent if parent is None : sect = getattr ( win , \"tree_section\" , None ) if sect is not None : parent = self . sections . get ( sect ) if parent is None : parent = self . def_section node = Window ( win ) parent . add_client ( node , hint = hint ) return node add_section ( name ) Add a new Section with the given name Source code in libqtile/layout/tree.py 188 189 190 191 192 193 194 195 def add_section ( self , name ): \"\"\"Add a new Section with the given name\"\"\" if name in self . sections : raise ValueError ( \"Duplicate section name\" ) node = Section ( name ) node . parent = self self . sections [ name ] = node self . children . append ( node ) del_section ( name ) Remove the Section with the given name Source code in libqtile/layout/tree.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def del_section ( self , name ): \"\"\"Remove the Section with the given name\"\"\" if name not in self . sections : raise ValueError ( \"Section name not found\" ) if len ( self . children ) == 1 : raise ValueError ( \"Can't delete last section\" ) sec = self . sections [ name ] # move the children of the deleted section to the previous section # if delecting the first section, add children to second section idx = max ( self . children . index ( sec ), 1 ) next_sec = self . children [ idx - 1 ] # delete old section, reparent children to next section del self . children [ idx ] next_sec . children . extend ( sec . children ) for i in sec . children : i . parent = next_sec del self . sections [ name ] TreeNode () Source code in libqtile/layout/tree.py 40 41 42 43 44 45 def __init__ ( self ): self . children = [] self . parent = None self . expanded = True self . _children_top = None self . _children_bot = None add_client ( node , hint = None ) Add a node below this node The hint is a node to place the new node after in this nodes children. Source code in libqtile/layout/tree.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def add_client ( self , node , hint = None ): \"\"\"Add a node below this node The `hint` is a node to place the new node after in this nodes children. \"\"\" node . parent = self if hint is not None : try : idx = self . children . index ( hint ) except ValueError : pass else : self . children . insert ( idx + 1 , node ) return self . children . append ( node ) add_superscript ( title ) Prepend superscript denoting the number of hidden children Source code in libqtile/layout/tree.py 88 89 90 91 92 def add_superscript ( self , title ): \"\"\"Prepend superscript denoting the number of hidden children\"\"\" if not self . expanded and self . children : return \" {:d} \" . format ( len ( self . children )) . translate ( to_superscript ) + title return title button_press ( x , y ) Returns self or sibling which got the click Source code in libqtile/layout/tree.py 77 78 79 80 81 82 83 84 85 86 def button_press ( self , x , y ): \"\"\"Returns self or sibling which got the click\"\"\" # if we store the locations of each child, it would be possible to do # this without having to traverse the tree... if not ( self . _children_top <= y < self . _children_bot ): return for i in self . children : res = i . button_press ( x , y ) if res is not None : return res draw ( layout , top , level = 0 ) Draw the node and its children to a layout Draws this node to the given layout (presumably a TreeTab), starting from a y-offset of top and at the given level. Source code in libqtile/layout/tree.py 64 65 66 67 68 69 70 71 72 73 74 75 def draw ( self , layout , top , level = 0 ): \"\"\"Draw the node and its children to a layout Draws this node to the given layout (presumably a TreeTab), starting from a y-offset of `top` and at the given level. \"\"\" self . _children_top = top if self . expanded : for i in self . children : top = i . draw ( layout , top , level ) self . _children_bot = top return top get_first_window () Find the first Window under this node Returns self if this is a Window , otherwise finds first Window by depth-first search Source code in libqtile/layout/tree.py 94 95 96 97 98 99 100 101 102 103 104 105 106 def get_first_window ( self ): \"\"\"Find the first Window under this node Returns self if this is a `Window`, otherwise finds first `Window` by depth-first search \"\"\" if isinstance ( self , Window ): return self if self . expanded : for i in self . children : node = i . get_first_window () if node : return node get_last_window () Find the last Window under this node Finds last Window by depth-first search, otherwise returns self if this is a Window . Source code in libqtile/layout/tree.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def get_last_window ( self ): \"\"\"Find the last Window under this node Finds last `Window` by depth-first search, otherwise returns self if this is a `Window`. \"\"\" if self . expanded : for i in reversed ( self . children ): node = i . get_last_window () if node : return node if isinstance ( self , Window ): return self TreeTab ( ** config ) Bases: Layout Tree Tab Layout This layout works just like Max but displays tree of the windows at the left border of the screen_rect, which allows you to overview all opened windows. It's designed to work with uzbl-browser but works with other windows too. The panel at the left border contains sections, each of which contains windows. Initially the panel looks like flat lists inside its section, and looks like trees if some of the windows are \"moved\" left or right. For example, it looks like below with two sections initially: :: +------------+ |Section Foo | +------------+ | Window A | +------------+ | Window B | +------------+ | Window C | +------------+ |Section Bar | +------------+ And then it will look like below if \"Window B\" is moved right and \"Window C\" is moved right too: :: +------------+ |Section Foo | +------------+ | Window A | +------------+ | Window B | +------------+ | Window C | +------------+ |Section Bar | +------------+ Source code in libqtile/layout/tree.py 378 379 380 381 382 383 384 385 386 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( TreeTab . defaults ) self . _focused = None self . _panel = None self . _drawer = None self . _layout = None self . _tree = Root ( self . sections ) self . _nodes = {} add_section ( name ) Add named section to tree Source code in libqtile/layout/tree.py 613 614 615 616 617 @expose_command () def add_section ( self , name ): \"\"\"Add named section to tree\"\"\" self . _tree . add_section ( name ) self . draw_panel () del_section ( name ) Remove named section from tree Source code in libqtile/layout/tree.py 619 620 621 622 623 @expose_command () def del_section ( self , name ): \"\"\"Remove named section from tree\"\"\" self . _tree . del_section ( name ) self . draw_panel () next () Switch down in the window list Source code in libqtile/layout/tree.py 552 553 554 555 556 557 558 559 560 561 562 @expose_command ( \"down\" ) def next ( self ): \"\"\"Switch down in the window list\"\"\" win = None if self . _focused : win = self . _nodes [ self . _focused ] . get_next_window () if not win : win = self . _tree . get_first_window () if win : self . group . focus ( win . window , False ) self . _focused = win . window if win else None previous () Switch up in the window list Source code in libqtile/layout/tree.py 564 565 566 567 568 569 570 571 572 573 574 @expose_command ( \"up\" ) def previous ( self ): \"\"\"Switch up in the window list\"\"\" win = None if self . _focused : win = self . _nodes [ self . _focused ] . get_prev_window () if not win : win = self . _tree . get_last_window () if win : self . group . focus ( win . window , False ) self . _focused = win . window if win else None sort_windows ( sorter , create_sections = True ) Sorts window to sections using sorter function Parameters sorter: function with single arg returning string returns name of the section where window should be create_sections: if this parameter is True (default), if sorter returns unknown section name it will be created dynamically Source code in libqtile/layout/tree.py 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 @expose_command () def sort_windows ( self , sorter , create_sections = True ): \"\"\"Sorts window to sections using sorter function Parameters ========== sorter: function with single arg returning string returns name of the section where window should be create_sections: if this parameter is True (default), if sorter returns unknown section name it will be created dynamically \"\"\" for sec in self . _tree . children : for win in sec . children [:]: nname = sorter ( win . window ) if nname is None or nname == sec . title : continue try : nsec = self . _tree . sections [ nname ] except KeyError : if create_sections : self . _tree . add_section ( nname ) nsec = self . _tree . sections [ nname ] else : continue sec . children . remove ( win ) nsec . children . append ( win ) win . parent = nsec self . draw_panel () Window ( win ) Bases: TreeNode Source code in libqtile/layout/tree.py 241 242 243 244 def __init__ ( self , win ): super () . __init__ () self . window = win self . _title_top = None button_press ( x , y ) Returns self if clicked on title else returns sibling Source code in libqtile/layout/tree.py 276 277 278 279 280 def button_press ( self , x , y ): \"\"\"Returns self if clicked on title else returns sibling\"\"\" if self . _title_top <= y < self . _children_top : return self return super () . button_press ( x , y ) remove () Removes this Window If this window has children, the first child takes the place of this window, and any remaining children are reparented to that node Source code in libqtile/layout/tree.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def remove ( self ): \"\"\"Removes this Window If this window has children, the first child takes the place of this window, and any remaining children are reparented to that node \"\"\" if self . children : head = self . children [ 0 ] # add the first child to our parent, next to ourselves self . parent . add_client ( head , hint = self ) # move remaining children to be under the new head for i in self . children [ 1 :]: head . add_client ( i ) self . parent . children . remove ( self ) del self . children","title":"tree"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Root","text":"Bases: TreeNode Source code in libqtile/layout/tree.py 150 151 152 153 154 155 156 157 158 def __init__ ( self , sections , default_section = None ): super () . __init__ () self . sections = {} for section in sections : self . add_section ( section ) if default_section is None : self . def_section = self . children [ 0 ] else : self . def_section = self . sections [ default_section ]","title":"Root"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Root.add_client","text":"Add a new window Adds a new Window to the tree. The location of the new node is controlled by looking: * `hint` kwarg - place the node next to this node * win.tree_section - place the window in the given section, by name * default section - fallback to default section (first section, if not otherwise set) Source code in libqtile/layout/tree.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def add_client ( self , win , hint = None ): \"\"\"Add a new window Adds a new `Window` to the tree. The location of the new node is controlled by looking: * `hint` kwarg - place the node next to this node * win.tree_section - place the window in the given section, by name * default section - fallback to default section (first section, if not otherwise set) \"\"\" parent = None if hint is not None : parent = hint . parent if parent is None : sect = getattr ( win , \"tree_section\" , None ) if sect is not None : parent = self . sections . get ( sect ) if parent is None : parent = self . def_section node = Window ( win ) parent . add_client ( node , hint = hint ) return node","title":"add_client()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Root.add_section","text":"Add a new Section with the given name Source code in libqtile/layout/tree.py 188 189 190 191 192 193 194 195 def add_section ( self , name ): \"\"\"Add a new Section with the given name\"\"\" if name in self . sections : raise ValueError ( \"Duplicate section name\" ) node = Section ( name ) node . parent = self self . sections [ name ] = node self . children . append ( node )","title":"add_section()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Root.del_section","text":"Remove the Section with the given name Source code in libqtile/layout/tree.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def del_section ( self , name ): \"\"\"Remove the Section with the given name\"\"\" if name not in self . sections : raise ValueError ( \"Section name not found\" ) if len ( self . children ) == 1 : raise ValueError ( \"Can't delete last section\" ) sec = self . sections [ name ] # move the children of the deleted section to the previous section # if delecting the first section, add children to second section idx = max ( self . children . index ( sec ), 1 ) next_sec = self . children [ idx - 1 ] # delete old section, reparent children to next section del self . children [ idx ] next_sec . children . extend ( sec . children ) for i in sec . children : i . parent = next_sec del self . sections [ name ]","title":"del_section()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode","text":"Source code in libqtile/layout/tree.py 40 41 42 43 44 45 def __init__ ( self ): self . children = [] self . parent = None self . expanded = True self . _children_top = None self . _children_bot = None","title":"TreeNode"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode.add_client","text":"Add a node below this node The hint is a node to place the new node after in this nodes children. Source code in libqtile/layout/tree.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def add_client ( self , node , hint = None ): \"\"\"Add a node below this node The `hint` is a node to place the new node after in this nodes children. \"\"\" node . parent = self if hint is not None : try : idx = self . children . index ( hint ) except ValueError : pass else : self . children . insert ( idx + 1 , node ) return self . children . append ( node )","title":"add_client()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode.add_superscript","text":"Prepend superscript denoting the number of hidden children Source code in libqtile/layout/tree.py 88 89 90 91 92 def add_superscript ( self , title ): \"\"\"Prepend superscript denoting the number of hidden children\"\"\" if not self . expanded and self . children : return \" {:d} \" . format ( len ( self . children )) . translate ( to_superscript ) + title return title","title":"add_superscript()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode.button_press","text":"Returns self or sibling which got the click Source code in libqtile/layout/tree.py 77 78 79 80 81 82 83 84 85 86 def button_press ( self , x , y ): \"\"\"Returns self or sibling which got the click\"\"\" # if we store the locations of each child, it would be possible to do # this without having to traverse the tree... if not ( self . _children_top <= y < self . _children_bot ): return for i in self . children : res = i . button_press ( x , y ) if res is not None : return res","title":"button_press()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode.draw","text":"Draw the node and its children to a layout Draws this node to the given layout (presumably a TreeTab), starting from a y-offset of top and at the given level. Source code in libqtile/layout/tree.py 64 65 66 67 68 69 70 71 72 73 74 75 def draw ( self , layout , top , level = 0 ): \"\"\"Draw the node and its children to a layout Draws this node to the given layout (presumably a TreeTab), starting from a y-offset of `top` and at the given level. \"\"\" self . _children_top = top if self . expanded : for i in self . children : top = i . draw ( layout , top , level ) self . _children_bot = top return top","title":"draw()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode.get_first_window","text":"Find the first Window under this node Returns self if this is a Window , otherwise finds first Window by depth-first search Source code in libqtile/layout/tree.py 94 95 96 97 98 99 100 101 102 103 104 105 106 def get_first_window ( self ): \"\"\"Find the first Window under this node Returns self if this is a `Window`, otherwise finds first `Window` by depth-first search \"\"\" if isinstance ( self , Window ): return self if self . expanded : for i in self . children : node = i . get_first_window () if node : return node","title":"get_first_window()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeNode.get_last_window","text":"Find the last Window under this node Finds last Window by depth-first search, otherwise returns self if this is a Window . Source code in libqtile/layout/tree.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def get_last_window ( self ): \"\"\"Find the last Window under this node Finds last `Window` by depth-first search, otherwise returns self if this is a `Window`. \"\"\" if self . expanded : for i in reversed ( self . children ): node = i . get_last_window () if node : return node if isinstance ( self , Window ): return self","title":"get_last_window()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab","text":"Bases: Layout Tree Tab Layout This layout works just like Max but displays tree of the windows at the left border of the screen_rect, which allows you to overview all opened windows. It's designed to work with uzbl-browser but works with other windows too. The panel at the left border contains sections, each of which contains windows. Initially the panel looks like flat lists inside its section, and looks like trees if some of the windows are \"moved\" left or right. For example, it looks like below with two sections initially: :: +------------+ |Section Foo | +------------+ | Window A | +------------+ | Window B | +------------+ | Window C | +------------+ |Section Bar | +------------+ And then it will look like below if \"Window B\" is moved right and \"Window C\" is moved right too: :: +------------+ |Section Foo | +------------+ | Window A | +------------+ | Window B | +------------+ | Window C | +------------+ |Section Bar | +------------+ Source code in libqtile/layout/tree.py 378 379 380 381 382 383 384 385 386 def __init__ ( self , ** config ): Layout . __init__ ( self , ** config ) self . add_defaults ( TreeTab . defaults ) self . _focused = None self . _panel = None self . _drawer = None self . _layout = None self . _tree = Root ( self . sections ) self . _nodes = {}","title":"TreeTab"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab.add_section","text":"Add named section to tree Source code in libqtile/layout/tree.py 613 614 615 616 617 @expose_command () def add_section ( self , name ): \"\"\"Add named section to tree\"\"\" self . _tree . add_section ( name ) self . draw_panel ()","title":"add_section()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab.del_section","text":"Remove named section from tree Source code in libqtile/layout/tree.py 619 620 621 622 623 @expose_command () def del_section ( self , name ): \"\"\"Remove named section from tree\"\"\" self . _tree . del_section ( name ) self . draw_panel ()","title":"del_section()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab.next","text":"Switch down in the window list Source code in libqtile/layout/tree.py 552 553 554 555 556 557 558 559 560 561 562 @expose_command ( \"down\" ) def next ( self ): \"\"\"Switch down in the window list\"\"\" win = None if self . _focused : win = self . _nodes [ self . _focused ] . get_next_window () if not win : win = self . _tree . get_first_window () if win : self . group . focus ( win . window , False ) self . _focused = win . window if win else None","title":"next()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab.previous","text":"Switch up in the window list Source code in libqtile/layout/tree.py 564 565 566 567 568 569 570 571 572 573 574 @expose_command ( \"up\" ) def previous ( self ): \"\"\"Switch up in the window list\"\"\" win = None if self . _focused : win = self . _nodes [ self . _focused ] . get_prev_window () if not win : win = self . _tree . get_last_window () if win : self . group . focus ( win . window , False ) self . _focused = win . window if win else None","title":"previous()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab.sort_windows","text":"Sorts window to sections using sorter function","title":"sort_windows()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.TreeTab.sort_windows--parameters","text":"sorter: function with single arg returning string returns name of the section where window should be create_sections: if this parameter is True (default), if sorter returns unknown section name it will be created dynamically Source code in libqtile/layout/tree.py 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 @expose_command () def sort_windows ( self , sorter , create_sections = True ): \"\"\"Sorts window to sections using sorter function Parameters ========== sorter: function with single arg returning string returns name of the section where window should be create_sections: if this parameter is True (default), if sorter returns unknown section name it will be created dynamically \"\"\" for sec in self . _tree . children : for win in sec . children [:]: nname = sorter ( win . window ) if nname is None or nname == sec . title : continue try : nsec = self . _tree . sections [ nname ] except KeyError : if create_sections : self . _tree . add_section ( nname ) nsec = self . _tree . sections [ nname ] else : continue sec . children . remove ( win ) nsec . children . append ( win ) win . parent = nsec self . draw_panel ()","title":"Parameters"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Window","text":"Bases: TreeNode Source code in libqtile/layout/tree.py 241 242 243 244 def __init__ ( self , win ): super () . __init__ () self . window = win self . _title_top = None","title":"Window"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Window.button_press","text":"Returns self if clicked on title else returns sibling Source code in libqtile/layout/tree.py 276 277 278 279 280 def button_press ( self , x , y ): \"\"\"Returns self if clicked on title else returns sibling\"\"\" if self . _title_top <= y < self . _children_top : return self return super () . button_press ( x , y )","title":"button_press()"},{"location":"reference/libqtile/layout/tree/#libqtile.layout.tree.Window.remove","text":"Removes this Window If this window has children, the first child takes the place of this window, and any remaining children are reparented to that node Source code in libqtile/layout/tree.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def remove ( self ): \"\"\"Removes this Window If this window has children, the first child takes the place of this window, and any remaining children are reparented to that node \"\"\" if self . children : head = self . children [ 0 ] # add the first child to our parent, next to ourselves self . parent . add_client ( head , hint = self ) # move remaining children to be under the new head for i in self . children [ 1 :]: head . add_client ( i ) self . parent . children . remove ( self ) del self . children","title":"remove()"},{"location":"reference/libqtile/layout/verticaltile/","text":"VerticalTile ( ** config ) Bases: _SimpleLayoutBase Tiling layout that works nice on vertically mounted monitors The available height gets divided by the number of panes, if no pane is maximized. If one pane has been maximized, the available height gets split in master- and secondary area. The maximized pane (master pane) gets the full height of the master area and the other panes (secondary panes) share the remaining space. The master area (at default 75%) can grow and shrink via keybindings. :: ----------------- ----------------- --- | | | | | | 1 | <-- Panes | | | | | | | | | |---------------| | | | | | | | | | | | 2 | <-----+ | 1 | | Master Area | | | | | | |---------------| | | | | | | | | | | | 3 | <-----+ | | | | | | | | | |---------------| | |---------------| --- | | | | 2 | | | 4 | <-----+ |---------------| | Secondary Area | | | 3 | | ----------------- ----------------- --- Normal behavior. No One maximized pane in the master area maximized pane. No and two secondary panes in the specific areas. secondary area. :: ----------------------------------- In some cases VerticalTile can be | | useful on horizontal mounted | 1 | monitors two. | | For example if you want to have a |---------------------------------| webbrowser and a shell below it. | | | 2 | | | ----------------------------------- Suggested keybindings: :: Key([modkey], 'j', lazy.layout.down()), Key([modkey], 'k', lazy.layout.up()), Key([modkey], 'Tab', lazy.layout.next()), Key([modkey, 'shift'], 'Tab', lazy.layout.next()), Key([modkey, 'shift'], 'j', lazy.layout.shuffle_down()), Key([modkey, 'shift'], 'k', lazy.layout.shuffle_up()), Key([modkey], 'm', lazy.layout.maximize()), Key([modkey], 'n', lazy.layout.normalize()), Source code in libqtile/layout/verticaltile.py 97 98 99 100 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( VerticalTile . defaults ) self . maximized = None","title":"verticaltile"},{"location":"reference/libqtile/layout/verticaltile/#libqtile.layout.verticaltile.VerticalTile","text":"Bases: _SimpleLayoutBase Tiling layout that works nice on vertically mounted monitors The available height gets divided by the number of panes, if no pane is maximized. If one pane has been maximized, the available height gets split in master- and secondary area. The maximized pane (master pane) gets the full height of the master area and the other panes (secondary panes) share the remaining space. The master area (at default 75%) can grow and shrink via keybindings. :: ----------------- ----------------- --- | | | | | | 1 | <-- Panes | | | | | | | | | |---------------| | | | | | | | | | | | 2 | <-----+ | 1 | | Master Area | | | | | | |---------------| | | | | | | | | | | | 3 | <-----+ | | | | | | | | | |---------------| | |---------------| --- | | | | 2 | | | 4 | <-----+ |---------------| | Secondary Area | | | 3 | | ----------------- ----------------- --- Normal behavior. No One maximized pane in the master area maximized pane. No and two secondary panes in the specific areas. secondary area. :: ----------------------------------- In some cases VerticalTile can be | | useful on horizontal mounted | 1 | monitors two. | | For example if you want to have a |---------------------------------| webbrowser and a shell below it. | | | 2 | | | ----------------------------------- Suggested keybindings: :: Key([modkey], 'j', lazy.layout.down()), Key([modkey], 'k', lazy.layout.up()), Key([modkey], 'Tab', lazy.layout.next()), Key([modkey, 'shift'], 'Tab', lazy.layout.next()), Key([modkey, 'shift'], 'j', lazy.layout.shuffle_down()), Key([modkey, 'shift'], 'k', lazy.layout.shuffle_up()), Key([modkey], 'm', lazy.layout.maximize()), Key([modkey], 'n', lazy.layout.normalize()), Source code in libqtile/layout/verticaltile.py 97 98 99 100 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( VerticalTile . defaults ) self . maximized = None","title":"VerticalTile"},{"location":"reference/libqtile/layout/xmonad/","text":"MonadTall ( ** config ) Bases: _SimpleLayoutBase Emulate the behavior of XMonad's default tiling scheme. Main-Pane: A main pane that contains a single window takes up a vertical portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the grow_main and shrink_main or, while the main pane is in focus, grow and shrink . You may also set the ratio directly with set_ratio . :: --------------------- | | | | | | | | | | | | | | | | | | --------------------- Using the flip method will switch which horizontal side the main pane will occupy. The main pane is considered the \"top\" of the stack. :: --------------------- | | | | | | | | | | | | | | | | | | --------------------- Secondary-panes: Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will share the vertical space of the screen_rect however they can be resized at will with the grow and shrink methods. The other secondary panes will adjust their sizes to smoothly fill all of the space. :: --------------------- --------------------- | | | | |______| | |______| | | | | | | | | | | |______| | | | | | | | |______| | | | | | | --------------------- --------------------- Panes can be moved with the shuffle_up and shuffle_down methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. The opposite is true if the layout is \"flipped\". :: --------------------- --------------------- | | 2 | | 2 | | | |______| |_______| | | | 3 | | 3 | | | 1 |______| |_______| 1 | | | 4 | | 4 | | | | | | | | --------------------- --------------------- Normalizing/Resetting: To restore all secondary client windows to their default size ratios use the normalize method. To reset all client windows to their default sizes, including the primary window, use the reset method. Maximizing: To toggle a client window between its minimum and maximum sizes simply use the maximize on a focused client. Suggested Bindings:: Key([modkey], \"h\", lazy.layout.left()), Key([modkey], \"l\", lazy.layout.right()), Key([modkey], \"j\", lazy.layout.down()), Key([modkey], \"k\", lazy.layout.up()), Key([modkey, \"shift\"], \"h\", lazy.layout.swap_left()), Key([modkey, \"shift\"], \"l\", lazy.layout.swap_right()), Key([modkey, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([modkey, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([modkey], \"i\", lazy.layout.grow()), Key([modkey], \"m\", lazy.layout.shrink()), Key([modkey], \"n\", lazy.layout.normalize()), Key([modkey], \"o\", lazy.layout.maximize()), Key([modkey, \"shift\"], \"space\", lazy.layout.flip()), Source code in libqtile/layout/xmonad.py 191 192 193 194 195 196 197 198 199 200 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( MonadTall . defaults ) if self . single_border_width is None : self . single_border_width = self . border_width if self . single_margin is None : self . single_margin = self . margin self . relative_sizes = [] self . screen_rect = None self . default_ratio = self . ratio add_client ( client ) Add client to layout Source code in libqtile/layout/xmonad.py 222 223 224 225 def add_client ( self , client ): \"Add client to layout\" self . clients . add_client ( client , client_position = self . new_client_position ) self . do_normalize = True clone ( group ) Clone layout for other groups Source code in libqtile/layout/xmonad.py 212 213 214 215 216 217 218 219 220 def clone ( self , group ): \"Clone layout for other groups\" c = _SimpleLayoutBase . clone ( self , group ) c . sizes = [] c . relative_sizes = [] c . screen_rect = group . screen . get_rect () if group . screen else None c . ratio = self . ratio c . align = self . align return c configure ( client , screen_rect ) Position client based on order and sizes Source code in libqtile/layout/xmonad.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def configure ( self , client , screen_rect ): \"Position client based on order and sizes\" self . screen_rect = screen_rect # if no sizes or normalize flag is set, normalize if not self . relative_sizes or self . do_normalize : self . normalize ( False ) # if client not in this layout if not self . clients or client not in self . clients : client . hide () return # determine focus border-color if client . has_focus : px = self . border_focus else : px = self . border_normal # single client - fullscreen if len ( self . clients ) == 1 : client . place ( self . screen_rect . x , self . screen_rect . y , self . screen_rect . width - 2 * self . single_border_width , self . screen_rect . height - 2 * self . single_border_width , self . single_border_width , px , margin = self . single_margin , ) client . unhide () return cidx = self . clients . index ( client ) self . _configure_specific ( client , screen_rect , px , cidx ) client . unhide () flip () Flip the layout horizontally Source code in libqtile/layout/xmonad.py 697 698 699 700 701 @expose_command () def flip ( self ): \"\"\"Flip the layout horizontally\"\"\" self . align = self . _left if self . align == self . _right else self . _right self . group . layout_all () get_shrink_margin ( cidx ) Return how many remaining pixels a client can shrink Source code in libqtile/layout/xmonad.py 412 413 414 415 416 417 418 def get_shrink_margin ( self , cidx ): \"Return how many remaining pixels a client can shrink\" return max ( 0 , self . _get_absolute_size_from_relative ( self . relative_sizes [ cidx ]) - self . min_secondary_size , ) grow () Grow current window Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further. Source code in libqtile/layout/xmonad.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 @expose_command () def grow ( self ): \"\"\"Grow current window Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further. \"\"\" if self . focused == 0 : self . _grow_main ( self . change_ratio ) elif len ( self . clients ) == 2 : self . _grow_solo_secondary ( self . change_ratio ) else : self . _grow_secondary ( self . change_size ) self . group . layout_all () grow_down_shared ( cidx , amt ) Grow lower secondary clients Will grow all secondary clients below the specified index by an equal share of the provided amount. Source code in libqtile/layout/xmonad.py 603 604 605 606 607 608 609 610 611 612 def grow_down_shared ( self , cidx , amt ): \"\"\"Grow lower secondary clients Will grow all secondary clients below the specified index by an equal share of the provided amount. \"\"\" # split grow amount among number of clients per_amt = amt / ( len ( self . relative_sizes ) - 1 - cidx ) for idx in range ( cidx + 1 , len ( self . relative_sizes )): self . _grow ( idx , per_amt ) grow_main () Grow main pane Will grow the main pane, reducing the size of clients in the secondary pane. Source code in libqtile/layout/xmonad.py 568 569 570 571 572 573 574 575 576 @expose_command () def grow_main ( self ): \"\"\"Grow main pane Will grow the main pane, reducing the size of clients in the secondary pane. \"\"\" self . _grow_main ( self . change_ratio ) self . group . layout_all () grow_up_shared ( cidx , amt ) Grow higher secondary clients Will grow all secondary clients above the specified index by an equal share of the provided amount. Source code in libqtile/layout/xmonad.py 592 593 594 595 596 597 598 599 600 601 def grow_up_shared ( self , cidx , amt ): \"\"\"Grow higher secondary clients Will grow all secondary clients above the specified index by an equal share of the provided amount. \"\"\" # split grow amount among number of clients per_amt = amt / cidx for idx in range ( 0 , cidx ): self . _grow ( idx , per_amt ) left () Focus on the closest window to the left of the current window Source code in libqtile/layout/xmonad.py 745 746 747 748 749 750 751 752 @expose_command () def left ( self ): \"\"\"Focus on the closest window to the left of the current window\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] < x ] self . clients . current_client = self . _get_closest ( x , y , candidates ) self . group . focus ( self . clients . current_client ) maximize () Grow the currently focused client to the max size Source code in libqtile/layout/xmonad.py 289 290 291 292 293 294 295 296 297 298 @expose_command () def maximize ( self ): \"Grow the currently focused client to the max size\" # if we have 1 or 2 panes or main pane is focused if len ( self . clients ) < 3 or self . focused == 0 : self . _maximize_main () # secondary is focused else : self . _maximize_secondary () self . group . layout_all () normalize ( redraw = True ) Evenly distribute screen-space among secondary clients Source code in libqtile/layout/xmonad.py 239 240 241 242 243 244 245 246 247 248 249 @expose_command () def normalize ( self , redraw = True ): \"Evenly distribute screen-space among secondary clients\" n = len ( self . clients ) - 1 # exclude main client, 0 # if secondary clients exist if n > 0 and self . screen_rect is not None : self . relative_sizes = [ 1.0 / n ] * n # reset main pane ratio if redraw : self . group . layout_all () self . do_normalize = False remove ( client ) Remove client from layout Source code in libqtile/layout/xmonad.py 227 228 229 230 def remove ( self , client ): \"Remove client from layout\" self . do_normalize = True return self . clients . remove ( client ) reset ( ratio = None , redraw = True ) Reset Layout. Source code in libqtile/layout/xmonad.py 251 252 253 254 255 256 257 @expose_command () def reset ( self , ratio = None , redraw = True ): \"Reset Layout.\" self . ratio = ratio or self . default_ratio if self . align == self . _right : self . align = self . _left self . normalize ( redraw ) right () Focus on the closest window to the right of the current window Source code in libqtile/layout/xmonad.py 754 755 756 757 758 759 760 761 @expose_command () def right ( self ): \"\"\"Focus on the closest window to the right of the current window\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] > x ] self . clients . current_client = self . _get_closest ( x , y , candidates ) self . group . focus ( self . clients . current_client ) set_ratio ( ratio ) Directly set the main pane ratio Source code in libqtile/layout/xmonad.py 232 233 234 235 236 237 @expose_command () def set_ratio ( self , ratio ): \"Directly set the main pane ratio\" ratio = min ( self . max_ratio , ratio ) self . ratio = max ( self . min_ratio , ratio ) self . group . layout_all () shrink () Shrink current window Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size. Source code in libqtile/layout/xmonad.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 @expose_command () def shrink ( self ): \"\"\"Shrink current window Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size. \"\"\" if self . focused == 0 : self . _shrink_main ( self . change_ratio ) elif len ( self . clients ) == 2 : self . _shrink_solo_secondary ( self . change_ratio ) else : self . _shrink_secondary ( self . change_size ) self . group . layout_all () shrink_down ( cidx , amt ) Shrink current window down Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 def shrink_down ( self , cidx , amt ): \"\"\"Shrink current window down Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. \"\"\" left = amt # track unused shrink amount # for each client after specified index for idx in range ( cidx + 1 , len ( self . relative_sizes )): # shrink by current total left-over amount left -= left - self . _shrink ( idx , left ) # return unused shrink amount return left shrink_down_shared ( cidx , amt ) Shrink secondary clients Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with shrink_down . Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def shrink_down_shared ( self , cidx , amt ): \"\"\"Shrink secondary clients Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with ``shrink_down``. Any amount that was unable to be applied to the clients is returned. \"\"\" # split shrink amount among number of clients per_amt = amt / ( len ( self . relative_sizes ) - 1 - cidx ) left = amt # track unused shrink amount # for each client after specified index for idx in range ( cidx + 1 , len ( self . relative_sizes )): # shrink by equal amount and track left-over left -= per_amt - self . _shrink ( idx , per_amt ) # apply non-equal shrinkage secondary pass # in order to use up any left over shrink amounts left = self . shrink_down ( cidx , left ) # return whatever could not be applied return left shrink_main () Shrink main pane Will shrink the main pane, increasing the size of clients in the secondary pane. Source code in libqtile/layout/xmonad.py 578 579 580 581 582 583 584 585 586 @expose_command () def shrink_main ( self ): \"\"\"Shrink main pane Will shrink the main pane, increasing the size of clients in the secondary pane. \"\"\" self . _shrink_main ( self . change_ratio ) self . group . layout_all () shrink_up ( cidx , amt ) Shrink the window up Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 def shrink_up ( self , cidx , amt ): \"\"\"Shrink the window up Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. \"\"\" left = amt # track unused shrink amount # for each client before specified index for idx in range ( 0 , cidx ): # shrink by whatever is left-over of original amount left -= left - self . _shrink ( idx , left ) # return unused shrink amount return left shrink_up_shared ( cidx , amt ) Shrink the shared space Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with shrink_up . Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def shrink_up_shared ( self , cidx , amt ): \"\"\"Shrink the shared space Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with ``shrink_up``. Any amount that was unable to be applied to the clients is returned. \"\"\" # split shrink amount among number of clients per_amt = amt / cidx left = amt # track unused shrink amount # for each client before specified index for idx in range ( 0 , cidx ): # shrink by equal amount and track left-over left -= per_amt - self . _shrink ( idx , per_amt ) # apply non-equal shrinkage secondary pass # in order to use up any left over shrink amounts left = self . _shrink_up ( cidx , left ) # return whatever could not be applied return left shuffle_down () Shuffle the client down the stack Source code in libqtile/layout/xmonad.py 690 691 692 693 694 695 @expose_command () def shuffle_down ( self ): \"\"\"Shuffle the client down the stack\"\"\" self . clients . shuffle_down () self . group . layout_all () self . group . focus ( self . clients [ self . focused ]) shuffle_up () Shuffle the client up the stack Source code in libqtile/layout/xmonad.py 683 684 685 686 687 688 @expose_command () def shuffle_up ( self ): \"\"\"Shuffle the client up the stack\"\"\" self . clients . shuffle_up () self . group . layout_all () self . group . focus ( self . clients . current_client ) swap ( window1 , window2 ) Swap two windows Source code in libqtile/layout/xmonad.py 712 713 714 715 716 717 @expose_command () def swap ( self , window1 , window2 ): \"\"\"Swap two windows\"\"\" self . clients . swap ( window1 , window2 , 1 ) self . group . layout_all () self . group . focus ( window1 ) swap_left () Swap current window with closest window to the left Source code in libqtile/layout/xmonad.py 719 720 721 722 723 724 725 726 @expose_command ( \"shuffle_left\" ) def swap_left ( self ): \"\"\"Swap current window with closest window to the left\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] < x ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target ) swap_main () Swap current window to main pane Source code in libqtile/layout/xmonad.py 737 738 739 740 741 742 743 @expose_command () def swap_main ( self ): \"\"\"Swap current window to main pane\"\"\" if self . align == self . _left : self . swap_left () elif self . align == self . _right : self . swap_right () swap_right () Swap current window with closest window to the right Source code in libqtile/layout/xmonad.py 728 729 730 731 732 733 734 735 @expose_command ( \"shuffle_right\" ) def swap_right ( self ): \"\"\"Swap current window with closest window to the right\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] > x ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target ) MonadThreeCol ( ** config ) Bases: MonadTall Emulate the behavior of XMonad's ThreeColumns layout. A layout similar to tall but with three columns. With an ultra wide display this layout can be used for a huge main window - ideally at the center of the screen - and up to six reasonable sized secondary windows. Main-Pane: A main pane that contains a single window takes up a vertical portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the grow_main and shrink_main or, while the main pane is in focus, grow and shrink . The main pane can also be centered. :: --------------------------- --------------------------- | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | --------------------------- --------------------------- Secondary-panes: Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will be divided into two columns and share the vertical space of each column. However they can be resized at will with the grow and shrink methods. The other secondary panes will adjust their sizes to smoothly fill all of the space. :: --------------------------- --------------------------- | | | | | |______| | | |______| | | | | | | | |______| | | |______| | |______| | | | | | | | | | | |______| | | | | | | | | | --------------------------- --------------------------- Panes can be moved with the shuffle_up and shuffle_down methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. A secondary pane can also be promoted to the main pane with the swap_main method. Normalizing/Resetting: To restore all secondary client windows to their default size ratios use the normalize method. To reset all client windows to their default sizes, including the primary window, use the reset method. Maximizing: To maximized a client window simply use the maximize on a focused client. Source code in libqtile/layout/xmonad.py 1107 1108 1109 def __init__ ( self , ** config ): MonadTall . __init__ ( self , ** config ) self . add_defaults ( MonadThreeCol . defaults ) normalize ( redraw = True ) Evenly distribute screen-space among secondary clients Source code in libqtile/layout/xmonad.py 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 @expose_command () def normalize ( self , redraw = True ): \"\"\"Evenly distribute screen-space among secondary clients\"\"\" if self . screen_rect is not None : self . relative_sizes = [] height = self . screen_rect . height left , right = self . _get_columns () if left . count > 0 : self . relative_sizes += self . _split_integer ( height , left . count ) if right . count > 0 : self . relative_sizes += self . _split_integer ( height , right . count ) if redraw : self . group . layout_all () self . do_normalize = False swap_main () Swap current window to main pane Source code in libqtile/layout/xmonad.py 1216 1217 1218 1219 @expose_command () def swap_main ( self ): \"\"\"Swap current window to main pane\"\"\" self . swap ( self . clients . current_client , self . clients [ 0 ]) MonadWide Bases: MonadTall Emulate the behavior of XMonad's horizontal tiling scheme. This layout attempts to emulate the behavior of XMonad wide tiling scheme. Main-Pane: A main pane that contains a single window takes up a horizontal portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the grow_main and shrink_main or, while the main pane is in focus, grow and shrink . :: --------------------- | | | | | | |___________________| | | | | --------------------- Using the flip method will switch which vertical side the main pane will occupy. The main pane is considered the \"top\" of the stack. :: --------------------- | | |___________________| | | | | | | | | --------------------- Secondary-panes: Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will share the horizontal space of the screen_rect however they can be resized at will with the grow and shrink methods. The other secondary panes will adjust their sizes to smoothly fill all of the space. :: --------------------- --------------------- | | | | | | | | | | | | |___________________| |___________________| | | | | | | | | | | | | | | | | --------------------- --------------------- Panes can be moved with the shuffle_up and shuffle_down methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. The opposite is true if the layout is \"flipped\". :: --------------------- --------------------- | | | 2 | 3 | 4 | | 1 | |_____|_______|_____| | | | | |___________________| | | | | | | | 1 | | 2 | 3 | 4 | | | --------------------- --------------------- Normalizing/Resetting: To restore all secondary client windows to their default size ratios use the normalize method. To reset all client windows to their default sizes, including the primary window, use the reset method. Maximizing: To toggle a client window between its minimum and maximum sizes simply use the maximize on a focused client. Suggested Bindings:: Key([modkey], \"h\", lazy.layout.left()), Key([modkey], \"l\", lazy.layout.right()), Key([modkey], \"j\", lazy.layout.down()), Key([modkey], \"k\", lazy.layout.up()), Key([modkey, \"shift\"], \"h\", lazy.layout.swap_left()), Key([modkey, \"shift\"], \"l\", lazy.layout.swap_right()), Key([modkey, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([modkey, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([modkey], \"i\", lazy.layout.grow()), Key([modkey], \"m\", lazy.layout.shrink()), Key([modkey], \"n\", lazy.layout.normalize()), Key([modkey], \"o\", lazy.layout.maximize()), Key([modkey, \"shift\"], \"space\", lazy.layout.flip()), swap_left () Swap current window with closest window to the down Source code in libqtile/layout/xmonad.py 1001 1002 1003 1004 1005 1006 1007 1008 @expose_command () def swap_left ( self ): \"\"\"Swap current window with closest window to the down\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients . clients if c . info ()[ \"y\" ] > y ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target ) swap_main () Swap current window to main pane Source code in libqtile/layout/xmonad.py 1019 1020 1021 1022 1023 1024 1025 @expose_command () def swap_main ( self ): \"\"\"Swap current window to main pane\"\"\" if self . align == self . _up : self . swap_right () elif self . align == self . _down : self . swap_left () swap_right () Swap current window with closest window to the up Source code in libqtile/layout/xmonad.py 1010 1011 1012 1013 1014 1015 1016 1017 @expose_command () def swap_right ( self ): \"\"\"Swap current window with closest window to the up\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"y\" ] < y ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target )","title":"xmonad"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall","text":"Bases: _SimpleLayoutBase Emulate the behavior of XMonad's default tiling scheme. Main-Pane: A main pane that contains a single window takes up a vertical portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the grow_main and shrink_main or, while the main pane is in focus, grow and shrink . You may also set the ratio directly with set_ratio . :: --------------------- | | | | | | | | | | | | | | | | | | --------------------- Using the flip method will switch which horizontal side the main pane will occupy. The main pane is considered the \"top\" of the stack. :: --------------------- | | | | | | | | | | | | | | | | | | --------------------- Secondary-panes: Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will share the vertical space of the screen_rect however they can be resized at will with the grow and shrink methods. The other secondary panes will adjust their sizes to smoothly fill all of the space. :: --------------------- --------------------- | | | | |______| | |______| | | | | | | | | | | |______| | | | | | | | |______| | | | | | | --------------------- --------------------- Panes can be moved with the shuffle_up and shuffle_down methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. The opposite is true if the layout is \"flipped\". :: --------------------- --------------------- | | 2 | | 2 | | | |______| |_______| | | | 3 | | 3 | | | 1 |______| |_______| 1 | | | 4 | | 4 | | | | | | | | --------------------- --------------------- Normalizing/Resetting: To restore all secondary client windows to their default size ratios use the normalize method. To reset all client windows to their default sizes, including the primary window, use the reset method. Maximizing: To toggle a client window between its minimum and maximum sizes simply use the maximize on a focused client. Suggested Bindings:: Key([modkey], \"h\", lazy.layout.left()), Key([modkey], \"l\", lazy.layout.right()), Key([modkey], \"j\", lazy.layout.down()), Key([modkey], \"k\", lazy.layout.up()), Key([modkey, \"shift\"], \"h\", lazy.layout.swap_left()), Key([modkey, \"shift\"], \"l\", lazy.layout.swap_right()), Key([modkey, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([modkey, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([modkey], \"i\", lazy.layout.grow()), Key([modkey], \"m\", lazy.layout.shrink()), Key([modkey], \"n\", lazy.layout.normalize()), Key([modkey], \"o\", lazy.layout.maximize()), Key([modkey, \"shift\"], \"space\", lazy.layout.flip()), Source code in libqtile/layout/xmonad.py 191 192 193 194 195 196 197 198 199 200 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( MonadTall . defaults ) if self . single_border_width is None : self . single_border_width = self . border_width if self . single_margin is None : self . single_margin = self . margin self . relative_sizes = [] self . screen_rect = None self . default_ratio = self . ratio","title":"MonadTall"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.add_client","text":"Add client to layout Source code in libqtile/layout/xmonad.py 222 223 224 225 def add_client ( self , client ): \"Add client to layout\" self . clients . add_client ( client , client_position = self . new_client_position ) self . do_normalize = True","title":"add_client()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.clone","text":"Clone layout for other groups Source code in libqtile/layout/xmonad.py 212 213 214 215 216 217 218 219 220 def clone ( self , group ): \"Clone layout for other groups\" c = _SimpleLayoutBase . clone ( self , group ) c . sizes = [] c . relative_sizes = [] c . screen_rect = group . screen . get_rect () if group . screen else None c . ratio = self . ratio c . align = self . align return c","title":"clone()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.configure","text":"Position client based on order and sizes Source code in libqtile/layout/xmonad.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def configure ( self , client , screen_rect ): \"Position client based on order and sizes\" self . screen_rect = screen_rect # if no sizes or normalize flag is set, normalize if not self . relative_sizes or self . do_normalize : self . normalize ( False ) # if client not in this layout if not self . clients or client not in self . clients : client . hide () return # determine focus border-color if client . has_focus : px = self . border_focus else : px = self . border_normal # single client - fullscreen if len ( self . clients ) == 1 : client . place ( self . screen_rect . x , self . screen_rect . y , self . screen_rect . width - 2 * self . single_border_width , self . screen_rect . height - 2 * self . single_border_width , self . single_border_width , px , margin = self . single_margin , ) client . unhide () return cidx = self . clients . index ( client ) self . _configure_specific ( client , screen_rect , px , cidx ) client . unhide ()","title":"configure()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.flip","text":"Flip the layout horizontally Source code in libqtile/layout/xmonad.py 697 698 699 700 701 @expose_command () def flip ( self ): \"\"\"Flip the layout horizontally\"\"\" self . align = self . _left if self . align == self . _right else self . _right self . group . layout_all ()","title":"flip()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.get_shrink_margin","text":"Return how many remaining pixels a client can shrink Source code in libqtile/layout/xmonad.py 412 413 414 415 416 417 418 def get_shrink_margin ( self , cidx ): \"Return how many remaining pixels a client can shrink\" return max ( 0 , self . _get_absolute_size_from_relative ( self . relative_sizes [ cidx ]) - self . min_secondary_size , )","title":"get_shrink_margin()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.grow","text":"Grow current window Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further. Source code in libqtile/layout/xmonad.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 @expose_command () def grow ( self ): \"\"\"Grow current window Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further. \"\"\" if self . focused == 0 : self . _grow_main ( self . change_ratio ) elif len ( self . clients ) == 2 : self . _grow_solo_secondary ( self . change_ratio ) else : self . _grow_secondary ( self . change_size ) self . group . layout_all ()","title":"grow()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.grow_down_shared","text":"Grow lower secondary clients Will grow all secondary clients below the specified index by an equal share of the provided amount. Source code in libqtile/layout/xmonad.py 603 604 605 606 607 608 609 610 611 612 def grow_down_shared ( self , cidx , amt ): \"\"\"Grow lower secondary clients Will grow all secondary clients below the specified index by an equal share of the provided amount. \"\"\" # split grow amount among number of clients per_amt = amt / ( len ( self . relative_sizes ) - 1 - cidx ) for idx in range ( cidx + 1 , len ( self . relative_sizes )): self . _grow ( idx , per_amt )","title":"grow_down_shared()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.grow_main","text":"Grow main pane Will grow the main pane, reducing the size of clients in the secondary pane. Source code in libqtile/layout/xmonad.py 568 569 570 571 572 573 574 575 576 @expose_command () def grow_main ( self ): \"\"\"Grow main pane Will grow the main pane, reducing the size of clients in the secondary pane. \"\"\" self . _grow_main ( self . change_ratio ) self . group . layout_all ()","title":"grow_main()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.grow_up_shared","text":"Grow higher secondary clients Will grow all secondary clients above the specified index by an equal share of the provided amount. Source code in libqtile/layout/xmonad.py 592 593 594 595 596 597 598 599 600 601 def grow_up_shared ( self , cidx , amt ): \"\"\"Grow higher secondary clients Will grow all secondary clients above the specified index by an equal share of the provided amount. \"\"\" # split grow amount among number of clients per_amt = amt / cidx for idx in range ( 0 , cidx ): self . _grow ( idx , per_amt )","title":"grow_up_shared()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.left","text":"Focus on the closest window to the left of the current window Source code in libqtile/layout/xmonad.py 745 746 747 748 749 750 751 752 @expose_command () def left ( self ): \"\"\"Focus on the closest window to the left of the current window\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] < x ] self . clients . current_client = self . _get_closest ( x , y , candidates ) self . group . focus ( self . clients . current_client )","title":"left()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.maximize","text":"Grow the currently focused client to the max size Source code in libqtile/layout/xmonad.py 289 290 291 292 293 294 295 296 297 298 @expose_command () def maximize ( self ): \"Grow the currently focused client to the max size\" # if we have 1 or 2 panes or main pane is focused if len ( self . clients ) < 3 or self . focused == 0 : self . _maximize_main () # secondary is focused else : self . _maximize_secondary () self . group . layout_all ()","title":"maximize()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.normalize","text":"Evenly distribute screen-space among secondary clients Source code in libqtile/layout/xmonad.py 239 240 241 242 243 244 245 246 247 248 249 @expose_command () def normalize ( self , redraw = True ): \"Evenly distribute screen-space among secondary clients\" n = len ( self . clients ) - 1 # exclude main client, 0 # if secondary clients exist if n > 0 and self . screen_rect is not None : self . relative_sizes = [ 1.0 / n ] * n # reset main pane ratio if redraw : self . group . layout_all () self . do_normalize = False","title":"normalize()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.remove","text":"Remove client from layout Source code in libqtile/layout/xmonad.py 227 228 229 230 def remove ( self , client ): \"Remove client from layout\" self . do_normalize = True return self . clients . remove ( client )","title":"remove()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.reset","text":"Reset Layout. Source code in libqtile/layout/xmonad.py 251 252 253 254 255 256 257 @expose_command () def reset ( self , ratio = None , redraw = True ): \"Reset Layout.\" self . ratio = ratio or self . default_ratio if self . align == self . _right : self . align = self . _left self . normalize ( redraw )","title":"reset()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.right","text":"Focus on the closest window to the right of the current window Source code in libqtile/layout/xmonad.py 754 755 756 757 758 759 760 761 @expose_command () def right ( self ): \"\"\"Focus on the closest window to the right of the current window\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] > x ] self . clients . current_client = self . _get_closest ( x , y , candidates ) self . group . focus ( self . clients . current_client )","title":"right()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.set_ratio","text":"Directly set the main pane ratio Source code in libqtile/layout/xmonad.py 232 233 234 235 236 237 @expose_command () def set_ratio ( self , ratio ): \"Directly set the main pane ratio\" ratio = min ( self . max_ratio , ratio ) self . ratio = max ( self . min_ratio , ratio ) self . group . layout_all ()","title":"set_ratio()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shrink","text":"Shrink current window Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size. Source code in libqtile/layout/xmonad.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 @expose_command () def shrink ( self ): \"\"\"Shrink current window Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size. \"\"\" if self . focused == 0 : self . _shrink_main ( self . change_ratio ) elif len ( self . clients ) == 2 : self . _shrink_solo_secondary ( self . change_ratio ) else : self . _shrink_secondary ( self . change_size ) self . group . layout_all ()","title":"shrink()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shrink_down","text":"Shrink current window down Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 def shrink_down ( self , cidx , amt ): \"\"\"Shrink current window down Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. \"\"\" left = amt # track unused shrink amount # for each client after specified index for idx in range ( cidx + 1 , len ( self . relative_sizes )): # shrink by current total left-over amount left -= left - self . _shrink ( idx , left ) # return unused shrink amount return left","title":"shrink_down()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shrink_down_shared","text":"Shrink secondary clients Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with shrink_down . Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def shrink_down_shared ( self , cidx , amt ): \"\"\"Shrink secondary clients Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with ``shrink_down``. Any amount that was unable to be applied to the clients is returned. \"\"\" # split shrink amount among number of clients per_amt = amt / ( len ( self . relative_sizes ) - 1 - cidx ) left = amt # track unused shrink amount # for each client after specified index for idx in range ( cidx + 1 , len ( self . relative_sizes )): # shrink by equal amount and track left-over left -= per_amt - self . _shrink ( idx , per_amt ) # apply non-equal shrinkage secondary pass # in order to use up any left over shrink amounts left = self . shrink_down ( cidx , left ) # return whatever could not be applied return left","title":"shrink_down_shared()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shrink_main","text":"Shrink main pane Will shrink the main pane, increasing the size of clients in the secondary pane. Source code in libqtile/layout/xmonad.py 578 579 580 581 582 583 584 585 586 @expose_command () def shrink_main ( self ): \"\"\"Shrink main pane Will shrink the main pane, increasing the size of clients in the secondary pane. \"\"\" self . _shrink_main ( self . change_ratio ) self . group . layout_all ()","title":"shrink_main()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shrink_up","text":"Shrink the window up Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 def shrink_up ( self , cidx , amt ): \"\"\"Shrink the window up Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized. Any amount that was unable to be applied to the clients is returned. \"\"\" left = amt # track unused shrink amount # for each client before specified index for idx in range ( 0 , cidx ): # shrink by whatever is left-over of original amount left -= left - self . _shrink ( idx , left ) # return unused shrink amount return left","title":"shrink_up()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shrink_up_shared","text":"Shrink the shared space Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with shrink_up . Any amount that was unable to be applied to the clients is returned. Source code in libqtile/layout/xmonad.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def shrink_up_shared ( self , cidx , amt ): \"\"\"Shrink the shared space Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with ``shrink_up``. Any amount that was unable to be applied to the clients is returned. \"\"\" # split shrink amount among number of clients per_amt = amt / cidx left = amt # track unused shrink amount # for each client before specified index for idx in range ( 0 , cidx ): # shrink by equal amount and track left-over left -= per_amt - self . _shrink ( idx , per_amt ) # apply non-equal shrinkage secondary pass # in order to use up any left over shrink amounts left = self . _shrink_up ( cidx , left ) # return whatever could not be applied return left","title":"shrink_up_shared()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shuffle_down","text":"Shuffle the client down the stack Source code in libqtile/layout/xmonad.py 690 691 692 693 694 695 @expose_command () def shuffle_down ( self ): \"\"\"Shuffle the client down the stack\"\"\" self . clients . shuffle_down () self . group . layout_all () self . group . focus ( self . clients [ self . focused ])","title":"shuffle_down()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.shuffle_up","text":"Shuffle the client up the stack Source code in libqtile/layout/xmonad.py 683 684 685 686 687 688 @expose_command () def shuffle_up ( self ): \"\"\"Shuffle the client up the stack\"\"\" self . clients . shuffle_up () self . group . layout_all () self . group . focus ( self . clients . current_client )","title":"shuffle_up()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.swap","text":"Swap two windows Source code in libqtile/layout/xmonad.py 712 713 714 715 716 717 @expose_command () def swap ( self , window1 , window2 ): \"\"\"Swap two windows\"\"\" self . clients . swap ( window1 , window2 , 1 ) self . group . layout_all () self . group . focus ( window1 )","title":"swap()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.swap_left","text":"Swap current window with closest window to the left Source code in libqtile/layout/xmonad.py 719 720 721 722 723 724 725 726 @expose_command ( \"shuffle_left\" ) def swap_left ( self ): \"\"\"Swap current window with closest window to the left\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] < x ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target )","title":"swap_left()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.swap_main","text":"Swap current window to main pane Source code in libqtile/layout/xmonad.py 737 738 739 740 741 742 743 @expose_command () def swap_main ( self ): \"\"\"Swap current window to main pane\"\"\" if self . align == self . _left : self . swap_left () elif self . align == self . _right : self . swap_right ()","title":"swap_main()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadTall.swap_right","text":"Swap current window with closest window to the right Source code in libqtile/layout/xmonad.py 728 729 730 731 732 733 734 735 @expose_command ( \"shuffle_right\" ) def swap_right ( self ): \"\"\"Swap current window with closest window to the right\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"x\" ] > x ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target )","title":"swap_right()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadThreeCol","text":"Bases: MonadTall Emulate the behavior of XMonad's ThreeColumns layout. A layout similar to tall but with three columns. With an ultra wide display this layout can be used for a huge main window - ideally at the center of the screen - and up to six reasonable sized secondary windows. Main-Pane: A main pane that contains a single window takes up a vertical portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the grow_main and shrink_main or, while the main pane is in focus, grow and shrink . The main pane can also be centered. :: --------------------------- --------------------------- | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | --------------------------- --------------------------- Secondary-panes: Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will be divided into two columns and share the vertical space of each column. However they can be resized at will with the grow and shrink methods. The other secondary panes will adjust their sizes to smoothly fill all of the space. :: --------------------------- --------------------------- | | | | | |______| | | |______| | | | | | | | |______| | | |______| | |______| | | | | | | | | | | |______| | | | | | | | | | --------------------------- --------------------------- Panes can be moved with the shuffle_up and shuffle_down methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. A secondary pane can also be promoted to the main pane with the swap_main method. Normalizing/Resetting: To restore all secondary client windows to their default size ratios use the normalize method. To reset all client windows to their default sizes, including the primary window, use the reset method. Maximizing: To maximized a client window simply use the maximize on a focused client. Source code in libqtile/layout/xmonad.py 1107 1108 1109 def __init__ ( self , ** config ): MonadTall . __init__ ( self , ** config ) self . add_defaults ( MonadThreeCol . defaults )","title":"MonadThreeCol"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadThreeCol.normalize","text":"Evenly distribute screen-space among secondary clients Source code in libqtile/layout/xmonad.py 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 @expose_command () def normalize ( self , redraw = True ): \"\"\"Evenly distribute screen-space among secondary clients\"\"\" if self . screen_rect is not None : self . relative_sizes = [] height = self . screen_rect . height left , right = self . _get_columns () if left . count > 0 : self . relative_sizes += self . _split_integer ( height , left . count ) if right . count > 0 : self . relative_sizes += self . _split_integer ( height , right . count ) if redraw : self . group . layout_all () self . do_normalize = False","title":"normalize()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadThreeCol.swap_main","text":"Swap current window to main pane Source code in libqtile/layout/xmonad.py 1216 1217 1218 1219 @expose_command () def swap_main ( self ): \"\"\"Swap current window to main pane\"\"\" self . swap ( self . clients . current_client , self . clients [ 0 ])","title":"swap_main()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadWide","text":"Bases: MonadTall Emulate the behavior of XMonad's horizontal tiling scheme. This layout attempts to emulate the behavior of XMonad wide tiling scheme. Main-Pane: A main pane that contains a single window takes up a horizontal portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the grow_main and shrink_main or, while the main pane is in focus, grow and shrink . :: --------------------- | | | | | | |___________________| | | | | --------------------- Using the flip method will switch which vertical side the main pane will occupy. The main pane is considered the \"top\" of the stack. :: --------------------- | | |___________________| | | | | | | | | --------------------- Secondary-panes: Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will share the horizontal space of the screen_rect however they can be resized at will with the grow and shrink methods. The other secondary panes will adjust their sizes to smoothly fill all of the space. :: --------------------- --------------------- | | | | | | | | | | | | |___________________| |___________________| | | | | | | | | | | | | | | | | --------------------- --------------------- Panes can be moved with the shuffle_up and shuffle_down methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. The opposite is true if the layout is \"flipped\". :: --------------------- --------------------- | | | 2 | 3 | 4 | | 1 | |_____|_______|_____| | | | | |___________________| | | | | | | | 1 | | 2 | 3 | 4 | | | --------------------- --------------------- Normalizing/Resetting: To restore all secondary client windows to their default size ratios use the normalize method. To reset all client windows to their default sizes, including the primary window, use the reset method. Maximizing: To toggle a client window between its minimum and maximum sizes simply use the maximize on a focused client. Suggested Bindings:: Key([modkey], \"h\", lazy.layout.left()), Key([modkey], \"l\", lazy.layout.right()), Key([modkey], \"j\", lazy.layout.down()), Key([modkey], \"k\", lazy.layout.up()), Key([modkey, \"shift\"], \"h\", lazy.layout.swap_left()), Key([modkey, \"shift\"], \"l\", lazy.layout.swap_right()), Key([modkey, \"shift\"], \"j\", lazy.layout.shuffle_down()), Key([modkey, \"shift\"], \"k\", lazy.layout.shuffle_up()), Key([modkey], \"i\", lazy.layout.grow()), Key([modkey], \"m\", lazy.layout.shrink()), Key([modkey], \"n\", lazy.layout.normalize()), Key([modkey], \"o\", lazy.layout.maximize()), Key([modkey, \"shift\"], \"space\", lazy.layout.flip()),","title":"MonadWide"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadWide.swap_left","text":"Swap current window with closest window to the down Source code in libqtile/layout/xmonad.py 1001 1002 1003 1004 1005 1006 1007 1008 @expose_command () def swap_left ( self ): \"\"\"Swap current window with closest window to the down\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients . clients if c . info ()[ \"y\" ] > y ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target )","title":"swap_left()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadWide.swap_main","text":"Swap current window to main pane Source code in libqtile/layout/xmonad.py 1019 1020 1021 1022 1023 1024 1025 @expose_command () def swap_main ( self ): \"\"\"Swap current window to main pane\"\"\" if self . align == self . _up : self . swap_right () elif self . align == self . _down : self . swap_left ()","title":"swap_main()"},{"location":"reference/libqtile/layout/xmonad/#libqtile.layout.xmonad.MonadWide.swap_right","text":"Swap current window with closest window to the up Source code in libqtile/layout/xmonad.py 1010 1011 1012 1013 1014 1015 1016 1017 @expose_command () def swap_right ( self ): \"\"\"Swap current window with closest window to the up\"\"\" win = self . clients . current_client x , y = win . x , win . y candidates = [ c for c in self . clients if c . info ()[ \"y\" ] < y ] target = self . _get_closest ( x , y , candidates ) self . swap ( win , target )","title":"swap_right()"},{"location":"reference/libqtile/layout/zoomy/","text":"Zoomy ( ** config ) Bases: _SimpleLayoutBase A layout with single active windows, and few other previews at the right Source code in libqtile/layout/zoomy.py 46 47 48 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Zoomy . defaults )","title":"zoomy"},{"location":"reference/libqtile/layout/zoomy/#libqtile.layout.zoomy.Zoomy","text":"Bases: _SimpleLayoutBase A layout with single active windows, and few other previews at the right Source code in libqtile/layout/zoomy.py 46 47 48 def __init__ ( self , ** config ): _SimpleLayoutBase . __init__ ( self , ** config ) self . add_defaults ( Zoomy . defaults )","title":"Zoomy"},{"location":"reference/libqtile/resources/","text":"","title":"resources"},{"location":"reference/libqtile/resources/default_config/","text":"","title":"default_config"},{"location":"reference/libqtile/scripts/","text":"","title":"scripts"},{"location":"reference/libqtile/scripts/check/","text":"","title":"check"},{"location":"reference/libqtile/scripts/cmd_obj/","text":"Command-line tool to expose qtile.command functionality to shell. This can be used standalone or in other shell scripts. cmd_obj ( args ) Runs tool according to specified arguments. Source code in libqtile/scripts/cmd_obj.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def cmd_obj ( args ) -> None : \"Runs tool according to specified arguments.\" if args . obj_spec : sock_file = args . socket or find_sockfile () ipc_client = Client ( sock_file ) cmd_object = IPCCommandInterface ( ipc_client ) cmd_client = CommandClient ( cmd_object ) obj = get_object ( cmd_client , args . obj_spec ) if args . function == \"help\" : try : print_commands ( \"-o \" + \" \" . join ( args . obj_spec ), obj ) except CommandError : if len ( args . obj_spec ) == 1 : print ( f \" { args . obj_spec } object needs a specified identifier e.g. '-o bar top'.\" ) sys . exit ( 1 ) else : raise elif args . info : print ( args . function + get_formated_info ( obj , args . function , args = True , short = False )) else : ret = run_function ( obj , args . function , args . args ) if ret is not None : pprint . pprint ( ret ) else : print_base_objects () sys . exit ( 1 ) get_formated_info ( obj , cmd , args = True , short = True ) Get documentation for command/function and format it. Returns: * args=True, short=True - '*' if arguments are present and a summary line. * args=True, short=False - (function args) and a summary line. * args=False - a summary line. If 'doc' function is not present in object or there is no doc string for given cmd it returns empty string. The arguments are extracted from doc[0] line, the summary is constructed from doc[1] line. Source code in libqtile/scripts/cmd_obj.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def get_formated_info ( obj : CommandClient , cmd : str , args = True , short = True ) -> str : \"\"\"Get documentation for command/function and format it. Returns: * args=True, short=True - '*' if arguments are present and a summary line. * args=True, short=False - (function args) and a summary line. * args=False - a summary line. If 'doc' function is not present in object or there is no doc string for given cmd it returns empty string. The arguments are extracted from doc[0] line, the summary is constructed from doc[1] line. \"\"\" doc = obj . call ( \"doc\" , cmd ) . splitlines () tdoc = doc [ 0 ] doc_args = tdoc [ tdoc . find ( \"(\" ) : tdoc . find ( \")\" ) + 1 ] . strip () short_description = doc [ 1 ] if len ( doc ) > 1 else \"\" if not args : doc_args = \"\" elif short : doc_args = \" \" if doc_args == \"()\" else \"*\" return ( doc_args + \" \" + short_description ) . rstrip () get_object ( client , argv ) Constructs a path to object and returns given object (if it exists). Source code in libqtile/scripts/cmd_obj.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def get_object ( client : CommandClient , argv : list [ str ]) -> CommandClient : \"\"\" Constructs a path to object and returns given object (if it exists). \"\"\" if argv [ 0 ] == \"cmd\" : argv = argv [ 1 :] # flag noting if we have consumed arg1 as the selector, eg screen[0] parsed_next = False for arg0 , arg1 in itertools . zip_longest ( argv , argv [ 1 :]): # previous argument was an item, skip here if parsed_next : parsed_next = False continue # check if it is an item try : client = client . navigate ( arg0 , arg1 ) parsed_next = True continue except SelectError : pass # check if it is an attr try : client = client . navigate ( arg0 , None ) continue except SelectError : pass print ( \"Specified object does not exist: \" + \" \" . join ( argv )) sys . exit ( 1 ) return client print_base_objects () Prints access objects of Client, use cmd for commands. Source code in libqtile/scripts/cmd_obj.py 150 151 152 153 154 155 def print_base_objects () -> None : \"\"\"Prints access objects of Client, use cmd for commands.\"\"\" root = CommandGraphRoot () actions = [ \"-o cmd\" ] + [ f \"-o { key } \" for key in root . children ] print ( \"Specify an object on which to execute command\" ) print ( \" \\n \" . join ( actions )) print_commands ( prefix , obj ) Print available commands for given object. Source code in libqtile/scripts/cmd_obj.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def print_commands ( prefix : str , obj : CommandClient ) -> None : \"\"\"Print available commands for given object.\"\"\" prefix += \" -f \" cmds = obj . call ( \"commands\" ) output = [] for cmd in cmds : doc_args = get_formated_info ( obj , cmd ) pcmd = prefix + cmd output . append ([ pcmd , doc_args ]) max_cmd = max ( len ( pcmd ) for pcmd , _ in output ) # Print formatted output formatting = \"{:< %d } \\t {} \" % ( max_cmd + 1 ) for line in output : print ( formatting . format ( line [ 0 ], line [ 1 ])) run_function ( client , funcname , args ) Run command with specified args on given object. Source code in libqtile/scripts/cmd_obj.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def run_function ( client : CommandClient , funcname : str , args : list [ str ]) -> str : \"Run command with specified args on given object.\" try : ret = client . call ( funcname , * args ) except SelectError : print ( \"error: Sorry no function \" , funcname ) sys . exit ( 1 ) except CommandError as e : print ( \"error: Command ' {} ' returned error: {} \" . format ( funcname , str ( e ))) sys . exit ( 1 ) except CommandException as e : print ( \"error: Sorry cannot run function ' {} ' with arguments {} : {} \" . format ( funcname , args , str ( e ) ) ) sys . exit ( 1 ) return ret","title":"cmd_obj"},{"location":"reference/libqtile/scripts/cmd_obj/#libqtile.scripts.cmd_obj.cmd_obj","text":"Runs tool according to specified arguments. Source code in libqtile/scripts/cmd_obj.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def cmd_obj ( args ) -> None : \"Runs tool according to specified arguments.\" if args . obj_spec : sock_file = args . socket or find_sockfile () ipc_client = Client ( sock_file ) cmd_object = IPCCommandInterface ( ipc_client ) cmd_client = CommandClient ( cmd_object ) obj = get_object ( cmd_client , args . obj_spec ) if args . function == \"help\" : try : print_commands ( \"-o \" + \" \" . join ( args . obj_spec ), obj ) except CommandError : if len ( args . obj_spec ) == 1 : print ( f \" { args . obj_spec } object needs a specified identifier e.g. '-o bar top'.\" ) sys . exit ( 1 ) else : raise elif args . info : print ( args . function + get_formated_info ( obj , args . function , args = True , short = False )) else : ret = run_function ( obj , args . function , args . args ) if ret is not None : pprint . pprint ( ret ) else : print_base_objects () sys . exit ( 1 )","title":"cmd_obj()"},{"location":"reference/libqtile/scripts/cmd_obj/#libqtile.scripts.cmd_obj.get_formated_info","text":"Get documentation for command/function and format it. Returns: * args=True, short=True - '*' if arguments are present and a summary line. * args=True, short=False - (function args) and a summary line. * args=False - a summary line. If 'doc' function is not present in object or there is no doc string for given cmd it returns empty string. The arguments are extracted from doc[0] line, the summary is constructed from doc[1] line. Source code in libqtile/scripts/cmd_obj.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def get_formated_info ( obj : CommandClient , cmd : str , args = True , short = True ) -> str : \"\"\"Get documentation for command/function and format it. Returns: * args=True, short=True - '*' if arguments are present and a summary line. * args=True, short=False - (function args) and a summary line. * args=False - a summary line. If 'doc' function is not present in object or there is no doc string for given cmd it returns empty string. The arguments are extracted from doc[0] line, the summary is constructed from doc[1] line. \"\"\" doc = obj . call ( \"doc\" , cmd ) . splitlines () tdoc = doc [ 0 ] doc_args = tdoc [ tdoc . find ( \"(\" ) : tdoc . find ( \")\" ) + 1 ] . strip () short_description = doc [ 1 ] if len ( doc ) > 1 else \"\" if not args : doc_args = \"\" elif short : doc_args = \" \" if doc_args == \"()\" else \"*\" return ( doc_args + \" \" + short_description ) . rstrip ()","title":"get_formated_info()"},{"location":"reference/libqtile/scripts/cmd_obj/#libqtile.scripts.cmd_obj.get_object","text":"Constructs a path to object and returns given object (if it exists). Source code in libqtile/scripts/cmd_obj.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def get_object ( client : CommandClient , argv : list [ str ]) -> CommandClient : \"\"\" Constructs a path to object and returns given object (if it exists). \"\"\" if argv [ 0 ] == \"cmd\" : argv = argv [ 1 :] # flag noting if we have consumed arg1 as the selector, eg screen[0] parsed_next = False for arg0 , arg1 in itertools . zip_longest ( argv , argv [ 1 :]): # previous argument was an item, skip here if parsed_next : parsed_next = False continue # check if it is an item try : client = client . navigate ( arg0 , arg1 ) parsed_next = True continue except SelectError : pass # check if it is an attr try : client = client . navigate ( arg0 , None ) continue except SelectError : pass print ( \"Specified object does not exist: \" + \" \" . join ( argv )) sys . exit ( 1 ) return client","title":"get_object()"},{"location":"reference/libqtile/scripts/cmd_obj/#libqtile.scripts.cmd_obj.print_base_objects","text":"Prints access objects of Client, use cmd for commands. Source code in libqtile/scripts/cmd_obj.py 150 151 152 153 154 155 def print_base_objects () -> None : \"\"\"Prints access objects of Client, use cmd for commands.\"\"\" root = CommandGraphRoot () actions = [ \"-o cmd\" ] + [ f \"-o { key } \" for key in root . children ] print ( \"Specify an object on which to execute command\" ) print ( \" \\n \" . join ( actions ))","title":"print_base_objects()"},{"location":"reference/libqtile/scripts/cmd_obj/#libqtile.scripts.cmd_obj.print_commands","text":"Print available commands for given object. Source code in libqtile/scripts/cmd_obj.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def print_commands ( prefix : str , obj : CommandClient ) -> None : \"\"\"Print available commands for given object.\"\"\" prefix += \" -f \" cmds = obj . call ( \"commands\" ) output = [] for cmd in cmds : doc_args = get_formated_info ( obj , cmd ) pcmd = prefix + cmd output . append ([ pcmd , doc_args ]) max_cmd = max ( len ( pcmd ) for pcmd , _ in output ) # Print formatted output formatting = \"{:< %d } \\t {} \" % ( max_cmd + 1 ) for line in output : print ( formatting . format ( line [ 0 ], line [ 1 ]))","title":"print_commands()"},{"location":"reference/libqtile/scripts/cmd_obj/#libqtile.scripts.cmd_obj.run_function","text":"Run command with specified args on given object. Source code in libqtile/scripts/cmd_obj.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def run_function ( client : CommandClient , funcname : str , args : list [ str ]) -> str : \"Run command with specified args on given object.\" try : ret = client . call ( funcname , * args ) except SelectError : print ( \"error: Sorry no function \" , funcname ) sys . exit ( 1 ) except CommandError as e : print ( \"error: Command ' {} ' returned error: {} \" . format ( funcname , str ( e ))) sys . exit ( 1 ) except CommandException as e : print ( \"error: Sorry cannot run function ' {} ' with arguments {} : {} \" . format ( funcname , args , str ( e ) ) ) sys . exit ( 1 ) return ret","title":"run_function()"},{"location":"reference/libqtile/scripts/main/","text":"","title":"main"},{"location":"reference/libqtile/scripts/migrate/","text":"client_name_updated ( query ) Rename window_name_change -> client_name_updated Source code in libqtile/scripts/migrate.py 44 45 46 def client_name_updated ( query ): \"\"\"Rename window_name_change -> client_name_updated\"\"\" return rename_hook ( query , \"window_name_change\" , \"client_name_updated\" ) command_decorators_changes ( query ) Some commands were renamed when moving from cmd_ to decorator syntax for exposed commands. While most code should continue to work, with required changes indicated in log files, some changes may cause breakages. This migration function attempts to address the key changes. Source code in libqtile/scripts/migrate.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def command_decorators_changes ( query ): \"\"\" Some commands were renamed when moving from `cmd_` to decorator syntax for exposed commands. While most code should continue to work, with required changes indicated in log files, some changes may cause breakages. This migration function attempts to address the key changes. \"\"\" return ( query . select_method ( \"cmd_groups\" ) # noqa: BLK100 . rename ( \"get_groups\" ) . select_method ( \"cmd_screens\" ) . rename ( \"get_screens\" ) . select_method ( \"opacity\" ) . rename ( \"set_opacity\" ) . select_method ( \"cmd_opacity\" ) . rename ( \"set_opacity\" ) . select_method ( \"hints\" ) . rename ( \"get_hints\" ) . select_method ( \"cmd_hints\" ) . rename ( \"get_hints\" ) ) rename_cmd_methods ( query ) Renames any method call that starts with \"cmd_\" to remove the prefix. Source code in libqtile/scripts/migrate.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def rename_cmd_methods ( query ): \"\"\" Renames any method call that starts with \"cmd_\" to remove the prefix. \"\"\" select = \"\"\"power< name=any* trailer< \"(\" any* \")\" > any* >\"\"\" def modify ( node , capture , filename ): def search_method ( item ): \"\"\" Result will be a nested list of Node and Leaf objects so we need to be able to recursively check each object. \"\"\" for obj in item : if hasattr ( obj , \"value\" ): if obj . value . startswith ( \"cmd_\" ): obj . value = obj . value [ 4 :] else : search_method ( obj . leaves ()) cmd_name = capture . get ( \"name\" ) search_method ( cmd_name ) return query . select ( select ) . modify ( modify )","title":"migrate"},{"location":"reference/libqtile/scripts/migrate/#libqtile.scripts.migrate.client_name_updated","text":"Rename window_name_change -> client_name_updated Source code in libqtile/scripts/migrate.py 44 45 46 def client_name_updated ( query ): \"\"\"Rename window_name_change -> client_name_updated\"\"\" return rename_hook ( query , \"window_name_change\" , \"client_name_updated\" )","title":"client_name_updated()"},{"location":"reference/libqtile/scripts/migrate/#libqtile.scripts.migrate.command_decorators_changes","text":"Some commands were renamed when moving from cmd_ to decorator syntax for exposed commands. While most code should continue to work, with required changes indicated in log files, some changes may cause breakages. This migration function attempts to address the key changes. Source code in libqtile/scripts/migrate.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def command_decorators_changes ( query ): \"\"\" Some commands were renamed when moving from `cmd_` to decorator syntax for exposed commands. While most code should continue to work, with required changes indicated in log files, some changes may cause breakages. This migration function attempts to address the key changes. \"\"\" return ( query . select_method ( \"cmd_groups\" ) # noqa: BLK100 . rename ( \"get_groups\" ) . select_method ( \"cmd_screens\" ) . rename ( \"get_screens\" ) . select_method ( \"opacity\" ) . rename ( \"set_opacity\" ) . select_method ( \"cmd_opacity\" ) . rename ( \"set_opacity\" ) . select_method ( \"hints\" ) . rename ( \"get_hints\" ) . select_method ( \"cmd_hints\" ) . rename ( \"get_hints\" ) )","title":"command_decorators_changes()"},{"location":"reference/libqtile/scripts/migrate/#libqtile.scripts.migrate.rename_cmd_methods","text":"Renames any method call that starts with \"cmd_\" to remove the prefix. Source code in libqtile/scripts/migrate.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def rename_cmd_methods ( query ): \"\"\" Renames any method call that starts with \"cmd_\" to remove the prefix. \"\"\" select = \"\"\"power< name=any* trailer< \"(\" any* \")\" > any* >\"\"\" def modify ( node , capture , filename ): def search_method ( item ): \"\"\" Result will be a nested list of Node and Leaf objects so we need to be able to recursively check each object. \"\"\" for obj in item : if hasattr ( obj , \"value\" ): if obj . value . startswith ( \"cmd_\" ): obj . value = obj . value [ 4 :] else : search_method ( obj . leaves ()) cmd_name = capture . get ( \"name\" ) search_method ( cmd_name ) return query . select ( select ) . modify ( modify )","title":"rename_cmd_methods()"},{"location":"reference/libqtile/scripts/run_cmd/","text":"Command-line wrapper to run commands and add rules to new windows","title":"run_cmd"},{"location":"reference/libqtile/scripts/shell/","text":"","title":"shell"},{"location":"reference/libqtile/scripts/start/","text":"rename_process () Try to rename the qtile process if py-setproctitle is installed: http://code.google.com/p/py-setproctitle/ Will fail silently if it's not installed. Setting the title lets you do stuff like \"killall qtile\". Source code in libqtile/scripts/start.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def rename_process (): \"\"\" Try to rename the qtile process if py-setproctitle is installed: http://code.google.com/p/py-setproctitle/ Will fail silently if it's not installed. Setting the title lets you do stuff like \"killall qtile\". \"\"\" try : import setproctitle setproctitle . setproctitle ( \"qtile\" ) except ImportError : pass","title":"start"},{"location":"reference/libqtile/scripts/start/#libqtile.scripts.start.rename_process","text":"Try to rename the qtile process if py-setproctitle is installed: http://code.google.com/p/py-setproctitle/ Will fail silently if it's not installed. Setting the title lets you do stuff like \"killall qtile\". Source code in libqtile/scripts/start.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def rename_process (): \"\"\" Try to rename the qtile process if py-setproctitle is installed: http://code.google.com/p/py-setproctitle/ Will fail silently if it's not installed. Setting the title lets you do stuff like \"killall qtile\". \"\"\" try : import setproctitle setproctitle . setproctitle ( \"qtile\" ) except ImportError : pass","title":"rename_process()"},{"location":"reference/libqtile/scripts/top/","text":"Command-line top like for qtile","title":"top"},{"location":"reference/libqtile/widget/","text":"","title":"widget"},{"location":"reference/libqtile/widget/backlight/","text":"Backlight ( ** config ) Bases: base . InLoopPollText A simple widget to show the current brightness of a monitor. If the change_command parameter is set to None, the widget will attempt to use the interface at /sys/class to change brightness. Depending on the setup, the user may need to be added to the video group to have permission to write to this interface. This depends on having the correct udev rules the brightness file; these are typically installed alongside brightness tools such as brightnessctl (which changes the group to 'video') so installing that is an easy way to get it working. You can also bind keyboard shortcuts to the backlight widget with: .. code-block: python from libqtile.widget import backlight Key( [], \"XF86MonBrightnessUp\", lazy.widget['backlight'].change_backlight(backlight.ChangeDirection.UP) ) Key( [], \"XF86MonBrightnessDown\", lazy.widget['backlight'].change_backlight(backlight.ChangeDirection.DOWN) ) Source code in libqtile/widget/backlight.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Backlight . defaults ) self . _future = None self . brightness_file = os . path . join ( BACKLIGHT_DIR , self . backlight_name , self . brightness_file , ) self . max_brightness_file = os . path . join ( BACKLIGHT_DIR , self . backlight_name , self . max_brightness_file , ) self . add_callbacks ( { \"Button4\" : partial ( self . change_backlight , ChangeDirection . UP ), \"Button5\" : partial ( self . change_backlight , ChangeDirection . DOWN ), } )","title":"backlight"},{"location":"reference/libqtile/widget/backlight/#libqtile.widget.backlight.Backlight","text":"Bases: base . InLoopPollText A simple widget to show the current brightness of a monitor. If the change_command parameter is set to None, the widget will attempt to use the interface at /sys/class to change brightness. Depending on the setup, the user may need to be added to the video group to have permission to write to this interface. This depends on having the correct udev rules the brightness file; these are typically installed alongside brightness tools such as brightnessctl (which changes the group to 'video') so installing that is an easy way to get it working. You can also bind keyboard shortcuts to the backlight widget with: .. code-block: python from libqtile.widget import backlight Key( [], \"XF86MonBrightnessUp\", lazy.widget['backlight'].change_backlight(backlight.ChangeDirection.UP) ) Key( [], \"XF86MonBrightnessDown\", lazy.widget['backlight'].change_backlight(backlight.ChangeDirection.DOWN) ) Source code in libqtile/widget/backlight.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Backlight . defaults ) self . _future = None self . brightness_file = os . path . join ( BACKLIGHT_DIR , self . backlight_name , self . brightness_file , ) self . max_brightness_file = os . path . join ( BACKLIGHT_DIR , self . backlight_name , self . max_brightness_file , ) self . add_callbacks ( { \"Button4\" : partial ( self . change_backlight , ChangeDirection . UP ), \"Button5\" : partial ( self . change_backlight , ChangeDirection . DOWN ), } )","title":"Backlight"},{"location":"reference/libqtile/widget/base/","text":"InLoopPollText ( default_text = 'N/A' , ** config ) Bases: _TextBox A common interface for polling some 'fast' information, munging it, and rendering the result in a text box. You probably want to use ThreadPoolText instead. ('fast' here means that this runs /in/ the event loop, so don't block! If you want to run something nontrivial, use ThreadedPollWidget.) Source code in libqtile/widget/base.py 724 725 726 def __init__ ( self , default_text = \"N/A\" , ** config ): _TextBox . __init__ ( self , default_text , ** config ) self . add_defaults ( InLoopPollText . defaults ) MarginMixin Bases: configurable . Configurable Mixin that provides margin(_x|_y|) To use it, subclass and add this to init : self.add_defaults(base.MarginMixin.defaults) Mirror ( reflection , ** config ) Bases: _Widget A widget for showing the same widget content in more than one place, for instance, on bars across multiple screens. You don't need to use it directly; instead, just instantiate your widget once and hand it in to multiple bars. For instance:: cpu = widget.CPUGraph() clock = widget.Clock() screens = [ Screen(top=bar.Bar([widget.GroupBox(), cpu, clock])), Screen(top=bar.Bar([widget.GroupBox(), cpu, clock])), ] Widgets can be passed to more than one bar, so that there don't need to be any duplicates executing the same code all the time, and they'll always be visually identical. This works for all widgets that use drawers (and nothing else) to display their contents. Currently, this is all widgets except for Systray . Source code in libqtile/widget/base.py 880 881 882 883 884 885 def __init__ ( self , reflection , ** config ): _Widget . __init__ ( self , reflection . length , ** config ) self . reflects = reflection self . _length = 0 if self . reflects . length_type == bar . STRETCH : self . length_type = bar . STRETCH PaddingMixin Bases: configurable . Configurable Mixin that provides padding(_x|_y|) To use it, subclass and add this to init : self.add_defaults(base.PaddingMixin.defaults) ThreadPoolText ( text , ** config ) Bases: _TextBox A common interface for wrapping blocking events which when triggered will update a textbox. The poll method is intended to wrap a blocking function which may take quite a while to return anything. It will be executed as a future and should return updated text when completed. It may also return None to disable any further updates. param: text - Initial text to display. Source code in libqtile/widget/base.py 779 780 781 def __init__ ( self , text , ** config ): super () . __init__ ( text , ** config ) self . add_defaults ( ThreadPoolText . defaults ) force_update () Immediately poll the widget. Existing timers are unaffected. Source code in libqtile/widget/base.py 811 812 813 814 @expose_command () def force_update ( self ): \"\"\"Immediately poll the widget. Existing timers are unaffected.\"\"\" self . update ( self . poll ())","title":"base"},{"location":"reference/libqtile/widget/base/#libqtile.widget.base.InLoopPollText","text":"Bases: _TextBox A common interface for polling some 'fast' information, munging it, and rendering the result in a text box. You probably want to use ThreadPoolText instead. ('fast' here means that this runs /in/ the event loop, so don't block! If you want to run something nontrivial, use ThreadedPollWidget.) Source code in libqtile/widget/base.py 724 725 726 def __init__ ( self , default_text = \"N/A\" , ** config ): _TextBox . __init__ ( self , default_text , ** config ) self . add_defaults ( InLoopPollText . defaults )","title":"InLoopPollText"},{"location":"reference/libqtile/widget/base/#libqtile.widget.base.MarginMixin","text":"Bases: configurable . Configurable Mixin that provides margin(_x|_y|) To use it, subclass and add this to init : self.add_defaults(base.MarginMixin.defaults)","title":"MarginMixin"},{"location":"reference/libqtile/widget/base/#libqtile.widget.base.Mirror","text":"Bases: _Widget A widget for showing the same widget content in more than one place, for instance, on bars across multiple screens. You don't need to use it directly; instead, just instantiate your widget once and hand it in to multiple bars. For instance:: cpu = widget.CPUGraph() clock = widget.Clock() screens = [ Screen(top=bar.Bar([widget.GroupBox(), cpu, clock])), Screen(top=bar.Bar([widget.GroupBox(), cpu, clock])), ] Widgets can be passed to more than one bar, so that there don't need to be any duplicates executing the same code all the time, and they'll always be visually identical. This works for all widgets that use drawers (and nothing else) to display their contents. Currently, this is all widgets except for Systray . Source code in libqtile/widget/base.py 880 881 882 883 884 885 def __init__ ( self , reflection , ** config ): _Widget . __init__ ( self , reflection . length , ** config ) self . reflects = reflection self . _length = 0 if self . reflects . length_type == bar . STRETCH : self . length_type = bar . STRETCH","title":"Mirror"},{"location":"reference/libqtile/widget/base/#libqtile.widget.base.PaddingMixin","text":"Bases: configurable . Configurable Mixin that provides padding(_x|_y|) To use it, subclass and add this to init : self.add_defaults(base.PaddingMixin.defaults)","title":"PaddingMixin"},{"location":"reference/libqtile/widget/base/#libqtile.widget.base.ThreadPoolText","text":"Bases: _TextBox A common interface for wrapping blocking events which when triggered will update a textbox. The poll method is intended to wrap a blocking function which may take quite a while to return anything. It will be executed as a future and should return updated text when completed. It may also return None to disable any further updates. param: text - Initial text to display. Source code in libqtile/widget/base.py 779 780 781 def __init__ ( self , text , ** config ): super () . __init__ ( text , ** config ) self . add_defaults ( ThreadPoolText . defaults )","title":"ThreadPoolText"},{"location":"reference/libqtile/widget/base/#libqtile.widget.base.ThreadPoolText.force_update","text":"Immediately poll the widget. Existing timers are unaffected. Source code in libqtile/widget/base.py 811 812 813 814 @expose_command () def force_update ( self ): \"\"\"Immediately poll the widget. Existing timers are unaffected.\"\"\" self . update ( self . poll ())","title":"force_update()"},{"location":"reference/libqtile/widget/battery/","text":"Battery ( ** config ) Bases: base . ThreadPoolText A text-based battery monitoring widget currently supporting FreeBSD Source code in libqtile/widget/battery.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def __init__ ( self , ** config ) -> None : if \"update_delay\" in config : warnings . warn ( \"Change from using update_delay to update_interval for battery widget, removed in 0.15\" , DeprecationWarning , ) config [ \"update_interval\" ] = config . pop ( \"update_delay\" ) base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( self . defaults ) self . _battery = self . _load_battery ( ** config ) self . _has_notified = False self . timeout = int ( self . notification_timeout * 1000 ) build_string ( status ) Determine the string to return for the given battery state Parameters: Name Type Description Default status BatteryStatus The current status of the battery required Returns: Type Description str The string to display for the current status. Source code in libqtile/widget/battery.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def build_string ( self , status : BatteryStatus ) -> str : \"\"\"Determine the string to return for the given battery state Parameters ---------- status: The current status of the battery Returns ------- str The string to display for the current status. \"\"\" if self . hide_threshold is not None and status . percent > self . hide_threshold : return \"\" if self . layout is not None : if status . state == BatteryState . DISCHARGING and status . percent < self . low_percentage : self . layout . colour = self . low_foreground self . background = self . low_background else : self . layout . colour = self . foreground self . background = self . normal_background if status . state == BatteryState . CHARGING : char = self . charge_char elif status . state == BatteryState . DISCHARGING : char = self . discharge_char elif status . state == BatteryState . FULL : if self . show_short_text : return \"Full\" char = self . full_char elif status . state == BatteryState . EMPTY or ( status . state == BatteryState . UNKNOWN and status . percent == 0 ): if self . show_short_text : return \"Empty\" char = self . empty_char else : char = self . unknown_char hour = status . time // 3600 minute = ( status . time // 60 ) % 60 return self . format . format ( char = char , percent = status . percent , watt = status . power , hour = hour , min = minute ) poll () Determine the text to display Function returning a string with battery information to display on the status bar. Should only use the public interface in _Battery to get necessary information for constructing the string. Source code in libqtile/widget/battery.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def poll ( self ) -> str : \"\"\"Determine the text to display Function returning a string with battery information to display on the status bar. Should only use the public interface in _Battery to get necessary information for constructing the string. \"\"\" try : status = self . _battery . update_status () except RuntimeError as e : return \"Error: {} \" . format ( e ) if self . notify_below : percent = int ( status . percent * 100 ) if percent < self . notify_below : if not self . _has_notified : send_notification ( \"Warning\" , \"Battery at {0} %\" . format ( percent ), urgent = True , timeout = self . timeout , ) self . _has_notified = True elif self . _has_notified : self . _has_notified = False return self . build_string ( status ) BatteryIcon ( ** config ) Bases: base . _Widget Battery life indicator widget. Source code in libqtile/widget/battery.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def __init__ ( self , ** config ) -> None : if \"update_delay\" in config : warnings . warn ( \"Change from using update_delay to update_interval for battery widget, removed in 0.15\" , DeprecationWarning , ) config [ \"update_interval\" ] = config . pop ( \"update_delay\" ) base . _Widget . __init__ ( self , length = bar . CALCULATED , ** config ) self . add_defaults ( self . defaults ) self . scale = 1.0 / self . scale # type: float self . length_type = bar . STATIC self . length = 0 self . image_padding = 0 self . surfaces = {} # type: dict[str, Img] self . current_icon = \"battery-missing\" self . _battery = self . _load_battery ( ** config ) default_icon_path () Get the default path to battery icons Source code in libqtile/widget/battery.py 444 445 446 447 def default_icon_path () -> str : \"\"\"Get the default path to battery icons\"\"\" dir_path = Path ( __file__ ) . resolve () / \"..\" / \"..\" / \"resources\" / \"battery-icons\" return str ( dir_path . resolve ()) load_battery ( ** config ) Default battery loading function Loads and returns the _Battery interface suitable for the current running platform. Parameters: Name Type Description Default config required battery required Return The configured _Battery for the current platform. Source code in libqtile/widget/battery.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def load_battery ( ** config ) -> _Battery : \"\"\"Default battery loading function Loads and returns the _Battery interface suitable for the current running platform. Parameters ---------- config: Dictionary of config options that are passed to the generated battery. Return ------ The configured _Battery for the current platform. \"\"\" system = platform . system () if system == \"FreeBSD\" : return _FreeBSDBattery ( str ( config [ \"battery\" ])) elif system == \"Linux\" : return _LinuxBattery ( ** config ) else : raise RuntimeError ( \"Unknown platform!\" )","title":"battery"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.Battery","text":"Bases: base . ThreadPoolText A text-based battery monitoring widget currently supporting FreeBSD Source code in libqtile/widget/battery.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def __init__ ( self , ** config ) -> None : if \"update_delay\" in config : warnings . warn ( \"Change from using update_delay to update_interval for battery widget, removed in 0.15\" , DeprecationWarning , ) config [ \"update_interval\" ] = config . pop ( \"update_delay\" ) base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( self . defaults ) self . _battery = self . _load_battery ( ** config ) self . _has_notified = False self . timeout = int ( self . notification_timeout * 1000 )","title":"Battery"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.Battery.build_string","text":"Determine the string to return for the given battery state Parameters: Name Type Description Default status BatteryStatus The current status of the battery required Returns: Type Description str The string to display for the current status. Source code in libqtile/widget/battery.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def build_string ( self , status : BatteryStatus ) -> str : \"\"\"Determine the string to return for the given battery state Parameters ---------- status: The current status of the battery Returns ------- str The string to display for the current status. \"\"\" if self . hide_threshold is not None and status . percent > self . hide_threshold : return \"\" if self . layout is not None : if status . state == BatteryState . DISCHARGING and status . percent < self . low_percentage : self . layout . colour = self . low_foreground self . background = self . low_background else : self . layout . colour = self . foreground self . background = self . normal_background if status . state == BatteryState . CHARGING : char = self . charge_char elif status . state == BatteryState . DISCHARGING : char = self . discharge_char elif status . state == BatteryState . FULL : if self . show_short_text : return \"Full\" char = self . full_char elif status . state == BatteryState . EMPTY or ( status . state == BatteryState . UNKNOWN and status . percent == 0 ): if self . show_short_text : return \"Empty\" char = self . empty_char else : char = self . unknown_char hour = status . time // 3600 minute = ( status . time // 60 ) % 60 return self . format . format ( char = char , percent = status . percent , watt = status . power , hour = hour , min = minute )","title":"build_string()"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.Battery.poll","text":"Determine the text to display Function returning a string with battery information to display on the status bar. Should only use the public interface in _Battery to get necessary information for constructing the string. Source code in libqtile/widget/battery.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def poll ( self ) -> str : \"\"\"Determine the text to display Function returning a string with battery information to display on the status bar. Should only use the public interface in _Battery to get necessary information for constructing the string. \"\"\" try : status = self . _battery . update_status () except RuntimeError as e : return \"Error: {} \" . format ( e ) if self . notify_below : percent = int ( status . percent * 100 ) if percent < self . notify_below : if not self . _has_notified : send_notification ( \"Warning\" , \"Battery at {0} %\" . format ( percent ), urgent = True , timeout = self . timeout , ) self . _has_notified = True elif self . _has_notified : self . _has_notified = False return self . build_string ( status )","title":"poll()"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.BatteryIcon","text":"Bases: base . _Widget Battery life indicator widget. Source code in libqtile/widget/battery.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def __init__ ( self , ** config ) -> None : if \"update_delay\" in config : warnings . warn ( \"Change from using update_delay to update_interval for battery widget, removed in 0.15\" , DeprecationWarning , ) config [ \"update_interval\" ] = config . pop ( \"update_delay\" ) base . _Widget . __init__ ( self , length = bar . CALCULATED , ** config ) self . add_defaults ( self . defaults ) self . scale = 1.0 / self . scale # type: float self . length_type = bar . STATIC self . length = 0 self . image_padding = 0 self . surfaces = {} # type: dict[str, Img] self . current_icon = \"battery-missing\" self . _battery = self . _load_battery ( ** config )","title":"BatteryIcon"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.default_icon_path","text":"Get the default path to battery icons Source code in libqtile/widget/battery.py 444 445 446 447 def default_icon_path () -> str : \"\"\"Get the default path to battery icons\"\"\" dir_path = Path ( __file__ ) . resolve () / \"..\" / \"..\" / \"resources\" / \"battery-icons\" return str ( dir_path . resolve ())","title":"default_icon_path()"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.load_battery","text":"Default battery loading function Loads and returns the _Battery interface suitable for the current running platform. Parameters: Name Type Description Default config required battery required","title":"load_battery()"},{"location":"reference/libqtile/widget/battery/#libqtile.widget.battery.load_battery--return","text":"The configured _Battery for the current platform. Source code in libqtile/widget/battery.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def load_battery ( ** config ) -> _Battery : \"\"\"Default battery loading function Loads and returns the _Battery interface suitable for the current running platform. Parameters ---------- config: Dictionary of config options that are passed to the generated battery. Return ------ The configured _Battery for the current platform. \"\"\" system = platform . system () if system == \"FreeBSD\" : return _FreeBSDBattery ( str ( config [ \"battery\" ])) elif system == \"Linux\" : return _LinuxBattery ( ** config ) else : raise RuntimeError ( \"Unknown platform!\" )","title":"Return"},{"location":"reference/libqtile/widget/bluetooth/","text":"Bluetooth ( ** config ) Bases: base . _TextBox Displays bluetooth status for a particular connected device. (For example your bluetooth headphones.) Uses dbus-next to communicate with the system bus. Widget requirements: dbus-next_. .. _dbus-next: https://pypi.org/project/dbus-next/ Source code in libqtile/widget/bluetooth.py 54 55 56 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( Bluetooth . defaults )","title":"bluetooth"},{"location":"reference/libqtile/widget/bluetooth/#libqtile.widget.bluetooth.Bluetooth","text":"Bases: base . _TextBox Displays bluetooth status for a particular connected device. (For example your bluetooth headphones.) Uses dbus-next to communicate with the system bus. Widget requirements: dbus-next_. .. _dbus-next: https://pypi.org/project/dbus-next/ Source code in libqtile/widget/bluetooth.py 54 55 56 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( Bluetooth . defaults )","title":"Bluetooth"},{"location":"reference/libqtile/widget/canto/","text":"Canto ( ** config ) Bases: base . ThreadPoolText Display RSS feeds updates using the canto console reader Source code in libqtile/widget/canto.py 41 42 43 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Canto . defaults )","title":"canto"},{"location":"reference/libqtile/widget/canto/#libqtile.widget.canto.Canto","text":"Bases: base . ThreadPoolText Display RSS feeds updates using the canto console reader Source code in libqtile/widget/canto.py 41 42 43 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Canto . defaults )","title":"Canto"},{"location":"reference/libqtile/widget/caps_num_lock_indicator/","text":"CapsNumLockIndicator ( ** config ) Bases: base . ThreadPoolText Really simple widget to show the current Caps/Num Lock state. Source code in libqtile/widget/caps_num_lock_indicator.py 33 34 35 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( CapsNumLockIndicator . defaults ) get_indicators () Return a list with the current state of the keys. Source code in libqtile/widget/caps_num_lock_indicator.py 37 38 39 40 41 42 43 44 45 46 def get_indicators ( self ): \"\"\"Return a list with the current state of the keys.\"\"\" try : output = self . call_process ([ \"xset\" , \"q\" ]) except subprocess . CalledProcessError as err : output = err . output return [] if output . startswith ( \"Keyboard\" ): indicators = re . findall ( r \"(Caps|Num)\\s+Lock:\\s*(\\w*)\" , output ) return indicators poll () Poll content for the text box. Source code in libqtile/widget/caps_num_lock_indicator.py 48 49 50 51 52 def poll ( self ): \"\"\"Poll content for the text box.\"\"\" indicators = self . get_indicators () status = \" \" . join ([ \" \" . join ( indicator ) for indicator in indicators ]) return status","title":"caps_num_lock_indicator"},{"location":"reference/libqtile/widget/caps_num_lock_indicator/#libqtile.widget.caps_num_lock_indicator.CapsNumLockIndicator","text":"Bases: base . ThreadPoolText Really simple widget to show the current Caps/Num Lock state. Source code in libqtile/widget/caps_num_lock_indicator.py 33 34 35 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( CapsNumLockIndicator . defaults )","title":"CapsNumLockIndicator"},{"location":"reference/libqtile/widget/caps_num_lock_indicator/#libqtile.widget.caps_num_lock_indicator.CapsNumLockIndicator.get_indicators","text":"Return a list with the current state of the keys. Source code in libqtile/widget/caps_num_lock_indicator.py 37 38 39 40 41 42 43 44 45 46 def get_indicators ( self ): \"\"\"Return a list with the current state of the keys.\"\"\" try : output = self . call_process ([ \"xset\" , \"q\" ]) except subprocess . CalledProcessError as err : output = err . output return [] if output . startswith ( \"Keyboard\" ): indicators = re . findall ( r \"(Caps|Num)\\s+Lock:\\s*(\\w*)\" , output ) return indicators","title":"get_indicators()"},{"location":"reference/libqtile/widget/caps_num_lock_indicator/#libqtile.widget.caps_num_lock_indicator.CapsNumLockIndicator.poll","text":"Poll content for the text box. Source code in libqtile/widget/caps_num_lock_indicator.py 48 49 50 51 52 def poll ( self ): \"\"\"Poll content for the text box.\"\"\" indicators = self . get_indicators () status = \" \" . join ([ \" \" . join ( indicator ) for indicator in indicators ]) return status","title":"poll()"},{"location":"reference/libqtile/widget/check_updates/","text":"","title":"check_updates"},{"location":"reference/libqtile/widget/chord/","text":"Chord ( width = bar . CALCULATED , ** config ) Bases: base . _TextBox Display current key chord Source code in libqtile/widget/chord.py 46 47 48 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( Chord . defaults )","title":"chord"},{"location":"reference/libqtile/widget/chord/#libqtile.widget.chord.Chord","text":"Bases: base . _TextBox Display current key chord Source code in libqtile/widget/chord.py 46 47 48 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( Chord . defaults )","title":"Chord"},{"location":"reference/libqtile/widget/clipboard/","text":"Clipboard ( width = bar . CALCULATED , ** config ) Bases: base . _TextBox Display current clipboard contents Source code in libqtile/widget/clipboard.py 52 53 54 55 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( Clipboard . defaults ) self . timeout_id = None","title":"clipboard"},{"location":"reference/libqtile/widget/clipboard/#libqtile.widget.clipboard.Clipboard","text":"Bases: base . _TextBox Display current clipboard contents Source code in libqtile/widget/clipboard.py 52 53 54 55 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( Clipboard . defaults ) self . timeout_id = None","title":"Clipboard"},{"location":"reference/libqtile/widget/clock/","text":"Clock ( ** config ) Bases: base . InLoopPollText A simple but flexible text-based clock Source code in libqtile/widget/clock.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Clock . defaults ) if isinstance ( self . timezone , str ): if \"pytz\" in sys . modules : self . timezone = pytz . timezone ( self . timezone ) elif \"dateutil\" in sys . modules : self . timezone = dateutil . tz . gettz ( self . timezone ) else : logger . warning ( \"Clock widget can not infer its timezone from a\" \" string without pytz or dateutil. Install one\" \" of these libraries, or give it a\" \" datetime.tzinfo instance.\" ) if self . timezone is None : logger . debug ( \"Defaulting to the system local timezone.\" )","title":"clock"},{"location":"reference/libqtile/widget/clock/#libqtile.widget.clock.Clock","text":"Bases: base . InLoopPollText A simple but flexible text-based clock Source code in libqtile/widget/clock.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Clock . defaults ) if isinstance ( self . timezone , str ): if \"pytz\" in sys . modules : self . timezone = pytz . timezone ( self . timezone ) elif \"dateutil\" in sys . modules : self . timezone = dateutil . tz . gettz ( self . timezone ) else : logger . warning ( \"Clock widget can not infer its timezone from a\" \" string without pytz or dateutil. Install one\" \" of these libraries, or give it a\" \" datetime.tzinfo instance.\" ) if self . timezone is None : logger . debug ( \"Defaulting to the system local timezone.\" )","title":"Clock"},{"location":"reference/libqtile/widget/cmus/","text":"Cmus ( ** config ) Bases: base . ThreadPoolText A simple Cmus widget. Show the artist and album of now listening song and allow basic mouse control from the bar: - toggle pause (or play if stopped) on left click; - skip forward in playlist on scroll up; - skip backward in playlist on scroll down. Cmus ( https://cmus.github.io ) should be installed. Source code in libqtile/widget/cmus.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Cmus . defaults ) self . status = \"\" self . local = None self . add_callbacks ( { \"Button1\" : self . play , \"Button4\" : partial ( subprocess . Popen , [ \"cmus-remote\" , \"-n\" ]), \"Button5\" : partial ( subprocess . Popen , [ \"cmus-remote\" , \"-r\" ]), } ) get_info () Return a dictionary with info about the current cmus status. Source code in libqtile/widget/cmus.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def get_info ( self ): \"\"\"Return a dictionary with info about the current cmus status.\"\"\" try : output = self . call_process ([ \"cmus-remote\" , \"-C\" , \"status\" ]) except subprocess . CalledProcessError as err : output = err . output if output . startswith ( \"status\" ): output = output . splitlines () info = { \"status\" : \"\" , \"file\" : \"\" , \"artist\" : \"\" , \"album\" : \"\" , \"title\" : \"\" , \"stream\" : \"\" , } for line in output : for data in info : if data in line : index = line . index ( data ) if index < 5 : info [ data ] = line [ len ( data ) + index :] . strip () break elif line . startswith ( \"set\" ): return info return info now_playing () Return a string with the now playing info (Artist - Song Title). Source code in libqtile/widget/cmus.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def now_playing ( self ): \"\"\"Return a string with the now playing info (Artist - Song Title).\"\"\" info = self . get_info () now_playing = \"\" if info : status = info [ \"status\" ] if self . status != status : self . status = status if self . status == \"playing\" : self . layout . colour = self . play_color else : self . layout . colour = self . noplay_color self . local = info [ \"file\" ] . startswith ( \"/\" ) title = info [ \"title\" ] if self . local : artist = info [ \"artist\" ] now_playing = \" {0} - {1} \" . format ( artist , title ) if now_playing == \" - \" : file_path = info [ \"file\" ] file_path = file_path . split ( \"/\" )[ - 1 ] now_playing = file_path else : if info [ \"stream\" ]: now_playing = info [ \"stream\" ] else : now_playing = title if now_playing : now_playing = \"\u266b {0} \" . format ( now_playing ) return pangocffi . markup_escape_text ( now_playing ) play () Play music if stopped, else toggle pause. Source code in libqtile/widget/cmus.py 115 116 117 118 119 120 def play ( self ): \"\"\"Play music if stopped, else toggle pause.\"\"\" if self . status in ( \"playing\" , \"paused\" ): subprocess . Popen ([ \"cmus-remote\" , \"-u\" ]) elif self . status == \"stopped\" : subprocess . Popen ([ \"cmus-remote\" , \"-p\" ]) poll () Poll content for the text box. Source code in libqtile/widget/cmus.py 122 123 124 def poll ( self ): \"\"\"Poll content for the text box.\"\"\" return self . now_playing ()","title":"cmus"},{"location":"reference/libqtile/widget/cmus/#libqtile.widget.cmus.Cmus","text":"Bases: base . ThreadPoolText A simple Cmus widget. Show the artist and album of now listening song and allow basic mouse control from the bar: - toggle pause (or play if stopped) on left click; - skip forward in playlist on scroll up; - skip backward in playlist on scroll down. Cmus ( https://cmus.github.io ) should be installed. Source code in libqtile/widget/cmus.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Cmus . defaults ) self . status = \"\" self . local = None self . add_callbacks ( { \"Button1\" : self . play , \"Button4\" : partial ( subprocess . Popen , [ \"cmus-remote\" , \"-n\" ]), \"Button5\" : partial ( subprocess . Popen , [ \"cmus-remote\" , \"-r\" ]), } )","title":"Cmus"},{"location":"reference/libqtile/widget/cmus/#libqtile.widget.cmus.Cmus.get_info","text":"Return a dictionary with info about the current cmus status. Source code in libqtile/widget/cmus.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def get_info ( self ): \"\"\"Return a dictionary with info about the current cmus status.\"\"\" try : output = self . call_process ([ \"cmus-remote\" , \"-C\" , \"status\" ]) except subprocess . CalledProcessError as err : output = err . output if output . startswith ( \"status\" ): output = output . splitlines () info = { \"status\" : \"\" , \"file\" : \"\" , \"artist\" : \"\" , \"album\" : \"\" , \"title\" : \"\" , \"stream\" : \"\" , } for line in output : for data in info : if data in line : index = line . index ( data ) if index < 5 : info [ data ] = line [ len ( data ) + index :] . strip () break elif line . startswith ( \"set\" ): return info return info","title":"get_info()"},{"location":"reference/libqtile/widget/cmus/#libqtile.widget.cmus.Cmus.now_playing","text":"Return a string with the now playing info (Artist - Song Title). Source code in libqtile/widget/cmus.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def now_playing ( self ): \"\"\"Return a string with the now playing info (Artist - Song Title).\"\"\" info = self . get_info () now_playing = \"\" if info : status = info [ \"status\" ] if self . status != status : self . status = status if self . status == \"playing\" : self . layout . colour = self . play_color else : self . layout . colour = self . noplay_color self . local = info [ \"file\" ] . startswith ( \"/\" ) title = info [ \"title\" ] if self . local : artist = info [ \"artist\" ] now_playing = \" {0} - {1} \" . format ( artist , title ) if now_playing == \" - \" : file_path = info [ \"file\" ] file_path = file_path . split ( \"/\" )[ - 1 ] now_playing = file_path else : if info [ \"stream\" ]: now_playing = info [ \"stream\" ] else : now_playing = title if now_playing : now_playing = \"\u266b {0} \" . format ( now_playing ) return pangocffi . markup_escape_text ( now_playing )","title":"now_playing()"},{"location":"reference/libqtile/widget/cmus/#libqtile.widget.cmus.Cmus.play","text":"Play music if stopped, else toggle pause. Source code in libqtile/widget/cmus.py 115 116 117 118 119 120 def play ( self ): \"\"\"Play music if stopped, else toggle pause.\"\"\" if self . status in ( \"playing\" , \"paused\" ): subprocess . Popen ([ \"cmus-remote\" , \"-u\" ]) elif self . status == \"stopped\" : subprocess . Popen ([ \"cmus-remote\" , \"-p\" ])","title":"play()"},{"location":"reference/libqtile/widget/cmus/#libqtile.widget.cmus.Cmus.poll","text":"Poll content for the text box. Source code in libqtile/widget/cmus.py 122 123 124 def poll ( self ): \"\"\"Poll content for the text box.\"\"\" return self . now_playing ()","title":"poll()"},{"location":"reference/libqtile/widget/config_error/","text":"","title":"config_error"},{"location":"reference/libqtile/widget/countdown/","text":"Countdown ( ** config ) Bases: base . InLoopPollText A simple countdown timer text widget Source code in libqtile/widget/countdown.py 43 44 45 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Countdown . defaults )","title":"countdown"},{"location":"reference/libqtile/widget/countdown/#libqtile.widget.countdown.Countdown","text":"Bases: base . InLoopPollText A simple countdown timer text widget Source code in libqtile/widget/countdown.py 43 44 45 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Countdown . defaults )","title":"Countdown"},{"location":"reference/libqtile/widget/cpu/","text":"CPU ( ** config ) Bases: base . ThreadPoolText A simple widget to display CPU load and frequency. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/cpu.py 44 45 46 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( CPU . defaults )","title":"cpu"},{"location":"reference/libqtile/widget/cpu/#libqtile.widget.cpu.CPU","text":"Bases: base . ThreadPoolText A simple widget to display CPU load and frequency. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/cpu.py 44 45 46 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( CPU . defaults )","title":"CPU"},{"location":"reference/libqtile/widget/crashme/","text":"","title":"crashme"},{"location":"reference/libqtile/widget/crypto_ticker/","text":"CryptoTicker ( ** config ) Bases: GenPollUrl A cryptocurrency ticker widget, data provided by the coinbase.com or the binance.com API. Defaults to displaying currency in whatever the current locale is. Examples: # display the average price of bitcoin in local currency widget.CryptoTicker() # display it in Euros: widget.CryptoTicker(currency=\"EUR\") # or a different cryptocurrency! widget.CryptoTicker(crypto=\"ETH\") # change the currency symbol: widget.CryptoTicker(currency=\"EUR\", symbol=\"\u20ac\") # display from Binance API widget.CryptoTicker(api=\"binance\", currency=\"USDT\") Source code in libqtile/widget/crypto_ticker.py 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( CryptoTicker . defaults ) # set up USD as the currency if no locale is set if self . currency == \"\" : self . currency = \"USD\" # set up $ as the symbol if no locale is set if self . symbol == \"\" : self . symbol = \"$\"","title":"crypto_ticker"},{"location":"reference/libqtile/widget/crypto_ticker/#libqtile.widget.crypto_ticker.CryptoTicker","text":"Bases: GenPollUrl A cryptocurrency ticker widget, data provided by the coinbase.com or the binance.com API. Defaults to displaying currency in whatever the current locale is. Examples: # display the average price of bitcoin in local currency widget.CryptoTicker() # display it in Euros: widget.CryptoTicker(currency=\"EUR\") # or a different cryptocurrency! widget.CryptoTicker(crypto=\"ETH\") # change the currency symbol: widget.CryptoTicker(currency=\"EUR\", symbol=\"\u20ac\") # display from Binance API widget.CryptoTicker(api=\"binance\", currency=\"USDT\") Source code in libqtile/widget/crypto_ticker.py 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( CryptoTicker . defaults ) # set up USD as the currency if no locale is set if self . currency == \"\" : self . currency = \"USD\" # set up $ as the symbol if no locale is set if self . symbol == \"\" : self . symbol = \"$\"","title":"CryptoTicker"},{"location":"reference/libqtile/widget/currentlayout/","text":"CurrentLayout ( width = bar . CALCULATED , ** config ) Bases: base . _TextBox Display the name of the current layout of the current group of the screen, the bar containing the widget, is on. Source code in libqtile/widget/currentlayout.py 43 44 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) CurrentLayoutIcon ( ** config ) Bases: base . _TextBox Display the icon representing the current layout of the current group of the screen on which the bar containing the widget is. If you are using custom layouts, a default icon with question mark will be displayed for them. If you want to use custom icon for your own layout, for example, FooGrid , then create a file named \"layout-foogrid.png\" and place it in ~/.icons directory. You can as well use other directories, but then you need to specify those directories in custom_icon_paths argument for this plugin. The order of icon search is: dirs in custom_icon_paths config argument ~/.icons built-in qtile icons Source code in libqtile/widget/currentlayout.py 109 110 111 112 113 114 115 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( CurrentLayoutIcon . defaults ) self . scale = 1.0 / self . scale self . length_type = bar . STATIC self . length = 0","title":"currentlayout"},{"location":"reference/libqtile/widget/currentlayout/#libqtile.widget.currentlayout.CurrentLayout","text":"Bases: base . _TextBox Display the name of the current layout of the current group of the screen, the bar containing the widget, is on. Source code in libqtile/widget/currentlayout.py 43 44 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config )","title":"CurrentLayout"},{"location":"reference/libqtile/widget/currentlayout/#libqtile.widget.currentlayout.CurrentLayoutIcon","text":"Bases: base . _TextBox Display the icon representing the current layout of the current group of the screen on which the bar containing the widget is. If you are using custom layouts, a default icon with question mark will be displayed for them. If you want to use custom icon for your own layout, for example, FooGrid , then create a file named \"layout-foogrid.png\" and place it in ~/.icons directory. You can as well use other directories, but then you need to specify those directories in custom_icon_paths argument for this plugin. The order of icon search is: dirs in custom_icon_paths config argument ~/.icons built-in qtile icons Source code in libqtile/widget/currentlayout.py 109 110 111 112 113 114 115 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( CurrentLayoutIcon . defaults ) self . scale = 1.0 / self . scale self . length_type = bar . STATIC self . length = 0","title":"CurrentLayoutIcon"},{"location":"reference/libqtile/widget/currentscreen/","text":"CurrentScreen ( width = bar . CALCULATED , ** config ) Bases: base . _TextBox Indicates whether the screen this widget is on is currently active or not Source code in libqtile/widget/currentscreen.py 36 37 38 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( CurrentScreen . defaults )","title":"currentscreen"},{"location":"reference/libqtile/widget/currentscreen/#libqtile.widget.currentscreen.CurrentScreen","text":"Bases: base . _TextBox Indicates whether the screen this widget is on is currently active or not Source code in libqtile/widget/currentscreen.py 36 37 38 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( CurrentScreen . defaults )","title":"CurrentScreen"},{"location":"reference/libqtile/widget/df/","text":"DF ( ** config ) Bases: base . ThreadPoolText Disk Free Widget By default the widget only displays if the space is less than warn_space. Source code in libqtile/widget/df.py 49 50 51 52 53 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( DF . defaults ) self . user_free = 0 self . calc = self . measures [ self . measure ]","title":"df"},{"location":"reference/libqtile/widget/df/#libqtile.widget.df.DF","text":"Bases: base . ThreadPoolText Disk Free Widget By default the widget only displays if the space is less than warn_space. Source code in libqtile/widget/df.py 49 50 51 52 53 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( DF . defaults ) self . user_free = 0 self . calc = self . measures [ self . measure ]","title":"DF"},{"location":"reference/libqtile/widget/generic_poll_text/","text":"GenPollText ( ** config ) Bases: base . ThreadPoolText A generic text widget that polls using poll function to get the text Source code in libqtile/widget/generic_poll_text.py 29 30 31 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( GenPollText . defaults ) GenPollUrl ( ** config ) Bases: base . ThreadPoolText A generic text widget that polls an url and parses it using parse function Source code in libqtile/widget/generic_poll_text.py 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( GenPollUrl . defaults ) self . headers [ \"User-agent\" ] = self . user_agent if self . json : self . headers [ \"Content-Type\" ] = \"application/json\" if self . data and not isinstance ( self . data , str ): self . data = json . dumps ( self . data ) . encode ()","title":"generic_poll_text"},{"location":"reference/libqtile/widget/generic_poll_text/#libqtile.widget.generic_poll_text.GenPollText","text":"Bases: base . ThreadPoolText A generic text widget that polls using poll function to get the text Source code in libqtile/widget/generic_poll_text.py 29 30 31 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( GenPollText . defaults )","title":"GenPollText"},{"location":"reference/libqtile/widget/generic_poll_text/#libqtile.widget.generic_poll_text.GenPollUrl","text":"Bases: base . ThreadPoolText A generic text widget that polls an url and parses it using parse function Source code in libqtile/widget/generic_poll_text.py 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( GenPollUrl . defaults ) self . headers [ \"User-agent\" ] = self . user_agent if self . json : self . headers [ \"Content-Type\" ] = \"application/json\" if self . data and not isinstance ( self . data , str ): self . data = json . dumps ( self . data ) . encode ()","title":"GenPollUrl"},{"location":"reference/libqtile/widget/gmail_checker/","text":"GmailChecker ( ** config ) Bases: base . ThreadPoolText A simple gmail checker. If 'status_only_unseen' is True - set 'fmt' for one argument, ex. 'unseen: {0}' Source code in libqtile/widget/gmail_checker.py 46 47 48 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( GmailChecker . defaults )","title":"gmail_checker"},{"location":"reference/libqtile/widget/gmail_checker/#libqtile.widget.gmail_checker.GmailChecker","text":"Bases: base . ThreadPoolText A simple gmail checker. If 'status_only_unseen' is True - set 'fmt' for one argument, ex. 'unseen: {0}' Source code in libqtile/widget/gmail_checker.py 46 47 48 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( GmailChecker . defaults )","title":"GmailChecker"},{"location":"reference/libqtile/widget/graph/","text":"CPUGraph ( ** config ) Bases: _Graph Display CPU usage graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 223 224 225 226 227 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( CPUGraph . defaults ) self . maxvalue = 100 self . oldvalues = self . _getvalues () HDDBusyGraph ( ** config ) Bases: _Graph Display HDD busy time graph Parses /sys/block/ /stat file and extracts overall device IO usage, based on io_ticks 's value. See https://www.kernel.org/doc/Documentation/block/stat.txt Source code in libqtile/widget/graph.py 429 430 431 432 433 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( HDDBusyGraph . defaults ) self . path = \"/sys/block/ {dev} /stat\" . format ( dev = self . device ) self . _prev = 0 HDDGraph ( ** config ) Bases: _Graph Display HDD free or used space graph Source code in libqtile/widget/graph.py 398 399 400 401 402 403 404 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( HDDGraph . defaults ) stats = statvfs ( self . path ) self . maxvalue = stats . f_blocks * stats . f_frsize values = self . _get_values () self . fulfill ( values ) MemoryGraph ( ** config ) Bases: _Graph Displays a memory usage graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 273 274 275 276 277 278 279 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) val = self . _getvalues () self . maxvalue = val [ \"MemTotal\" ] mem = val [ \"MemTotal\" ] - val [ \"MemFree\" ] - val [ \"Buffers\" ] - val [ \"Cached\" ] self . fulfill ( mem ) NetGraph ( ** config ) Bases: _Graph Display a network usage graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( NetGraph . defaults ) if self . interface == \"auto\" : try : self . interface = self . get_main_iface () except RuntimeError : logger . warning ( \"NetGraph - Automatic interface detection failed, falling back to 'eth0'\" ) self . interface = \"eth0\" if self . bandwidth_type != \"down\" and self . bandwidth_type != \"up\" : raise ValueError ( \"bandwidth type {} not known!\" . format ( self . bandwidth_type )) self . bytes = 0 self . bytes = self . _get_values () SwapGraph ( ** config ) Bases: _Graph Display a swap info graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 306 307 308 309 310 311 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) val = self . _getvalues () self . maxvalue = val [ \"SwapTotal\" ] swap = val [ \"SwapTotal\" ] - val [ \"SwapFree\" ] self . fulfill ( swap )","title":"graph"},{"location":"reference/libqtile/widget/graph/#libqtile.widget.graph.CPUGraph","text":"Bases: _Graph Display CPU usage graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 223 224 225 226 227 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( CPUGraph . defaults ) self . maxvalue = 100 self . oldvalues = self . _getvalues ()","title":"CPUGraph"},{"location":"reference/libqtile/widget/graph/#libqtile.widget.graph.HDDBusyGraph","text":"Bases: _Graph Display HDD busy time graph Parses /sys/block/ /stat file and extracts overall device IO usage, based on io_ticks 's value. See https://www.kernel.org/doc/Documentation/block/stat.txt Source code in libqtile/widget/graph.py 429 430 431 432 433 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( HDDBusyGraph . defaults ) self . path = \"/sys/block/ {dev} /stat\" . format ( dev = self . device ) self . _prev = 0","title":"HDDBusyGraph"},{"location":"reference/libqtile/widget/graph/#libqtile.widget.graph.HDDGraph","text":"Bases: _Graph Display HDD free or used space graph Source code in libqtile/widget/graph.py 398 399 400 401 402 403 404 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( HDDGraph . defaults ) stats = statvfs ( self . path ) self . maxvalue = stats . f_blocks * stats . f_frsize values = self . _get_values () self . fulfill ( values )","title":"HDDGraph"},{"location":"reference/libqtile/widget/graph/#libqtile.widget.graph.MemoryGraph","text":"Bases: _Graph Displays a memory usage graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 273 274 275 276 277 278 279 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) val = self . _getvalues () self . maxvalue = val [ \"MemTotal\" ] mem = val [ \"MemTotal\" ] - val [ \"MemFree\" ] - val [ \"Buffers\" ] - val [ \"Cached\" ] self . fulfill ( mem )","title":"MemoryGraph"},{"location":"reference/libqtile/widget/graph/#libqtile.widget.graph.NetGraph","text":"Bases: _Graph Display a network usage graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) self . add_defaults ( NetGraph . defaults ) if self . interface == \"auto\" : try : self . interface = self . get_main_iface () except RuntimeError : logger . warning ( \"NetGraph - Automatic interface detection failed, falling back to 'eth0'\" ) self . interface = \"eth0\" if self . bandwidth_type != \"down\" and self . bandwidth_type != \"up\" : raise ValueError ( \"bandwidth type {} not known!\" . format ( self . bandwidth_type )) self . bytes = 0 self . bytes = self . _get_values ()","title":"NetGraph"},{"location":"reference/libqtile/widget/graph/#libqtile.widget.graph.SwapGraph","text":"Bases: _Graph Display a swap info graph. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/graph.py 306 307 308 309 310 311 def __init__ ( self , ** config ): _Graph . __init__ ( self , ** config ) val = self . _getvalues () self . maxvalue = val [ \"SwapTotal\" ] swap = val [ \"SwapTotal\" ] - val [ \"SwapFree\" ] self . fulfill ( swap )","title":"SwapGraph"},{"location":"reference/libqtile/widget/groupbox/","text":"AGroupBox ( ** config ) Bases: _GroupBase A widget that graphically displays the current group Source code in libqtile/widget/groupbox.py 154 155 156 def __init__ ( self , ** config ): _GroupBase . __init__ ( self , ** config ) self . add_defaults ( AGroupBox . defaults ) GroupBox ( ** config ) Bases: _GroupBase A widget that graphically displays the current group. All groups are displayed by their label. If the label of a group is the empty string that group will not be displayed. Source code in libqtile/widget/groupbox.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def __init__ ( self , ** config ): _GroupBase . __init__ ( self , ** config ) self . add_defaults ( GroupBox . defaults ) if self . spacing is None : self . spacing = self . margin_x self . clicked = None self . click = None default_callbacks = { \"Button1\" : self . select_group } if self . use_mouse_wheel : default_callbacks . update ( { \"Button5\" if self . invert_mouse_wheel else \"Button4\" : self . prev_group , \"Button4\" if self . invert_mouse_wheel else \"Button5\" : self . next_group , } ) self . add_callbacks ( default_callbacks ) groups () property returns list of visible groups. The existing groups are filtered by the visible_groups attribute and their label. Groups with an empty string as label are never contained. Groups that are not named in visible_groups are not returned. Source code in libqtile/widget/groupbox.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @property def groups ( self ): \"\"\" returns list of visible groups. The existing groups are filtered by the visible_groups attribute and their label. Groups with an empty string as label are never contained. Groups that are not named in visible_groups are not returned. \"\"\" if self . hide_unused : if self . visible_groups : return [ g for g in self . qtile . groups if g . label and ( g . windows or g . screen ) and g . name in self . visible_groups ] else : return [ g for g in self . qtile . groups if g . label and ( g . windows or g . screen )] else : if self . visible_groups : return [ g for g in self . qtile . groups if g . label and g . name in self . visible_groups ] else : return [ g for g in self . qtile . groups if g . label ]","title":"groupbox"},{"location":"reference/libqtile/widget/groupbox/#libqtile.widget.groupbox.AGroupBox","text":"Bases: _GroupBase A widget that graphically displays the current group Source code in libqtile/widget/groupbox.py 154 155 156 def __init__ ( self , ** config ): _GroupBase . __init__ ( self , ** config ) self . add_defaults ( AGroupBox . defaults )","title":"AGroupBox"},{"location":"reference/libqtile/widget/groupbox/#libqtile.widget.groupbox.GroupBox","text":"Bases: _GroupBase A widget that graphically displays the current group. All groups are displayed by their label. If the label of a group is the empty string that group will not be displayed. Source code in libqtile/widget/groupbox.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def __init__ ( self , ** config ): _GroupBase . __init__ ( self , ** config ) self . add_defaults ( GroupBox . defaults ) if self . spacing is None : self . spacing = self . margin_x self . clicked = None self . click = None default_callbacks = { \"Button1\" : self . select_group } if self . use_mouse_wheel : default_callbacks . update ( { \"Button5\" if self . invert_mouse_wheel else \"Button4\" : self . prev_group , \"Button4\" if self . invert_mouse_wheel else \"Button5\" : self . next_group , } ) self . add_callbacks ( default_callbacks )","title":"GroupBox"},{"location":"reference/libqtile/widget/groupbox/#libqtile.widget.groupbox.GroupBox.groups","text":"returns list of visible groups. The existing groups are filtered by the visible_groups attribute and their label. Groups with an empty string as label are never contained. Groups that are not named in visible_groups are not returned. Source code in libqtile/widget/groupbox.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @property def groups ( self ): \"\"\" returns list of visible groups. The existing groups are filtered by the visible_groups attribute and their label. Groups with an empty string as label are never contained. Groups that are not named in visible_groups are not returned. \"\"\" if self . hide_unused : if self . visible_groups : return [ g for g in self . qtile . groups if g . label and ( g . windows or g . screen ) and g . name in self . visible_groups ] else : return [ g for g in self . qtile . groups if g . label and ( g . windows or g . screen )] else : if self . visible_groups : return [ g for g in self . qtile . groups if g . label and g . name in self . visible_groups ] else : return [ g for g in self . qtile . groups if g . label ]","title":"groups()"},{"location":"reference/libqtile/widget/idlerpg/","text":"IdleRPG ( ** config ) Bases: GenPollUrl A widget for monitoring and displaying IdleRPG stats. :: # display idlerpg stats for the player 'pants' on freenode's #idlerpg widget.IdleRPG(url=\"http://xethron.lolhosting.net/xml.php?player=pants\") Widget requirements: xmltodict_. .. _xmltodict: https://pypi.org/project/xmltodict/ Source code in libqtile/widget/idlerpg.py 47 48 49 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( IdleRPG . defaults )","title":"idlerpg"},{"location":"reference/libqtile/widget/idlerpg/#libqtile.widget.idlerpg.IdleRPG","text":"Bases: GenPollUrl A widget for monitoring and displaying IdleRPG stats. :: # display idlerpg stats for the player 'pants' on freenode's #idlerpg widget.IdleRPG(url=\"http://xethron.lolhosting.net/xml.php?player=pants\") Widget requirements: xmltodict_. .. _xmltodict: https://pypi.org/project/xmltodict/ Source code in libqtile/widget/idlerpg.py 47 48 49 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( IdleRPG . defaults )","title":"IdleRPG"},{"location":"reference/libqtile/widget/image/","text":"Image ( length = bar . CALCULATED , ** config ) Bases: base . _Widget , base . MarginMixin Display a PNG image on the bar Source code in libqtile/widget/image.py 41 42 43 44 45 46 47 def __init__ ( self , length = bar . CALCULATED , ** config ): base . _Widget . __init__ ( self , length , ** config ) self . add_defaults ( Image . defaults ) self . add_defaults ( base . MarginMixin . defaults ) # make the default 0 instead self . _variable_defaults [ \"margin\" ] = 0","title":"image"},{"location":"reference/libqtile/widget/image/#libqtile.widget.image.Image","text":"Bases: base . _Widget , base . MarginMixin Display a PNG image on the bar Source code in libqtile/widget/image.py 41 42 43 44 45 46 47 def __init__ ( self , length = bar . CALCULATED , ** config ): base . _Widget . __init__ ( self , length , ** config ) self . add_defaults ( Image . defaults ) self . add_defaults ( base . MarginMixin . defaults ) # make the default 0 instead self . _variable_defaults [ \"margin\" ] = 0","title":"Image"},{"location":"reference/libqtile/widget/imapwidget/","text":"ImapWidget ( ** config ) Bases: base . ThreadPoolText Email IMAP widget This widget will scan one of your imap email boxes and report the number of unseen messages present. I've configured it to only work with imap with ssl. Your password is obtained from the Gnome Keyring. Writing your password to the keyring initially is as simple as (changing out and for your userid and password): 1) create the file ~/.local/share/python_keyring/keyringrc.cfg with the following contents:: [backend] default-keyring=keyring.backends.Gnome.Keyring keyring-path=/home/<userid>/.local/share/keyring/ 2) Execute the following python shell script once:: #!/usr/bin/env python3 import keyring user = <userid> password = <password> keyring.set_password('imapwidget', user, password) mbox names must include the path to the mbox (except for the default INBOX). So, for example if your mailroot is ~/Maildir , and you want to look at the mailbox at HomeMail/fred, the mbox setting would be: mbox=\"~/Maildir/HomeMail/fred\" . Note the nested sets of quotes! Labels can be whatever you choose, of course. Widget requirements: keyring_. .. _keyring: https://pypi.org/project/keyring/ Source code in libqtile/widget/imapwidget.py 75 76 77 78 79 80 81 82 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( ImapWidget . defaults ) password = keyring . get_password ( \"imapwidget\" , self . user ) if password is not None : self . password = password else : logger . critical ( \"Gnome Keyring Error\" )","title":"imapwidget"},{"location":"reference/libqtile/widget/imapwidget/#libqtile.widget.imapwidget.ImapWidget","text":"Bases: base . ThreadPoolText Email IMAP widget This widget will scan one of your imap email boxes and report the number of unseen messages present. I've configured it to only work with imap with ssl. Your password is obtained from the Gnome Keyring. Writing your password to the keyring initially is as simple as (changing out and for your userid and password): 1) create the file ~/.local/share/python_keyring/keyringrc.cfg with the following contents:: [backend] default-keyring=keyring.backends.Gnome.Keyring keyring-path=/home/<userid>/.local/share/keyring/ 2) Execute the following python shell script once:: #!/usr/bin/env python3 import keyring user = <userid> password = <password> keyring.set_password('imapwidget', user, password) mbox names must include the path to the mbox (except for the default INBOX). So, for example if your mailroot is ~/Maildir , and you want to look at the mailbox at HomeMail/fred, the mbox setting would be: mbox=\"~/Maildir/HomeMail/fred\" . Note the nested sets of quotes! Labels can be whatever you choose, of course. Widget requirements: keyring_. .. _keyring: https://pypi.org/project/keyring/ Source code in libqtile/widget/imapwidget.py 75 76 77 78 79 80 81 82 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( ImapWidget . defaults ) password = keyring . get_password ( \"imapwidget\" , self . user ) if password is not None : self . password = password else : logger . critical ( \"Gnome Keyring Error\" )","title":"ImapWidget"},{"location":"reference/libqtile/widget/import_error/","text":"","title":"import_error"},{"location":"reference/libqtile/widget/keyboardkbdd/","text":"KeyboardKbdd ( ** config ) Bases: base . ThreadPoolText Widget for changing keyboard layouts per window, using kbdd kbdd should be installed and running, you can get it from: https://github.com/qnikst/kbdd The widget also requires dbus-next_. .. _dbus-next: https://pypi.org/project/dbus-next/ Source code in libqtile/widget/keyboardkbdd.py 59 60 61 62 63 64 65 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( KeyboardKbdd . defaults ) self . keyboard = self . configured_keyboards [ 0 ] self . is_kbdd_running = self . _check_kbdd () if not self . is_kbdd_running : self . keyboard = \"N/A\"","title":"keyboardkbdd"},{"location":"reference/libqtile/widget/keyboardkbdd/#libqtile.widget.keyboardkbdd.KeyboardKbdd","text":"Bases: base . ThreadPoolText Widget for changing keyboard layouts per window, using kbdd kbdd should be installed and running, you can get it from: https://github.com/qnikst/kbdd The widget also requires dbus-next_. .. _dbus-next: https://pypi.org/project/dbus-next/ Source code in libqtile/widget/keyboardkbdd.py 59 60 61 62 63 64 65 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( KeyboardKbdd . defaults ) self . keyboard = self . configured_keyboards [ 0 ] self . is_kbdd_running = self . _check_kbdd () if not self . is_kbdd_running : self . keyboard = \"N/A\"","title":"KeyboardKbdd"},{"location":"reference/libqtile/widget/keyboardlayout/","text":"KeyboardLayout ( ** config ) Bases: base . InLoopPollText Widget for changing and displaying the current keyboard layout To use this widget effectively you need to specify keyboard layouts you want to use (using \"configured_keyboards\") and bind function \"next_keyboard\" to specific keys in order to change layouts. For example: Key([mod], \"space\", lazy.widget[\"keyboardlayout\"].next_keyboard(), desc=\"Next keyboard layout.\"), When running Qtile with the X11 backend, this widget requires setxkbmap to be available. Source code in libqtile/widget/keyboardlayout.py 157 158 159 160 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( KeyboardLayout . defaults ) self . add_callbacks ({ \"Button1\" : self . next_keyboard }) next_keyboard () set the next layout in the list of configured keyboard layouts as new current layout in use If the current keyboard layout is not in the list, it will set as new layout the first one in the list. Source code in libqtile/widget/keyboardlayout.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 @expose_command () def next_keyboard ( self ): \"\"\"set the next layout in the list of configured keyboard layouts as new current layout in use If the current keyboard layout is not in the list, it will set as new layout the first one in the list. \"\"\" current_keyboard = self . backend . get_keyboard () if current_keyboard in self . configured_keyboards : # iterate the list circularly next_keyboard = self . configured_keyboards [ ( self . configured_keyboards . index ( current_keyboard ) + 1 ) % len ( self . configured_keyboards ) ] else : next_keyboard = self . configured_keyboards [ 0 ] self . backend . set_keyboard ( next_keyboard , self . option ) self . tick ()","title":"keyboardlayout"},{"location":"reference/libqtile/widget/keyboardlayout/#libqtile.widget.keyboardlayout.KeyboardLayout","text":"Bases: base . InLoopPollText Widget for changing and displaying the current keyboard layout To use this widget effectively you need to specify keyboard layouts you want to use (using \"configured_keyboards\") and bind function \"next_keyboard\" to specific keys in order to change layouts. For example: Key([mod], \"space\", lazy.widget[\"keyboardlayout\"].next_keyboard(), desc=\"Next keyboard layout.\"), When running Qtile with the X11 backend, this widget requires setxkbmap to be available. Source code in libqtile/widget/keyboardlayout.py 157 158 159 160 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( KeyboardLayout . defaults ) self . add_callbacks ({ \"Button1\" : self . next_keyboard })","title":"KeyboardLayout"},{"location":"reference/libqtile/widget/keyboardlayout/#libqtile.widget.keyboardlayout.KeyboardLayout.next_keyboard","text":"set the next layout in the list of configured keyboard layouts as new current layout in use If the current keyboard layout is not in the list, it will set as new layout the first one in the list. Source code in libqtile/widget/keyboardlayout.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 @expose_command () def next_keyboard ( self ): \"\"\"set the next layout in the list of configured keyboard layouts as new current layout in use If the current keyboard layout is not in the list, it will set as new layout the first one in the list. \"\"\" current_keyboard = self . backend . get_keyboard () if current_keyboard in self . configured_keyboards : # iterate the list circularly next_keyboard = self . configured_keyboards [ ( self . configured_keyboards . index ( current_keyboard ) + 1 ) % len ( self . configured_keyboards ) ] else : next_keyboard = self . configured_keyboards [ 0 ] self . backend . set_keyboard ( next_keyboard , self . option ) self . tick ()","title":"next_keyboard()"},{"location":"reference/libqtile/widget/khal_calendar/","text":"KhalCalendar ( ** config ) Bases: base . ThreadPoolText Khal calendar widget This widget will display the next appointment on your Khal calendar in the qtile status bar. Appointments within the \"reminder\" time will be highlighted. Widget requirements: dateutil_. .. _dateutil: https://pypi.org/project/python-dateutil/ Source code in libqtile/widget/khal_calendar.py 69 70 71 72 73 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( KhalCalendar . defaults ) self . text = \"Calendar not initialized.\" self . default_foreground = self . foreground","title":"khal_calendar"},{"location":"reference/libqtile/widget/khal_calendar/#libqtile.widget.khal_calendar.KhalCalendar","text":"Bases: base . ThreadPoolText Khal calendar widget This widget will display the next appointment on your Khal calendar in the qtile status bar. Appointments within the \"reminder\" time will be highlighted. Widget requirements: dateutil_. .. _dateutil: https://pypi.org/project/python-dateutil/ Source code in libqtile/widget/khal_calendar.py 69 70 71 72 73 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( KhalCalendar . defaults ) self . text = \"Calendar not initialized.\" self . default_foreground = self . foreground","title":"KhalCalendar"},{"location":"reference/libqtile/widget/launchbar/","text":"This module define a widget that displays icons to launch softwares or commands when clicked -- a launchbar. Only png icon files are displayed, not xpm because cairo doesn't support loading of xpm file. The order of displaying (from left to right) is in the order of the list. If no icon was found for the name provided and if default_icon is set to None then the name is printed instead. If default_icon is defined then this icon is displayed instead. To execute a software: - ('thunderbird', 'thunderbird -safe-mode', 'launch thunderbird in safe mode') To execute a python command in qtile, begin with by 'qshell:' - ('logout', 'qshell:self.qtile.shutdown()', 'logout from qtile') LaunchBar ( _progs = None , width = bar . CALCULATED , ** config ) Bases: base . _Widget A widget that display icons to launch the associated command. Text will displayed when no icon is found. Widget requirements: pyxdg <https://pypi.org/project/pyxdg/> __. Source code in libqtile/widget/launchbar.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , _progs : list [ tuple [ str , str , str ]] | None = None , width = bar . CALCULATED , ** config ): base . _Widget . __init__ ( self , width , ** config ) self . add_defaults ( LaunchBar . defaults ) self . surfaces : dict [ str , Img | base . _TextBox ] = {} self . icons_files : dict [ str , str | None ] = {} self . icons_widths : dict [ str , int ] = {} self . icons_offsets : dict [ str , int ] = {} if _progs : logger . warning ( \"The use of a positional argument in LaunchBar is deprecated. \" \"Please update your config to use progs=[...].\" ) config [ \"progs\" ] = _progs # For now, ignore the comments but may be one day it will be useful self . progs = dict ( enumerate ( [ { \"name\" : prog [ 0 ], \"cmd\" : prog [ 1 ], \"comment\" : prog [ 2 ] if len ( prog ) > 2 else None , } for prog in config . get ( \"progs\" , list ()) ] ) ) self . progs_name = set ([ prog [ \"name\" ] for prog in self . progs . values ()]) self . length_type = bar . STATIC self . length = 0 button_press ( x , y , button ) Launch the associated command to the clicked icon. Source code in libqtile/widget/launchbar.py 224 225 226 227 228 229 230 231 232 233 234 235 def button_press ( self , x , y , button ): \"\"\"Launch the associated command to the clicked icon.\"\"\" base . _Widget . button_press ( self , x , y , button ) if button == 1 : icon = self . get_icon_in_position ( x , y ) if icon is not None : cmd = self . progs [ icon ][ \"cmd\" ] if cmd . startswith ( \"qshell:\" ): exec ( cmd [ 7 :] . lstrip ()) else : self . qtile . spawn ( cmd ) self . draw () calculate_length () Compute the width of the widget according to each icon width. Source code in libqtile/widget/launchbar.py 274 275 276 277 278 def calculate_length ( self ): \"\"\"Compute the width of the widget according to each icon width.\"\"\" return sum ( self . icons_widths [ prg [ \"name\" ]] for prg in self . progs . values () ) + self . padding * ( len ( self . progs ) + 1 ) draw () Draw the icons in the widget. Source code in libqtile/widget/launchbar.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def draw ( self ): \"\"\"Draw the icons in the widget.\"\"\" self . drawer . clear ( self . background or self . bar . background ) xoffset = 0 for i in sorted ( self . progs . keys ()): self . drawer . ctx . save () self . drawer . ctx . translate ( xoffset , 0 ) self . icons_offsets [ i ] = xoffset + self . padding name = self . progs [ i ][ \"name\" ] icon_width = self . icons_widths [ name ] if isinstance ( self . surfaces [ name ], base . _TextBox ): # display the name if no icon was found and no default icon textbox = self . surfaces [ name ] textbox . layout . draw ( self . padding + textbox . actual_padding , int (( self . bar . height - textbox . layout . height ) / 2.0 ) + 1 , ) else : # display an icon self . drawer . ctx . save () self . drawer . ctx . translate ( 0 , self . _icon_padding + self . padding_y ) self . drawer . ctx . set_source ( self . surfaces [ name ]) self . drawer . ctx . paint () self . drawer . ctx . restore () self . drawer . ctx . restore () self . drawer . draw ( offsetx = self . offset + xoffset , offsety = self . offsety , width = icon_width + self . padding , ) xoffset += icon_width + self . padding self . drawer . draw ( offsetx = self . offset , offsety = self . offsety , width = self . width ) get_icon_in_position ( x , y ) Determine which icon is clicked according to its position. Source code in libqtile/widget/launchbar.py 214 215 216 217 218 219 220 221 222 def get_icon_in_position ( self , x , y ): \"\"\"Determine which icon is clicked according to its position.\"\"\" for i in self . progs : if x < ( self . icons_offsets [ i ] + self . icons_widths [ self . progs [ i ][ \"name\" ]] + self . padding / 2 ): return i lookup_icons () Search for the icons corresponding to the commands to execute. Source code in libqtile/widget/launchbar.py 204 205 206 207 208 209 210 211 212 def lookup_icons ( self ): \"\"\"Search for the icons corresponding to the commands to execute.\"\"\" if self . default_icon is not None : if not os . path . isfile ( self . default_icon ): # if the default icon provided is not found, switch to # text mode self . default_icon = None for name in self . progs_name : self . _lookup_icon ( name ) setup_images () Create image structures for each icon files. Source code in libqtile/widget/launchbar.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def setup_images ( self ): \"\"\"Create image structures for each icon files.\"\"\" self . _icon_size = self . icon_size if self . icon_size is not None else self . bar . height - 4 self . _icon_padding = ( self . bar . height - self . _icon_size ) // 2 for img_name , iconfile in self . icons_files . items (): if iconfile is None or self . text_only : # Only warn the user that there's no icon if they haven't set text only mode if not self . text_only : logger . warning ( 'No icon found for application \" %s \" ( %s ) switch to text mode' , img_name , iconfile , ) # if no icon is found and no default icon was set, we just # print the name, based on a textbox. textbox = base . _TextBox () textbox . _configure ( self . qtile , self . bar ) textbox . layout = self . drawer . textlayout ( textbox . text , self . foreground , self . font , self . fontsize , self . fontshadow , markup = textbox . markup , ) # the name will be displayed textbox . text = img_name textbox . calculate_length () self . icons_widths [ img_name ] = textbox . width self . surfaces [ img_name ] = textbox continue else : try : img = Img . from_path ( iconfile ) except cairocffi . Error : logger . exception ( 'Error loading icon for application \" %s \" ( %s )' , img_name , iconfile ) return input_width = img . width input_height = img . height sp = input_height / ( self . _icon_size ) width = int ( input_width / sp ) imgpat = cairocffi . SurfacePattern ( img . surface ) scaler = cairocffi . Matrix () scaler . scale ( sp , sp ) scaler . translate ( self . padding * - 1 , - 2 ) imgpat . set_matrix ( scaler ) imgpat . set_filter ( cairocffi . FILTER_BEST ) self . surfaces [ img_name ] = imgpat self . icons_widths [ img_name ] = width","title":"launchbar"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar","text":"Bases: base . _Widget A widget that display icons to launch the associated command. Text will displayed when no icon is found. Widget requirements: pyxdg <https://pypi.org/project/pyxdg/> __. Source code in libqtile/widget/launchbar.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , _progs : list [ tuple [ str , str , str ]] | None = None , width = bar . CALCULATED , ** config ): base . _Widget . __init__ ( self , width , ** config ) self . add_defaults ( LaunchBar . defaults ) self . surfaces : dict [ str , Img | base . _TextBox ] = {} self . icons_files : dict [ str , str | None ] = {} self . icons_widths : dict [ str , int ] = {} self . icons_offsets : dict [ str , int ] = {} if _progs : logger . warning ( \"The use of a positional argument in LaunchBar is deprecated. \" \"Please update your config to use progs=[...].\" ) config [ \"progs\" ] = _progs # For now, ignore the comments but may be one day it will be useful self . progs = dict ( enumerate ( [ { \"name\" : prog [ 0 ], \"cmd\" : prog [ 1 ], \"comment\" : prog [ 2 ] if len ( prog ) > 2 else None , } for prog in config . get ( \"progs\" , list ()) ] ) ) self . progs_name = set ([ prog [ \"name\" ] for prog in self . progs . values ()]) self . length_type = bar . STATIC self . length = 0","title":"LaunchBar"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar.button_press","text":"Launch the associated command to the clicked icon. Source code in libqtile/widget/launchbar.py 224 225 226 227 228 229 230 231 232 233 234 235 def button_press ( self , x , y , button ): \"\"\"Launch the associated command to the clicked icon.\"\"\" base . _Widget . button_press ( self , x , y , button ) if button == 1 : icon = self . get_icon_in_position ( x , y ) if icon is not None : cmd = self . progs [ icon ][ \"cmd\" ] if cmd . startswith ( \"qshell:\" ): exec ( cmd [ 7 :] . lstrip ()) else : self . qtile . spawn ( cmd ) self . draw ()","title":"button_press()"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar.calculate_length","text":"Compute the width of the widget according to each icon width. Source code in libqtile/widget/launchbar.py 274 275 276 277 278 def calculate_length ( self ): \"\"\"Compute the width of the widget according to each icon width.\"\"\" return sum ( self . icons_widths [ prg [ \"name\" ]] for prg in self . progs . values () ) + self . padding * ( len ( self . progs ) + 1 )","title":"calculate_length()"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar.draw","text":"Draw the icons in the widget. Source code in libqtile/widget/launchbar.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def draw ( self ): \"\"\"Draw the icons in the widget.\"\"\" self . drawer . clear ( self . background or self . bar . background ) xoffset = 0 for i in sorted ( self . progs . keys ()): self . drawer . ctx . save () self . drawer . ctx . translate ( xoffset , 0 ) self . icons_offsets [ i ] = xoffset + self . padding name = self . progs [ i ][ \"name\" ] icon_width = self . icons_widths [ name ] if isinstance ( self . surfaces [ name ], base . _TextBox ): # display the name if no icon was found and no default icon textbox = self . surfaces [ name ] textbox . layout . draw ( self . padding + textbox . actual_padding , int (( self . bar . height - textbox . layout . height ) / 2.0 ) + 1 , ) else : # display an icon self . drawer . ctx . save () self . drawer . ctx . translate ( 0 , self . _icon_padding + self . padding_y ) self . drawer . ctx . set_source ( self . surfaces [ name ]) self . drawer . ctx . paint () self . drawer . ctx . restore () self . drawer . ctx . restore () self . drawer . draw ( offsetx = self . offset + xoffset , offsety = self . offsety , width = icon_width + self . padding , ) xoffset += icon_width + self . padding self . drawer . draw ( offsetx = self . offset , offsety = self . offsety , width = self . width )","title":"draw()"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar.get_icon_in_position","text":"Determine which icon is clicked according to its position. Source code in libqtile/widget/launchbar.py 214 215 216 217 218 219 220 221 222 def get_icon_in_position ( self , x , y ): \"\"\"Determine which icon is clicked according to its position.\"\"\" for i in self . progs : if x < ( self . icons_offsets [ i ] + self . icons_widths [ self . progs [ i ][ \"name\" ]] + self . padding / 2 ): return i","title":"get_icon_in_position()"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar.lookup_icons","text":"Search for the icons corresponding to the commands to execute. Source code in libqtile/widget/launchbar.py 204 205 206 207 208 209 210 211 212 def lookup_icons ( self ): \"\"\"Search for the icons corresponding to the commands to execute.\"\"\" if self . default_icon is not None : if not os . path . isfile ( self . default_icon ): # if the default icon provided is not found, switch to # text mode self . default_icon = None for name in self . progs_name : self . _lookup_icon ( name )","title":"lookup_icons()"},{"location":"reference/libqtile/widget/launchbar/#libqtile.widget.launchbar.LaunchBar.setup_images","text":"Create image structures for each icon files. Source code in libqtile/widget/launchbar.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def setup_images ( self ): \"\"\"Create image structures for each icon files.\"\"\" self . _icon_size = self . icon_size if self . icon_size is not None else self . bar . height - 4 self . _icon_padding = ( self . bar . height - self . _icon_size ) // 2 for img_name , iconfile in self . icons_files . items (): if iconfile is None or self . text_only : # Only warn the user that there's no icon if they haven't set text only mode if not self . text_only : logger . warning ( 'No icon found for application \" %s \" ( %s ) switch to text mode' , img_name , iconfile , ) # if no icon is found and no default icon was set, we just # print the name, based on a textbox. textbox = base . _TextBox () textbox . _configure ( self . qtile , self . bar ) textbox . layout = self . drawer . textlayout ( textbox . text , self . foreground , self . font , self . fontsize , self . fontshadow , markup = textbox . markup , ) # the name will be displayed textbox . text = img_name textbox . calculate_length () self . icons_widths [ img_name ] = textbox . width self . surfaces [ img_name ] = textbox continue else : try : img = Img . from_path ( iconfile ) except cairocffi . Error : logger . exception ( 'Error loading icon for application \" %s \" ( %s )' , img_name , iconfile ) return input_width = img . width input_height = img . height sp = input_height / ( self . _icon_size ) width = int ( input_width / sp ) imgpat = cairocffi . SurfacePattern ( img . surface ) scaler = cairocffi . Matrix () scaler . scale ( sp , sp ) scaler . translate ( self . padding * - 1 , - 2 ) imgpat . set_matrix ( scaler ) imgpat . set_filter ( cairocffi . FILTER_BEST ) self . surfaces [ img_name ] = imgpat self . icons_widths [ img_name ] = width","title":"setup_images()"},{"location":"reference/libqtile/widget/load/","text":"Load ( ** config ) Bases: base . ThreadPoolText A small widget to show the load averages of the system. Depends on psutil. Source code in libqtile/widget/load.py 38 39 40 41 42 43 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( Load . defaults ) self . add_callbacks ({ \"Button1\" : self . cmd_next_load }) self . cycled_times = cycle ( Load . times ) self . set_time ()","title":"load"},{"location":"reference/libqtile/widget/load/#libqtile.widget.load.Load","text":"Bases: base . ThreadPoolText A small widget to show the load averages of the system. Depends on psutil. Source code in libqtile/widget/load.py 38 39 40 41 42 43 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( Load . defaults ) self . add_callbacks ({ \"Button1\" : self . cmd_next_load }) self . cycled_times = cycle ( Load . times ) self . set_time ()","title":"Load"},{"location":"reference/libqtile/widget/maildir/","text":"Maildir ( ** config ) Bases: base . ThreadPoolText A simple widget showing the number of new mails in maildir mailboxes Source code in libqtile/widget/maildir.py 62 63 64 65 66 67 68 69 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Maildir . defaults ) # if it looks like a list of strings then we just convert them # and use the name as the label if isinstance ( self . sub_folders [ 0 ], str ): self . sub_folders = [{ \"path\" : folder , \"label\" : folder } for folder in self . sub_folders ] format_text ( state ) Converts the state of the subfolders to a string Parameters state: dict[str, int] a dictionary mapping subfolder labels to new mail values Returns a string representation of the given state Source code in libqtile/widget/maildir.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def format_text ( self , state : dict [ str , int ]) -> str : \"\"\"Converts the state of the subfolders to a string Parameters ========== state: dict[str, int] a dictionary mapping subfolder labels to new mail values Returns ======= a string representation of the given state \"\"\" if self . total : return self . _format_one ( self . sub_folders [ 0 ][ \"label\" ], sum ( state . values ())) else : return self . separator . join ( self . _format_one ( * item ) for item in state . items ()) poll () Scans the mailbox for new messages Returns A string representing the current mailbox state Source code in libqtile/widget/maildir.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def poll ( self ): \"\"\"Scans the mailbox for new messages Returns ======= A string representing the current mailbox state \"\"\" state = {} def to_maildir_fmt ( paths ): for path in iter ( paths ): yield path . rsplit ( \":\" )[ 0 ] for sub_folder in self . sub_folders : path = os . path . join ( os . path . expanduser ( self . maildir_path ), sub_folder [ \"path\" ]) maildir = mailbox . Maildir ( path ) state [ sub_folder [ \"label\" ]] = 0 for file in to_maildir_fmt ( os . listdir ( os . path . join ( path , \"new\" ))): if file in maildir : state [ sub_folder [ \"label\" ]] += 1 return self . format_text ( state )","title":"maildir"},{"location":"reference/libqtile/widget/maildir/#libqtile.widget.maildir.Maildir","text":"Bases: base . ThreadPoolText A simple widget showing the number of new mails in maildir mailboxes Source code in libqtile/widget/maildir.py 62 63 64 65 66 67 68 69 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Maildir . defaults ) # if it looks like a list of strings then we just convert them # and use the name as the label if isinstance ( self . sub_folders [ 0 ], str ): self . sub_folders = [{ \"path\" : folder , \"label\" : folder } for folder in self . sub_folders ]","title":"Maildir"},{"location":"reference/libqtile/widget/maildir/#libqtile.widget.maildir.Maildir.format_text","text":"Converts the state of the subfolders to a string","title":"format_text()"},{"location":"reference/libqtile/widget/maildir/#libqtile.widget.maildir.Maildir.format_text--parameters","text":"state: dict[str, int] a dictionary mapping subfolder labels to new mail values","title":"Parameters"},{"location":"reference/libqtile/widget/maildir/#libqtile.widget.maildir.Maildir.format_text--returns","text":"a string representation of the given state Source code in libqtile/widget/maildir.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def format_text ( self , state : dict [ str , int ]) -> str : \"\"\"Converts the state of the subfolders to a string Parameters ========== state: dict[str, int] a dictionary mapping subfolder labels to new mail values Returns ======= a string representation of the given state \"\"\" if self . total : return self . _format_one ( self . sub_folders [ 0 ][ \"label\" ], sum ( state . values ())) else : return self . separator . join ( self . _format_one ( * item ) for item in state . items ())","title":"Returns"},{"location":"reference/libqtile/widget/maildir/#libqtile.widget.maildir.Maildir.poll","text":"Scans the mailbox for new messages","title":"poll()"},{"location":"reference/libqtile/widget/maildir/#libqtile.widget.maildir.Maildir.poll--returns","text":"A string representing the current mailbox state Source code in libqtile/widget/maildir.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def poll ( self ): \"\"\"Scans the mailbox for new messages Returns ======= A string representing the current mailbox state \"\"\" state = {} def to_maildir_fmt ( paths ): for path in iter ( paths ): yield path . rsplit ( \":\" )[ 0 ] for sub_folder in self . sub_folders : path = os . path . join ( os . path . expanduser ( self . maildir_path ), sub_folder [ \"path\" ]) maildir = mailbox . Maildir ( path ) state [ sub_folder [ \"label\" ]] = 0 for file in to_maildir_fmt ( os . listdir ( os . path . join ( path , \"new\" ))): if file in maildir : state [ sub_folder [ \"label\" ]] += 1 return self . format_text ( state )","title":"Returns"},{"location":"reference/libqtile/widget/memory/","text":"Memory ( ** config ) Bases: base . ThreadPoolText Displays memory/swap usage MemUsed: Returns memory in use MemTotal: Returns total amount of memory MemFree: Returns amount of memory free MemPercent: Returns memory in use as a percentage Buffers: Returns buffer amount Active: Returns active memory Inactive: Returns inactive memory Shmem: Returns shared memory SwapTotal: Returns total amount of swap SwapFree: Returns amount of swap free SwapUsed: Returns amount of swap in use SwapPercent: Returns swap in use as a percentage Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/memory.py 59 60 61 62 63 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( Memory . defaults ) self . calc_mem = self . measures [ self . measure_mem ] self . calc_swap = self . measures [ self . measure_swap ]","title":"memory"},{"location":"reference/libqtile/widget/memory/#libqtile.widget.memory.Memory","text":"Bases: base . ThreadPoolText Displays memory/swap usage MemUsed: Returns memory in use MemTotal: Returns total amount of memory MemFree: Returns amount of memory free MemPercent: Returns memory in use as a percentage Buffers: Returns buffer amount Active: Returns active memory Inactive: Returns inactive memory Shmem: Returns shared memory SwapTotal: Returns total amount of swap SwapFree: Returns amount of swap free SwapUsed: Returns amount of swap in use SwapPercent: Returns swap in use as a percentage Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/memory.py 59 60 61 62 63 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( Memory . defaults ) self . calc_mem = self . measures [ self . measure_mem ] self . calc_swap = self . measures [ self . measure_swap ]","title":"Memory"},{"location":"reference/libqtile/widget/moc/","text":"Moc ( ** config ) Bases: base . ThreadPoolText A simple MOC widget. Show the artist and album of now listening song and allow basic mouse control from the bar: toggle pause (or play if stopped) on left click; skip forward in playlist on scroll up; skip backward in playlist on scroll down. MOC ( http://moc.daper.net ) should be installed. Source code in libqtile/widget/moc.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Moc . defaults ) self . status = \"\" self . local = None self . add_callbacks ( { \"Button1\" : self . play , \"Button4\" : partial ( subprocess . Popen , [ \"mocp\" , \"-f\" ]), \"Button5\" : partial ( subprocess . Popen , [ \"mocp\" , \"-r\" ]), } ) get_info () Return a dictionary with info about the current MOC status. Source code in libqtile/widget/moc.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_info ( self ): \"\"\"Return a dictionary with info about the current MOC status.\"\"\" try : output = self . call_process ([ \"mocp\" , \"-i\" ]) except subprocess . CalledProcessError as err : output = err . output if output . startswith ( \"State\" ): output = output . splitlines () info = { \"State\" : \"\" , \"File\" : \"\" , \"SongTitle\" : \"\" , \"Artist\" : \"\" , \"Album\" : \"\" } for line in output : for data in info : if data in line : info [ data ] = line [ len ( data ) + 2 :] . strip () break return info now_playing () Return a string with the now playing info (Artist - Song Title). Source code in libqtile/widget/moc.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def now_playing ( self ): \"\"\"Return a string with the now playing info (Artist - Song Title).\"\"\" info = self . get_info () now_playing = \"\" if info : status = info [ \"State\" ] if self . status != status : self . status = status if self . status == \"PLAY\" : self . layout . colour = self . play_color else : self . layout . colour = self . noplay_color title = info [ \"SongTitle\" ] artist = info [ \"Artist\" ] if title and artist : now_playing = \"\u266b {0} - {1} \" . format ( artist , title ) elif title : now_playing = \"\u266b {0} \" . format ( title ) else : basename = os . path . basename ( info [ \"File\" ]) filename = os . path . splitext ( basename )[ 0 ] now_playing = \"\u266b {0} \" . format ( filename ) if self . status == \"STOP\" : now_playing = \"\u266b\" return now_playing play () Play music if stopped, else toggle pause. Source code in libqtile/widget/moc.py 102 103 104 105 106 107 def play ( self ): \"\"\"Play music if stopped, else toggle pause.\"\"\" if self . status in ( \"PLAY\" , \"PAUSE\" ): subprocess . Popen ([ \"mocp\" , \"-G\" ]) elif self . status == \"STOP\" : subprocess . Popen ([ \"mocp\" , \"-p\" ]) poll () Poll content for the text box. Source code in libqtile/widget/moc.py 109 110 111 def poll ( self ): \"\"\"Poll content for the text box.\"\"\" return self . now_playing ()","title":"moc"},{"location":"reference/libqtile/widget/moc/#libqtile.widget.moc.Moc","text":"Bases: base . ThreadPoolText A simple MOC widget. Show the artist and album of now listening song and allow basic mouse control from the bar: toggle pause (or play if stopped) on left click; skip forward in playlist on scroll up; skip backward in playlist on scroll down. MOC ( http://moc.daper.net ) should be installed. Source code in libqtile/widget/moc.py 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Moc . defaults ) self . status = \"\" self . local = None self . add_callbacks ( { \"Button1\" : self . play , \"Button4\" : partial ( subprocess . Popen , [ \"mocp\" , \"-f\" ]), \"Button5\" : partial ( subprocess . Popen , [ \"mocp\" , \"-r\" ]), } )","title":"Moc"},{"location":"reference/libqtile/widget/moc/#libqtile.widget.moc.Moc.get_info","text":"Return a dictionary with info about the current MOC status. Source code in libqtile/widget/moc.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_info ( self ): \"\"\"Return a dictionary with info about the current MOC status.\"\"\" try : output = self . call_process ([ \"mocp\" , \"-i\" ]) except subprocess . CalledProcessError as err : output = err . output if output . startswith ( \"State\" ): output = output . splitlines () info = { \"State\" : \"\" , \"File\" : \"\" , \"SongTitle\" : \"\" , \"Artist\" : \"\" , \"Album\" : \"\" } for line in output : for data in info : if data in line : info [ data ] = line [ len ( data ) + 2 :] . strip () break return info","title":"get_info()"},{"location":"reference/libqtile/widget/moc/#libqtile.widget.moc.Moc.now_playing","text":"Return a string with the now playing info (Artist - Song Title). Source code in libqtile/widget/moc.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def now_playing ( self ): \"\"\"Return a string with the now playing info (Artist - Song Title).\"\"\" info = self . get_info () now_playing = \"\" if info : status = info [ \"State\" ] if self . status != status : self . status = status if self . status == \"PLAY\" : self . layout . colour = self . play_color else : self . layout . colour = self . noplay_color title = info [ \"SongTitle\" ] artist = info [ \"Artist\" ] if title and artist : now_playing = \"\u266b {0} - {1} \" . format ( artist , title ) elif title : now_playing = \"\u266b {0} \" . format ( title ) else : basename = os . path . basename ( info [ \"File\" ]) filename = os . path . splitext ( basename )[ 0 ] now_playing = \"\u266b {0} \" . format ( filename ) if self . status == \"STOP\" : now_playing = \"\u266b\" return now_playing","title":"now_playing()"},{"location":"reference/libqtile/widget/moc/#libqtile.widget.moc.Moc.play","text":"Play music if stopped, else toggle pause. Source code in libqtile/widget/moc.py 102 103 104 105 106 107 def play ( self ): \"\"\"Play music if stopped, else toggle pause.\"\"\" if self . status in ( \"PLAY\" , \"PAUSE\" ): subprocess . Popen ([ \"mocp\" , \"-G\" ]) elif self . status == \"STOP\" : subprocess . Popen ([ \"mocp\" , \"-p\" ])","title":"play()"},{"location":"reference/libqtile/widget/moc/#libqtile.widget.moc.Moc.poll","text":"Poll content for the text box. Source code in libqtile/widget/moc.py 109 110 111 def poll ( self ): \"\"\"Poll content for the text box.\"\"\" return self . now_playing ()","title":"poll()"},{"location":"reference/libqtile/widget/mpd2widget/","text":"A widget for Music Player Daemon (MPD) based on python-mpd2. This widget exists since python-mpd library is no longer supported. Mpd2 ( ** config ) Bases: base . ThreadPoolText Mpd2 Object. Parameters status_format: format string to display status For a full list of values, see: MPDClient.status() and MPDClient.currentsong() https://musicpd.org/doc/protocol/command_reference.html#command_status https://musicpd.org/doc/protocol/tags.html Default:: '{play_status} {artist}/{title} \\ [{repeat}{random}{single}{consume}{updating_db}]' ``play_status`` is a string from ``play_states`` dict Note that the ``time`` property of the song renamed to ``fulltime`` to prevent conflicts with status information during formating. idle_format: format string to display status when no song is in queue. Default:: '{play_status} {idle_message} \\ [{repeat}{random}{single}{consume}{updating_db}]' idle_message: text to display instead of song information when MPD is idle. (i.e. no song in queue) Default:: \"MPD IDLE\" prepare_status: dict of functions to replace values in status with custom characters. ``f(status, key, space_element) => str`` New functionality allows use of a dictionary of plain strings. Default:: status_dict = { 'repeat': 'r', 'random': 'z', 'single': '1', 'consume': 'c', 'updating_db': 'U' } format_fns: A dict of functions to format the various elements. 'Tag': f(str) => str Default:: { 'all': lambda s: cgi.escape(s) } N.B. if 'all' is present, it is processed on every element of song_info before any other formatting is done. mouse_buttons: A dict of mouse button numbers to actions Widget requirements: python-mpd2_. .. _python-mpd2: https://pypi.org/project/python-mpd2/ Source code in libqtile/widget/mpd2widget.py 175 176 177 178 179 180 181 def __init__ ( self , ** config ): \"\"\"Constructor.\"\"\" super () . __init__ ( \"\" , ** config ) self . add_defaults ( Mpd2 . defaults ) if self . color_progress : self . color_progress = utils . hex ( self . color_progress ) button_press ( x , y , button ) handle click event on widget. Source code in libqtile/widget/mpd2widget.py 223 224 225 226 227 228 229 230 231 232 def button_press ( self , x , y , button ): \"\"\"handle click event on widget.\"\"\" base . ThreadPoolText . button_press ( self , x , y , button ) m_name = self . mouse_buttons [ button ] if self . connected : if hasattr ( self , m_name ): self . __try_call ( m_name ) elif hasattr ( self . client , m_name ): self . __try_call ( m_name , self . client ) connected () property Attempt connection to mpd server. Source code in libqtile/widget/mpd2widget.py 189 190 191 192 193 194 195 196 197 198 199 200 201 @property def connected ( self ): \"\"\"Attempt connection to mpd server.\"\"\" try : self . client . ping () # pylint: disable=E1101 except ( socket_error , ConnectionError ): try : self . client . connect ( self . host , self . port ) if self . password : self . client . password ( self . password ) # pylint: disable=E1101 except ( socket_error , ConnectionError , CommandError ): return False return True finalize () finalize. Source code in libqtile/widget/mpd2widget.py 340 341 342 343 344 345 346 347 348 def finalize ( self ): \"\"\"finalize.\"\"\" super () . finalize () try : self . client . close () # pylint: disable=E1101 self . client . disconnect () except ConnectionError : pass formatter ( status , current_song ) format song info. Source code in libqtile/widget/mpd2widget.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 def formatter ( self , status , current_song ): \"\"\"format song info.\"\"\" default = \"Undefined\" song_info = defaultdict ( lambda : default ) song_info [ \"play_status\" ] = self . play_states [ status [ \"state\" ]] if status [ \"state\" ] == \"stop\" and current_song == {}: song_info [ \"idle_message\" ] = self . idle_message fmt = self . idle_format else : fmt = self . status_format for k in current_song : song_info [ k ] = current_song [ k ] song_info [ \"fulltime\" ] = song_info [ \"time\" ] del song_info [ \"time\" ] song_info . update ( status ) if song_info [ \"updating_db\" ] == default : song_info [ \"updating_db\" ] = \"0\" if not callable ( self . prepare_status [ \"repeat\" ]): for k in self . prepare_status : if k in status and status [ k ] != \"0\" : # Much more direct. song_info [ k ] = self . prepare_status [ k ] else : song_info [ k ] = self . space else : self . prepare_formatting ( song_info ) # 'remaining' isn't actually in the information provided by mpd # so we construct it from 'fulltime' and 'elapsed'. # 'elapsed' is always less than or equal to 'fulltime', if it exists. # Remaining should default to '00:00' if either or both are missing. # These values are also used for coloring text by progress, if wanted. if \"remaining\" in self . status_format or self . color_progress : total = float ( song_info [ \"fulltime\" ]) if song_info [ \"fulltime\" ] != default else 0.0 elapsed = float ( song_info [ \"elapsed\" ]) if song_info [ \"elapsed\" ] != default else 0.0 song_info [ \"remaining\" ] = \" {:.2f} \" . format ( float ( total - elapsed )) if \"song\" in self . status_format and song_info [ \"song\" ] != default : song_info [ \"currentsong\" ] = str ( int ( song_info [ \"song\" ]) + 1 ) # mpd serializes tags containing commas as lists. for key in song_info : if isinstance ( song_info [ key ], list ): song_info [ key ] = \", \" . join ( song_info [ key ]) # Now we apply the user formatting to selected elements in song_info. # if 'all' is defined, it is applied first. # the reason for this is that, if the format functions do pango markup. # we don't want to do anything that would mess it up, e.g. `escape`ing. if \"all\" in self . format_fns : for key in song_info : song_info [ key ] = self . format_fns [ \"all\" ]( song_info [ key ]) for fmt_fn in self . format_fns : if fmt_fn in song_info and fmt_fn != \"all\" : song_info [ fmt_fn ] = self . format_fns [ fmt_fn ]( song_info [ fmt_fn ]) # fmt = self.status_format if not isinstance ( fmt , str ): fmt = str ( fmt ) formatted = fmt . format_map ( song_info ) if self . color_progress and status [ \"state\" ] != \"stop\" : try : progress = int ( len ( formatted ) * elapsed / total ) formatted = '<span color=\" {0} \"> {1} </span> {2} ' . format ( self . color_progress , formatted [: progress ], formatted [ progress :], ) except ( ZeroDivisionError , ValueError ): pass return formatted poll () Called by qtile manager. poll the mpd server and update widget. Source code in libqtile/widget/mpd2widget.py 203 204 205 206 207 208 209 210 211 212 def poll ( self ): \"\"\" Called by qtile manager. poll the mpd server and update widget. \"\"\" if self . connected : return self . update_status () else : return self . no_connection prepare_formatting ( status ) old way of preparing status formatting. Source code in libqtile/widget/mpd2widget.py 335 336 337 338 def prepare_formatting ( self , status ): \"\"\"old way of preparing status formatting.\"\"\" for key in self . prepare_status : self . prepare_status [ key ]( status , key , self . space ) toggle () toggle play/pause. Source code in libqtile/widget/mpd2widget.py 247 248 249 250 251 252 253 254 255 def toggle ( self ): \"\"\"toggle play/pause.\"\"\" status = self . client . status () # pylint: disable=E1101 play_status = status [ \"state\" ] if play_status == \"play\" : self . client . pause () # pylint: disable=E1101 else : self . client . play () # pylint: disable=E1101 update_status () get updated info from mpd server and call format. Source code in libqtile/widget/mpd2widget.py 214 215 216 217 218 219 220 221 def update_status ( self ): \"\"\"get updated info from mpd server and call format.\"\"\" self . client . command_list_ok_begin () self . client . status () # pylint: disable=E1101 self . client . currentsong () # pylint: disable=E1101 status , current_song = self . client . command_list_end () return self . formatter ( status , current_song ) option ( char ) old status mapping method. Deprecated. Source code in libqtile/widget/mpd2widget.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def option ( char ): \"\"\" old status mapping method. Deprecated. \"\"\" def _convert ( elements , key , space ): if key in elements and elements [ key ] != \"0\" : elements [ key ] = char else : elements [ key ] = space return _convert","title":"mpd2widget"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2","text":"Bases: base . ThreadPoolText Mpd2 Object.","title":"Mpd2"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2--parameters","text":"status_format: format string to display status For a full list of values, see: MPDClient.status() and MPDClient.currentsong() https://musicpd.org/doc/protocol/command_reference.html#command_status https://musicpd.org/doc/protocol/tags.html Default:: '{play_status} {artist}/{title} \\ [{repeat}{random}{single}{consume}{updating_db}]' ``play_status`` is a string from ``play_states`` dict Note that the ``time`` property of the song renamed to ``fulltime`` to prevent conflicts with status information during formating. idle_format: format string to display status when no song is in queue. Default:: '{play_status} {idle_message} \\ [{repeat}{random}{single}{consume}{updating_db}]' idle_message: text to display instead of song information when MPD is idle. (i.e. no song in queue) Default:: \"MPD IDLE\" prepare_status: dict of functions to replace values in status with custom characters. ``f(status, key, space_element) => str`` New functionality allows use of a dictionary of plain strings. Default:: status_dict = { 'repeat': 'r', 'random': 'z', 'single': '1', 'consume': 'c', 'updating_db': 'U' } format_fns: A dict of functions to format the various elements. 'Tag': f(str) => str Default:: { 'all': lambda s: cgi.escape(s) } N.B. if 'all' is present, it is processed on every element of song_info before any other formatting is done. mouse_buttons: A dict of mouse button numbers to actions Widget requirements: python-mpd2_. .. _python-mpd2: https://pypi.org/project/python-mpd2/ Source code in libqtile/widget/mpd2widget.py 175 176 177 178 179 180 181 def __init__ ( self , ** config ): \"\"\"Constructor.\"\"\" super () . __init__ ( \"\" , ** config ) self . add_defaults ( Mpd2 . defaults ) if self . color_progress : self . color_progress = utils . hex ( self . color_progress )","title":"Parameters"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.button_press","text":"handle click event on widget. Source code in libqtile/widget/mpd2widget.py 223 224 225 226 227 228 229 230 231 232 def button_press ( self , x , y , button ): \"\"\"handle click event on widget.\"\"\" base . ThreadPoolText . button_press ( self , x , y , button ) m_name = self . mouse_buttons [ button ] if self . connected : if hasattr ( self , m_name ): self . __try_call ( m_name ) elif hasattr ( self . client , m_name ): self . __try_call ( m_name , self . client )","title":"button_press()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.connected","text":"Attempt connection to mpd server. Source code in libqtile/widget/mpd2widget.py 189 190 191 192 193 194 195 196 197 198 199 200 201 @property def connected ( self ): \"\"\"Attempt connection to mpd server.\"\"\" try : self . client . ping () # pylint: disable=E1101 except ( socket_error , ConnectionError ): try : self . client . connect ( self . host , self . port ) if self . password : self . client . password ( self . password ) # pylint: disable=E1101 except ( socket_error , ConnectionError , CommandError ): return False return True","title":"connected()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.finalize","text":"finalize. Source code in libqtile/widget/mpd2widget.py 340 341 342 343 344 345 346 347 348 def finalize ( self ): \"\"\"finalize.\"\"\" super () . finalize () try : self . client . close () # pylint: disable=E1101 self . client . disconnect () except ConnectionError : pass","title":"finalize()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.formatter","text":"format song info. Source code in libqtile/widget/mpd2widget.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 def formatter ( self , status , current_song ): \"\"\"format song info.\"\"\" default = \"Undefined\" song_info = defaultdict ( lambda : default ) song_info [ \"play_status\" ] = self . play_states [ status [ \"state\" ]] if status [ \"state\" ] == \"stop\" and current_song == {}: song_info [ \"idle_message\" ] = self . idle_message fmt = self . idle_format else : fmt = self . status_format for k in current_song : song_info [ k ] = current_song [ k ] song_info [ \"fulltime\" ] = song_info [ \"time\" ] del song_info [ \"time\" ] song_info . update ( status ) if song_info [ \"updating_db\" ] == default : song_info [ \"updating_db\" ] = \"0\" if not callable ( self . prepare_status [ \"repeat\" ]): for k in self . prepare_status : if k in status and status [ k ] != \"0\" : # Much more direct. song_info [ k ] = self . prepare_status [ k ] else : song_info [ k ] = self . space else : self . prepare_formatting ( song_info ) # 'remaining' isn't actually in the information provided by mpd # so we construct it from 'fulltime' and 'elapsed'. # 'elapsed' is always less than or equal to 'fulltime', if it exists. # Remaining should default to '00:00' if either or both are missing. # These values are also used for coloring text by progress, if wanted. if \"remaining\" in self . status_format or self . color_progress : total = float ( song_info [ \"fulltime\" ]) if song_info [ \"fulltime\" ] != default else 0.0 elapsed = float ( song_info [ \"elapsed\" ]) if song_info [ \"elapsed\" ] != default else 0.0 song_info [ \"remaining\" ] = \" {:.2f} \" . format ( float ( total - elapsed )) if \"song\" in self . status_format and song_info [ \"song\" ] != default : song_info [ \"currentsong\" ] = str ( int ( song_info [ \"song\" ]) + 1 ) # mpd serializes tags containing commas as lists. for key in song_info : if isinstance ( song_info [ key ], list ): song_info [ key ] = \", \" . join ( song_info [ key ]) # Now we apply the user formatting to selected elements in song_info. # if 'all' is defined, it is applied first. # the reason for this is that, if the format functions do pango markup. # we don't want to do anything that would mess it up, e.g. `escape`ing. if \"all\" in self . format_fns : for key in song_info : song_info [ key ] = self . format_fns [ \"all\" ]( song_info [ key ]) for fmt_fn in self . format_fns : if fmt_fn in song_info and fmt_fn != \"all\" : song_info [ fmt_fn ] = self . format_fns [ fmt_fn ]( song_info [ fmt_fn ]) # fmt = self.status_format if not isinstance ( fmt , str ): fmt = str ( fmt ) formatted = fmt . format_map ( song_info ) if self . color_progress and status [ \"state\" ] != \"stop\" : try : progress = int ( len ( formatted ) * elapsed / total ) formatted = '<span color=\" {0} \"> {1} </span> {2} ' . format ( self . color_progress , formatted [: progress ], formatted [ progress :], ) except ( ZeroDivisionError , ValueError ): pass return formatted","title":"formatter()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.poll","text":"Called by qtile manager. poll the mpd server and update widget. Source code in libqtile/widget/mpd2widget.py 203 204 205 206 207 208 209 210 211 212 def poll ( self ): \"\"\" Called by qtile manager. poll the mpd server and update widget. \"\"\" if self . connected : return self . update_status () else : return self . no_connection","title":"poll()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.prepare_formatting","text":"old way of preparing status formatting. Source code in libqtile/widget/mpd2widget.py 335 336 337 338 def prepare_formatting ( self , status ): \"\"\"old way of preparing status formatting.\"\"\" for key in self . prepare_status : self . prepare_status [ key ]( status , key , self . space )","title":"prepare_formatting()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.toggle","text":"toggle play/pause. Source code in libqtile/widget/mpd2widget.py 247 248 249 250 251 252 253 254 255 def toggle ( self ): \"\"\"toggle play/pause.\"\"\" status = self . client . status () # pylint: disable=E1101 play_status = status [ \"state\" ] if play_status == \"play\" : self . client . pause () # pylint: disable=E1101 else : self . client . play () # pylint: disable=E1101","title":"toggle()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.Mpd2.update_status","text":"get updated info from mpd server and call format. Source code in libqtile/widget/mpd2widget.py 214 215 216 217 218 219 220 221 def update_status ( self ): \"\"\"get updated info from mpd server and call format.\"\"\" self . client . command_list_ok_begin () self . client . status () # pylint: disable=E1101 self . client . currentsong () # pylint: disable=E1101 status , current_song = self . client . command_list_end () return self . formatter ( status , current_song )","title":"update_status()"},{"location":"reference/libqtile/widget/mpd2widget/#libqtile.widget.mpd2widget.option","text":"old status mapping method. Deprecated. Source code in libqtile/widget/mpd2widget.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def option ( char ): \"\"\" old status mapping method. Deprecated. \"\"\" def _convert ( elements , key , space ): if key in elements and elements [ key ] != \"0\" : elements [ key ] = char else : elements [ key ] = space return _convert","title":"option()"},{"location":"reference/libqtile/widget/mpris2widget/","text":"Mpris2 ( ** config ) Bases: base . _TextBox An MPRIS 2 widget A widget which displays the current track/artist of your favorite MPRIS player. This widget scrolls the text if neccessary and information that is displayed is configurable. Basic mouse controls are also available: button 1 = play/pause, scroll up = next track, scroll down = previous track. Widget requirements: dbus-next_. .. _dbus-next: https://pypi.org/project/dbus-next/ Source code in libqtile/widget/mpris2widget.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( Mpris2 . defaults ) self . is_playing = False self . count = 0 self . displaytext = \"\" self . track_info = \"\" self . status = \" {track} \" self . add_callbacks ( { \"Button1\" : self . play_pause , \"Button4\" : self . next , \"Button5\" : self . previous , } ) paused = \"\" stopped = \"\" if \"stop_pause_text\" in config : logger . warning ( \"The use of 'stop_pause_text' is deprecated. Please use 'paused_text' and 'stopped_text' instead.\" ) if \"paused_text\" not in config : paused = self . stop_pause_text if \"stopped_text\" not in config : stopped = self . stop_pause_text self . prefixes = { \"Playing\" : self . playing_text , \"Paused\" : paused or self . paused_text , \"Stopped\" : stopped or self . stopped_text , } self . _current_player : str | None = None self . player_names : dict [ str , str ] = {} info () What's the current state of the widget? Source code in libqtile/widget/mpris2widget.py 292 293 294 295 296 297 @expose_command () def info ( self ): \"\"\"What's the current state of the widget?\"\"\" d = base . _TextBox . info ( self ) d . update ( dict ( isplaying = self . is_playing , player = self . player )) return d next () Play the next track. Source code in libqtile/widget/mpris2widget.py 277 278 279 280 @expose_command () def next ( self ) -> None : \"\"\"Play the next track.\"\"\" self . _player_cmd ( \"Next\" ) parse_message ( _interface_name , changed_properties , _invalidated_properties ) http://specifications.freedesktop.org/mpris-spec/latest/Track_List_Interface.html#Mapping:Metadata_Map Source code in libqtile/widget/mpris2widget.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def parse_message ( self , _interface_name : str , changed_properties : dict [ str , Any ], _invalidated_properties : list [ str ], ) -> None : \"\"\" http://specifications.freedesktop.org/mpris-spec/latest/Track_List_Interface.html#Mapping:Metadata_Map \"\"\" if not self . configured : return if \"Metadata\" not in changed_properties and \"PlaybackStatus\" not in changed_properties : return self . displaytext = \"\" metadata = changed_properties . get ( \"Metadata\" ) if metadata : self . track_info = self . get_track_info ( metadata . value ) playbackstatus = getattr ( changed_properties . get ( \"PlaybackStatus\" ), \"value\" , None ) if playbackstatus : self . is_playing = playbackstatus == \"Playing\" self . status = self . prefixes . get ( playbackstatus , \" {track} \" ) if not self . track_info : self . track_info = self . no_metadata_text self . displaytext = self . status . format ( track = self . track_info ) if self . text != self . displaytext : self . update ( self . displaytext ) play_pause () Toggle the playback status. Source code in libqtile/widget/mpris2widget.py 272 273 274 275 @expose_command () def play_pause ( self ) -> None : \"\"\"Toggle the playback status.\"\"\" self . _player_cmd ( \"PlayPause\" ) previous () Play the previous track. Source code in libqtile/widget/mpris2widget.py 282 283 284 285 @expose_command () def previous ( self ) -> None : \"\"\"Play the previous track.\"\"\" self . _player_cmd ( \"Previous\" ) stop () Stop playback. Source code in libqtile/widget/mpris2widget.py 287 288 289 290 @expose_command () def stop ( self ) -> None : \"\"\"Stop playback.\"\"\" self . _player_cmd ( \"Stop\" )","title":"mpris2widget"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2","text":"Bases: base . _TextBox An MPRIS 2 widget A widget which displays the current track/artist of your favorite MPRIS player. This widget scrolls the text if neccessary and information that is displayed is configurable. Basic mouse controls are also available: button 1 = play/pause, scroll up = next track, scroll down = previous track. Widget requirements: dbus-next_. .. _dbus-next: https://pypi.org/project/dbus-next/ Source code in libqtile/widget/mpris2widget.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( Mpris2 . defaults ) self . is_playing = False self . count = 0 self . displaytext = \"\" self . track_info = \"\" self . status = \" {track} \" self . add_callbacks ( { \"Button1\" : self . play_pause , \"Button4\" : self . next , \"Button5\" : self . previous , } ) paused = \"\" stopped = \"\" if \"stop_pause_text\" in config : logger . warning ( \"The use of 'stop_pause_text' is deprecated. Please use 'paused_text' and 'stopped_text' instead.\" ) if \"paused_text\" not in config : paused = self . stop_pause_text if \"stopped_text\" not in config : stopped = self . stop_pause_text self . prefixes = { \"Playing\" : self . playing_text , \"Paused\" : paused or self . paused_text , \"Stopped\" : stopped or self . stopped_text , } self . _current_player : str | None = None self . player_names : dict [ str , str ] = {}","title":"Mpris2"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2.info","text":"What's the current state of the widget? Source code in libqtile/widget/mpris2widget.py 292 293 294 295 296 297 @expose_command () def info ( self ): \"\"\"What's the current state of the widget?\"\"\" d = base . _TextBox . info ( self ) d . update ( dict ( isplaying = self . is_playing , player = self . player )) return d","title":"info()"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2.next","text":"Play the next track. Source code in libqtile/widget/mpris2widget.py 277 278 279 280 @expose_command () def next ( self ) -> None : \"\"\"Play the next track.\"\"\" self . _player_cmd ( \"Next\" )","title":"next()"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2.parse_message","text":"http://specifications.freedesktop.org/mpris-spec/latest/Track_List_Interface.html#Mapping:Metadata_Map Source code in libqtile/widget/mpris2widget.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def parse_message ( self , _interface_name : str , changed_properties : dict [ str , Any ], _invalidated_properties : list [ str ], ) -> None : \"\"\" http://specifications.freedesktop.org/mpris-spec/latest/Track_List_Interface.html#Mapping:Metadata_Map \"\"\" if not self . configured : return if \"Metadata\" not in changed_properties and \"PlaybackStatus\" not in changed_properties : return self . displaytext = \"\" metadata = changed_properties . get ( \"Metadata\" ) if metadata : self . track_info = self . get_track_info ( metadata . value ) playbackstatus = getattr ( changed_properties . get ( \"PlaybackStatus\" ), \"value\" , None ) if playbackstatus : self . is_playing = playbackstatus == \"Playing\" self . status = self . prefixes . get ( playbackstatus , \" {track} \" ) if not self . track_info : self . track_info = self . no_metadata_text self . displaytext = self . status . format ( track = self . track_info ) if self . text != self . displaytext : self . update ( self . displaytext )","title":"parse_message()"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2.play_pause","text":"Toggle the playback status. Source code in libqtile/widget/mpris2widget.py 272 273 274 275 @expose_command () def play_pause ( self ) -> None : \"\"\"Toggle the playback status.\"\"\" self . _player_cmd ( \"PlayPause\" )","title":"play_pause()"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2.previous","text":"Play the previous track. Source code in libqtile/widget/mpris2widget.py 282 283 284 285 @expose_command () def previous ( self ) -> None : \"\"\"Play the previous track.\"\"\" self . _player_cmd ( \"Previous\" )","title":"previous()"},{"location":"reference/libqtile/widget/mpris2widget/#libqtile.widget.mpris2widget.Mpris2.stop","text":"Stop playback. Source code in libqtile/widget/mpris2widget.py 287 288 289 290 @expose_command () def stop ( self ) -> None : \"\"\"Stop playback.\"\"\" self . _player_cmd ( \"Stop\" )","title":"stop()"},{"location":"reference/libqtile/widget/net/","text":"Net ( ** config ) Bases: base . ThreadPoolText Displays interface down and up speed Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/net.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Net . defaults ) self . factor = 1000.0 self . allowed_prefixes = [ \"\" , \"k\" , \"M\" , \"G\" , \"T\" , \"P\" , \"E\" , \"Z\" , \"Y\" ] if self . use_bits : self . base_unit = \"b\" self . byte_multiplier = 8 else : self . base_unit = \"B\" self . byte_multiplier = 1 self . units = list ( map ( lambda p : p + self . base_unit , self . allowed_prefixes )) if not isinstance ( self . interface , list ): if self . interface is None : self . interface = [ \"all\" ] elif isinstance ( self . interface , str ): self . interface = [ self . interface ] else : raise AttributeError ( \"Invalid Argument passed: %s \\n Allowed Types: list, str, None\" % self . interface ) self . stats = self . get_stats () convert_b ( num_bytes ) Converts the number of bytes to the correct unit Source code in libqtile/widget/net.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def convert_b ( self , num_bytes : float ) -> tuple [ float , str ]: \"\"\"Converts the number of bytes to the correct unit\"\"\" num_bytes *= self . byte_multiplier if self . prefix is None : if num_bytes > 0 : power = int ( log ( num_bytes ) / log ( self . factor )) power = min ( power , len ( self . units ) - 1 ) else : power = 0 else : power = self . allowed_prefixes . index ( self . prefix ) converted_bytes = num_bytes / self . factor ** power unit = self . units [ power ] return converted_bytes , unit","title":"net"},{"location":"reference/libqtile/widget/net/#libqtile.widget.net.Net","text":"Bases: base . ThreadPoolText Displays interface down and up speed Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/net.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Net . defaults ) self . factor = 1000.0 self . allowed_prefixes = [ \"\" , \"k\" , \"M\" , \"G\" , \"T\" , \"P\" , \"E\" , \"Z\" , \"Y\" ] if self . use_bits : self . base_unit = \"b\" self . byte_multiplier = 8 else : self . base_unit = \"B\" self . byte_multiplier = 1 self . units = list ( map ( lambda p : p + self . base_unit , self . allowed_prefixes )) if not isinstance ( self . interface , list ): if self . interface is None : self . interface = [ \"all\" ] elif isinstance ( self . interface , str ): self . interface = [ self . interface ] else : raise AttributeError ( \"Invalid Argument passed: %s \\n Allowed Types: list, str, None\" % self . interface ) self . stats = self . get_stats ()","title":"Net"},{"location":"reference/libqtile/widget/net/#libqtile.widget.net.Net.convert_b","text":"Converts the number of bytes to the correct unit Source code in libqtile/widget/net.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def convert_b ( self , num_bytes : float ) -> tuple [ float , str ]: \"\"\"Converts the number of bytes to the correct unit\"\"\" num_bytes *= self . byte_multiplier if self . prefix is None : if num_bytes > 0 : power = int ( log ( num_bytes ) / log ( self . factor )) power = min ( power , len ( self . units ) - 1 ) else : power = 0 else : power = self . allowed_prefixes . index ( self . prefix ) converted_bytes = num_bytes / self . factor ** power unit = self . units [ power ] return converted_bytes , unit","title":"convert_b()"},{"location":"reference/libqtile/widget/notify/","text":"Notify ( width = bar . CALCULATED , ** config ) Bases: base . _TextBox A notify widget This widget can handle actions provided by notification clients. However, only the default action is supported, so if a client provides multiple actions then only the default (first) action can be invoked. Some programs will provide their own notification windows if the notification server does not support actions, so if you want your notifications to handle more than one action then specify False for the action option to disable all action handling. Unfortunately we cannot specify the capability for exactly one action. Source code in libqtile/widget/notify.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( Notify . defaults ) self . current_id = 0 default_callbacks = { \"Button1\" : self . clear , \"Button4\" : self . prev , \"Button5\" : self . next , } if self . action : default_callbacks [ \"Button3\" ] = self . _invoke else : self . capabilities = Notify . capabilities . difference ({ \"actions\" }) self . add_callbacks ( default_callbacks ) clear () Clear the notification Source code in libqtile/widget/notify.py 184 185 186 187 @expose_command () def clear ( self ): \"\"\"Clear the notification\"\"\" self . _clear () invoke () Invoke the notification's default action Source code in libqtile/widget/notify.py 197 198 199 200 201 @expose_command () def invoke ( self ): \"\"\"Invoke the notification's default action\"\"\" if self . action : self . _invoke () prev () Show previous notification. Source code in libqtile/widget/notify.py 160 161 162 163 164 165 @expose_command () def prev ( self ): \"\"\"Show previous notification.\"\"\" if self . current_id > 0 : self . current_id -= 1 self . display () toggle () Toggle showing/clearing the notification Source code in libqtile/widget/notify.py 189 190 191 192 193 194 195 @expose_command () def toggle ( self ): \"\"\"Toggle showing/clearing the notification\"\"\" if self . text == \"\" : self . display () else : self . _clear ()","title":"notify"},{"location":"reference/libqtile/widget/notify/#libqtile.widget.notify.Notify","text":"Bases: base . _TextBox A notify widget This widget can handle actions provided by notification clients. However, only the default action is supported, so if a client provides multiple actions then only the default (first) action can be invoked. Some programs will provide their own notification windows if the notification server does not support actions, so if you want your notifications to handle more than one action then specify False for the action option to disable all action handling. Unfortunately we cannot specify the capability for exactly one action. Source code in libqtile/widget/notify.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , \"\" , width , ** config ) self . add_defaults ( Notify . defaults ) self . current_id = 0 default_callbacks = { \"Button1\" : self . clear , \"Button4\" : self . prev , \"Button5\" : self . next , } if self . action : default_callbacks [ \"Button3\" ] = self . _invoke else : self . capabilities = Notify . capabilities . difference ({ \"actions\" }) self . add_callbacks ( default_callbacks )","title":"Notify"},{"location":"reference/libqtile/widget/notify/#libqtile.widget.notify.Notify.clear","text":"Clear the notification Source code in libqtile/widget/notify.py 184 185 186 187 @expose_command () def clear ( self ): \"\"\"Clear the notification\"\"\" self . _clear ()","title":"clear()"},{"location":"reference/libqtile/widget/notify/#libqtile.widget.notify.Notify.invoke","text":"Invoke the notification's default action Source code in libqtile/widget/notify.py 197 198 199 200 201 @expose_command () def invoke ( self ): \"\"\"Invoke the notification's default action\"\"\" if self . action : self . _invoke ()","title":"invoke()"},{"location":"reference/libqtile/widget/notify/#libqtile.widget.notify.Notify.prev","text":"Show previous notification. Source code in libqtile/widget/notify.py 160 161 162 163 164 165 @expose_command () def prev ( self ): \"\"\"Show previous notification.\"\"\" if self . current_id > 0 : self . current_id -= 1 self . display ()","title":"prev()"},{"location":"reference/libqtile/widget/notify/#libqtile.widget.notify.Notify.toggle","text":"Toggle showing/clearing the notification Source code in libqtile/widget/notify.py 189 190 191 192 193 194 195 @expose_command () def toggle ( self ): \"\"\"Toggle showing/clearing the notification\"\"\" if self . text == \"\" : self . display () else : self . _clear ()","title":"toggle()"},{"location":"reference/libqtile/widget/nvidia_sensors/","text":"NvidiaSensors ( ** config ) Bases: base . ThreadPoolText Displays temperature, fan speed and performance level Nvidia GPU. Source code in libqtile/widget/nvidia_sensors.py 43 44 45 46 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( NvidiaSensors . defaults ) self . foreground_normal = self . foreground","title":"nvidia_sensors"},{"location":"reference/libqtile/widget/nvidia_sensors/#libqtile.widget.nvidia_sensors.NvidiaSensors","text":"Bases: base . ThreadPoolText Displays temperature, fan speed and performance level Nvidia GPU. Source code in libqtile/widget/nvidia_sensors.py 43 44 45 46 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( NvidiaSensors . defaults ) self . foreground_normal = self . foreground","title":"NvidiaSensors"},{"location":"reference/libqtile/widget/open_weather/","text":"OpenWeather ( ** config ) Bases: GenPollUrl A weather widget, data provided by the OpenWeather API. Some format options: - location_city - location_cityid - location_country - location_lat - location_long - weather - weather_details - units_temperature - units_wind_speed - isotime - humidity - pressure - sunrise - sunset - temp - visibility - wind_speed - wind_deg - wind_direction - main_feels_like - main_temp_min - main_temp_max - clouds_all - icon Icon support is available but you will need a suitable font installed. A default icon mapping is provided ( OpenWeather.symbols ) but changes can be made by setting weather_symbols . Available icon codes can be viewed here: https://openweathermap.org/weather-conditions#Icon-list Source code in libqtile/widget/open_weather.py 260 261 262 263 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( OpenWeather . defaults ) self . symbols . update ( self . weather_symbols )","title":"open_weather"},{"location":"reference/libqtile/widget/open_weather/#libqtile.widget.open_weather.OpenWeather","text":"Bases: GenPollUrl A weather widget, data provided by the OpenWeather API. Some format options: - location_city - location_cityid - location_country - location_lat - location_long - weather - weather_details - units_temperature - units_wind_speed - isotime - humidity - pressure - sunrise - sunset - temp - visibility - wind_speed - wind_deg - wind_direction - main_feels_like - main_temp_min - main_temp_max - clouds_all - icon Icon support is available but you will need a suitable font installed. A default icon mapping is provided ( OpenWeather.symbols ) but changes can be made by setting weather_symbols . Available icon codes can be viewed here: https://openweathermap.org/weather-conditions#Icon-list Source code in libqtile/widget/open_weather.py 260 261 262 263 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( OpenWeather . defaults ) self . symbols . update ( self . weather_symbols )","title":"OpenWeather"},{"location":"reference/libqtile/widget/pomodoro/","text":"Pomodoro ( ** config ) Bases: base . ThreadPoolText Pomodoro technique widget Source code in libqtile/widget/pomodoro.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Pomodoro . defaults ) self . prefix = { \"inactive\" : self . prefix_inactive , \"active\" : self . prefix_active , \"break\" : self . prefix_break , \"long_break\" : self . prefix_long_break , \"paused\" : self . prefix_paused , } self . add_callbacks ( { \"Button1\" : self . toggle_break , \"Button3\" : self . toggle_active , } )","title":"pomodoro"},{"location":"reference/libqtile/widget/pomodoro/#libqtile.widget.pomodoro.Pomodoro","text":"Bases: base . ThreadPoolText Pomodoro technique widget Source code in libqtile/widget/pomodoro.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , ** config ): base . ThreadPoolText . __init__ ( self , \"\" , ** config ) self . add_defaults ( Pomodoro . defaults ) self . prefix = { \"inactive\" : self . prefix_inactive , \"active\" : self . prefix_active , \"break\" : self . prefix_break , \"long_break\" : self . prefix_long_break , \"paused\" : self . prefix_paused , } self . add_callbacks ( { \"Button1\" : self . toggle_break , \"Button3\" : self . toggle_active , } )","title":"Pomodoro"},{"location":"reference/libqtile/widget/prompt/","text":"AbstractCompleter ( qtile ) Source code in libqtile/widget/prompt.py 52 53 54 @abc . abstractmethod def __init__ ( self , qtile : CommandObject ) -> None : pass complete ( txt ) abstractmethod Perform the requested completion on the given text Source code in libqtile/widget/prompt.py 64 65 66 67 @abc . abstractmethod def complete ( self , txt : str ) -> str : \"\"\"Perform the requested completion on the given text\"\"\" pass # pragma: no cover CommandCompleter ( qtile , _testing = False ) Parameters _testing : disables reloading of the lookup table to make testing possible. Source code in libqtile/widget/prompt.py 263 264 265 266 267 def __init__ ( self , qtile , _testing = False ): self . lookup = None # type: list[tuple[str, str]] | None self . offset = - 1 self . thisfinal = None # type: str | None self . _testing = _testing actual () Returns the current actual value Source code in libqtile/widget/prompt.py 269 270 271 def actual ( self ) -> str | None : \"\"\"Returns the current actual value\"\"\" return self . thisfinal complete ( txt ) Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" if self . lookup is None : # Lookup is a set of (display value, actual value) tuples. self . lookup = [] if txt and txt [ 0 ] in \"~/\" : path = os . path . expanduser ( txt ) if os . path . isdir ( path ): files = glob . glob ( os . path . join ( path , \"*\" )) prefix = txt else : files = glob . glob ( path + \"*\" ) prefix = os . path . dirname ( txt ) prefix = prefix . rstrip ( \"/\" ) or \"/\" for f in files : if self . executable ( f ): display = os . path . join ( prefix , os . path . basename ( f )) if os . path . isdir ( f ): display += \"/\" self . lookup . append (( display , f )) else : dirs = os . environ . get ( \"PATH\" , self . DEFAULTPATH ) . split ( \":\" ) for d in dirs : try : d = os . path . expanduser ( d ) for cmd in glob . iglob ( os . path . join ( d , \" %s *\" % txt )): if self . executable ( cmd ): self . lookup . append ( ( os . path . basename ( cmd ), cmd ), ) except OSError : pass self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ] FileCompleter ( qtile , _testing = False ) Bases: AbstractCompleter Source code in libqtile/widget/prompt.py 85 86 87 88 89 90 def __init__ ( self , qtile , _testing = False ) -> None : self . _testing = _testing self . qtile = qtile self . thisfinal = None # type: str | None self . lookup = None # type: list[tuple[str, str]] | None self . reset () complete ( txt ) Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" if self . lookup is None : self . lookup = [] if txt == \"\" or txt [ 0 ] not in \"~/\" : txt = \"~/\" + txt path = os . path . expanduser ( txt ) if os . path . isdir ( path ): files = glob . glob ( os . path . join ( path , \"*\" )) prefix = txt else : files = glob . glob ( path + \"*\" ) prefix = os . path . dirname ( txt ) prefix = prefix . rstrip ( \"/\" ) or \"/\" for f in files : display = os . path . join ( prefix , os . path . basename ( f )) if os . path . isdir ( f ): display += \"/\" self . lookup . append (( display , f )) self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ] GroupCompleter ( qtile ) Bases: AbstractCompleter Source code in libqtile/widget/prompt.py 183 184 185 186 187 def __init__ ( self , qtile : CommandObject ) -> None : self . qtile = qtile self . thisfinal = None # type: str | None self . lookup = None # type: list[tuple[str, str]] | None self . offset = - 1 actual () Returns the current actual value Source code in libqtile/widget/prompt.py 189 190 191 def actual ( self ) -> str | None : \"\"\"Returns the current actual value\"\"\" return self . thisfinal complete ( txt ) Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" txt = txt . lower () if not self . lookup : self . lookup = [] for group in self . qtile . groups_map . keys (): if group . lower () . startswith ( txt ): self . lookup . append (( group , group )) self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ] Prompt ( ** config ) Bases: base . _TextBox A widget that prompts for user input Input should be started using the .start_input() method on this class. Source code in libqtile/widget/prompt.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def __init__ ( self , ** config ) -> None : base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( Prompt . defaults ) self . active = False self . completer = None # type: AbstractCompleter | None # If history record is on, get saved history or create history record if self . record_history : self . history_path = os . path . join ( utils . get_cache_dir (), \"prompt_history\" ) if os . path . exists ( self . history_path ): with open ( self . history_path , \"rb\" ) as f : try : self . history = pickle . load ( f ) if self . ignore_dups_history : self . _dedup_history () except : # noqa: E722 # unfortunately, pickle doesn't wrap its errors, so we # can't detect what's a pickle error and what's not. logger . exception ( \"failed to load prompt history\" ) self . history = { x : deque ( maxlen = self . max_history ) for x in self . completers } # self.history of size does not match. if len ( self . history ) != len ( self . completers ): self . history = { x : deque ( maxlen = self . max_history ) for x in self . completers } if self . max_history != self . history [ list ( self . history )[ 0 ]] . maxlen : self . history = { x : deque ( self . history [ x ], self . max_history ) for x in self . completers } else : self . history = { x : deque ( maxlen = self . max_history ) for x in self . completers } exec_general ( prompt , object_name , cmd_name , selector = None , completer = None ) Execute a cmd of any object. For example layout, group, window, widget , etc with a string that is obtained from start_input. Parameters prompt : Text displayed at the prompt. object_name : Name of a object in Qtile. This string has to be 'layout', 'widget', 'bar', 'window' or 'screen'. cmd_name : Execution command of selected object using object_name and selector. selector : This value select a specific object within a object list that is obtained by object_name. If this value is None, current object is selected. e.g. current layout, current window and current screen. completer: Completer to use. config example: Key([alt, 'shift'], 'a', lazy.widget['prompt'].exec_general( 'section(add)', 'layout', 'add_section')) Source code in libqtile/widget/prompt.py 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 @expose_command () def exec_general ( self , prompt , object_name , cmd_name , selector = None , completer = None ): \"\"\" Execute a cmd of any object. For example layout, group, window, widget , etc with a string that is obtained from start_input. Parameters ========== prompt : Text displayed at the prompt. object_name : Name of a object in Qtile. This string has to be 'layout', 'widget', 'bar', 'window' or 'screen'. cmd_name : Execution command of selected object using object_name and selector. selector : This value select a specific object within a object list that is obtained by object_name. If this value is None, current object is selected. e.g. current layout, current window and current screen. completer: Completer to use. config example: Key([alt, 'shift'], 'a', lazy.widget['prompt'].exec_general( 'section(add)', 'layout', 'add_section')) \"\"\" try : obj = self . qtile . select ([( object_name , selector )]) except SelectError : logger . warning ( \"cannot select a object\" ) return cmd = obj . command ( cmd_name ) if not cmd : logger . warning ( \"command not found\" ) return def f ( args ): if args : cmd ( args ) self . start_input ( prompt , f , completer ) info () Returns a dictionary of info for this object Source code in libqtile/widget/prompt.py 681 682 683 684 685 686 687 688 689 @expose_command () def info ( self ): \"\"\"Returns a dictionary of info for this object\"\"\" return dict ( name = self . name , width = self . width , text = self . text , active = self . active , ) process_key_press ( keysym ) Key press handler for the minibuffer. Currently only supports ASCII characters. Source code in libqtile/widget/prompt.py 665 666 667 668 669 670 671 672 673 674 675 def process_key_press ( self , keysym : int ): \"\"\"Key press handler for the minibuffer. Currently only supports ASCII characters. \"\"\" handle_key = self . _get_keyhandler ( keysym ) if handle_key : handle_key () del self . key self . _update () start_input ( prompt , callback , complete = None , strict_completer = False , allow_empty_input = False ) Run the prompt Displays a prompt and starts to take one line of keyboard input from the user. When done, calls the callback with the input string as argument. If history record is enabled, also allows to browse between previous commands with \u2191 and \u2193, and execute them (untouched or modified). When history is exhausted, fires an alert. It tries to mimic, in some way, the shell behavior. Parameters complete : Tab-completion. Can be None, \"cmd\", \"file\", \"group\", \"qshell\" or \"window\". prompt : text displayed at the prompt, e.g. \"spawn: \" callback : function to call with returned value. complete : completer to use. strict_completer : When True the return value wil be the exact completer result where available. allow_empty_input : When True, an empty value will still call the callback function Source code in libqtile/widget/prompt.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def start_input ( self , prompt , callback , complete = None , strict_completer = False , allow_empty_input = False ) -> None : \"\"\"Run the prompt Displays a prompt and starts to take one line of keyboard input from the user. When done, calls the callback with the input string as argument. If history record is enabled, also allows to browse between previous commands with \u2191 and \u2193, and execute them (untouched or modified). When history is exhausted, fires an alert. It tries to mimic, in some way, the shell behavior. Parameters ========== complete : Tab-completion. Can be None, \"cmd\", \"file\", \"group\", \"qshell\" or \"window\". prompt : text displayed at the prompt, e.g. \"spawn: \" callback : function to call with returned value. complete : completer to use. strict_completer : When True the return value wil be the exact completer result where available. allow_empty_input : When True, an empty value will still call the callback function \"\"\" if self . cursor and self . cursorblink and not self . active : self . timeout_add ( self . cursorblink , self . _blink ) self . display = self . prompt . format ( prompt = prompt ) self . display = pangocffi . markup_escape_text ( self . display ) self . active = True self . user_input = \"\" self . archived_input = \"\" self . show_cursor = self . cursor self . cursor_position = 0 self . callback = callback self . completer = self . completers [ complete ]( self . qtile ) self . strict_completer = strict_completer self . allow_empty_input = allow_empty_input self . _update () self . bar . widget_grab_keyboard ( self ) if self . record_history : self . completer_history = self . history [ complete ] self . position = len ( self . completer_history ) WindowCompleter ( qtile ) Bases: AbstractCompleter Source code in libqtile/widget/prompt.py 219 220 221 222 223 def __init__ ( self , qtile : CommandObject ) -> None : self . qtile = qtile self . thisfinal = None # type: str | None self . lookup = None # type: list[tuple[str, str]] | None self . offset = - 1 actual () Returns the current actual value Source code in libqtile/widget/prompt.py 225 226 227 def actual ( self ) -> str | None : \"\"\"Returns the current actual value\"\"\" return self . thisfinal complete ( txt ) Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" if self . lookup is None : self . lookup = [] for wid , window in self . qtile . windows_map . items (): if window . group and window . name . lower () . startswith ( txt ): self . lookup . append (( window . name , wid )) self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ]","title":"prompt"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.AbstractCompleter","text":"Source code in libqtile/widget/prompt.py 52 53 54 @abc . abstractmethod def __init__ ( self , qtile : CommandObject ) -> None : pass","title":"AbstractCompleter"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.AbstractCompleter.complete","text":"Perform the requested completion on the given text Source code in libqtile/widget/prompt.py 64 65 66 67 @abc . abstractmethod def complete ( self , txt : str ) -> str : \"\"\"Perform the requested completion on the given text\"\"\" pass # pragma: no cover","title":"complete()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.CommandCompleter","text":"","title":"CommandCompleter"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.CommandCompleter--parameters","text":"_testing : disables reloading of the lookup table to make testing possible. Source code in libqtile/widget/prompt.py 263 264 265 266 267 def __init__ ( self , qtile , _testing = False ): self . lookup = None # type: list[tuple[str, str]] | None self . offset = - 1 self . thisfinal = None # type: str | None self . _testing = _testing","title":"Parameters"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.CommandCompleter.actual","text":"Returns the current actual value Source code in libqtile/widget/prompt.py 269 270 271 def actual ( self ) -> str | None : \"\"\"Returns the current actual value\"\"\" return self . thisfinal","title":"actual()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.CommandCompleter.complete","text":"Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" if self . lookup is None : # Lookup is a set of (display value, actual value) tuples. self . lookup = [] if txt and txt [ 0 ] in \"~/\" : path = os . path . expanduser ( txt ) if os . path . isdir ( path ): files = glob . glob ( os . path . join ( path , \"*\" )) prefix = txt else : files = glob . glob ( path + \"*\" ) prefix = os . path . dirname ( txt ) prefix = prefix . rstrip ( \"/\" ) or \"/\" for f in files : if self . executable ( f ): display = os . path . join ( prefix , os . path . basename ( f )) if os . path . isdir ( f ): display += \"/\" self . lookup . append (( display , f )) else : dirs = os . environ . get ( \"PATH\" , self . DEFAULTPATH ) . split ( \":\" ) for d in dirs : try : d = os . path . expanduser ( d ) for cmd in glob . iglob ( os . path . join ( d , \" %s *\" % txt )): if self . executable ( cmd ): self . lookup . append ( ( os . path . basename ( cmd ), cmd ), ) except OSError : pass self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ]","title":"complete()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.FileCompleter","text":"Bases: AbstractCompleter Source code in libqtile/widget/prompt.py 85 86 87 88 89 90 def __init__ ( self , qtile , _testing = False ) -> None : self . _testing = _testing self . qtile = qtile self . thisfinal = None # type: str | None self . lookup = None # type: list[tuple[str, str]] | None self . reset ()","title":"FileCompleter"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.FileCompleter.complete","text":"Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" if self . lookup is None : self . lookup = [] if txt == \"\" or txt [ 0 ] not in \"~/\" : txt = \"~/\" + txt path = os . path . expanduser ( txt ) if os . path . isdir ( path ): files = glob . glob ( os . path . join ( path , \"*\" )) prefix = txt else : files = glob . glob ( path + \"*\" ) prefix = os . path . dirname ( txt ) prefix = prefix . rstrip ( \"/\" ) or \"/\" for f in files : display = os . path . join ( prefix , os . path . basename ( f )) if os . path . isdir ( f ): display += \"/\" self . lookup . append (( display , f )) self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ]","title":"complete()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.GroupCompleter","text":"Bases: AbstractCompleter Source code in libqtile/widget/prompt.py 183 184 185 186 187 def __init__ ( self , qtile : CommandObject ) -> None : self . qtile = qtile self . thisfinal = None # type: str | None self . lookup = None # type: list[tuple[str, str]] | None self . offset = - 1","title":"GroupCompleter"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.GroupCompleter.actual","text":"Returns the current actual value Source code in libqtile/widget/prompt.py 189 190 191 def actual ( self ) -> str | None : \"\"\"Returns the current actual value\"\"\" return self . thisfinal","title":"actual()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.GroupCompleter.complete","text":"Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" txt = txt . lower () if not self . lookup : self . lookup = [] for group in self . qtile . groups_map . keys (): if group . lower () . startswith ( txt ): self . lookup . append (( group , group )) self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ]","title":"complete()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt","text":"Bases: base . _TextBox A widget that prompts for user input Input should be started using the .start_input() method on this class. Source code in libqtile/widget/prompt.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def __init__ ( self , ** config ) -> None : base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( Prompt . defaults ) self . active = False self . completer = None # type: AbstractCompleter | None # If history record is on, get saved history or create history record if self . record_history : self . history_path = os . path . join ( utils . get_cache_dir (), \"prompt_history\" ) if os . path . exists ( self . history_path ): with open ( self . history_path , \"rb\" ) as f : try : self . history = pickle . load ( f ) if self . ignore_dups_history : self . _dedup_history () except : # noqa: E722 # unfortunately, pickle doesn't wrap its errors, so we # can't detect what's a pickle error and what's not. logger . exception ( \"failed to load prompt history\" ) self . history = { x : deque ( maxlen = self . max_history ) for x in self . completers } # self.history of size does not match. if len ( self . history ) != len ( self . completers ): self . history = { x : deque ( maxlen = self . max_history ) for x in self . completers } if self . max_history != self . history [ list ( self . history )[ 0 ]] . maxlen : self . history = { x : deque ( self . history [ x ], self . max_history ) for x in self . completers } else : self . history = { x : deque ( maxlen = self . max_history ) for x in self . completers }","title":"Prompt"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt.exec_general","text":"Execute a cmd of any object. For example layout, group, window, widget , etc with a string that is obtained from start_input.","title":"exec_general()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt.exec_general--parameters","text":"prompt : Text displayed at the prompt. object_name : Name of a object in Qtile. This string has to be 'layout', 'widget', 'bar', 'window' or 'screen'. cmd_name : Execution command of selected object using object_name and selector. selector : This value select a specific object within a object list that is obtained by object_name. If this value is None, current object is selected. e.g. current layout, current window and current screen. completer: Completer to use. config example: Key([alt, 'shift'], 'a', lazy.widget['prompt'].exec_general( 'section(add)', 'layout', 'add_section')) Source code in libqtile/widget/prompt.py 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 @expose_command () def exec_general ( self , prompt , object_name , cmd_name , selector = None , completer = None ): \"\"\" Execute a cmd of any object. For example layout, group, window, widget , etc with a string that is obtained from start_input. Parameters ========== prompt : Text displayed at the prompt. object_name : Name of a object in Qtile. This string has to be 'layout', 'widget', 'bar', 'window' or 'screen'. cmd_name : Execution command of selected object using object_name and selector. selector : This value select a specific object within a object list that is obtained by object_name. If this value is None, current object is selected. e.g. current layout, current window and current screen. completer: Completer to use. config example: Key([alt, 'shift'], 'a', lazy.widget['prompt'].exec_general( 'section(add)', 'layout', 'add_section')) \"\"\" try : obj = self . qtile . select ([( object_name , selector )]) except SelectError : logger . warning ( \"cannot select a object\" ) return cmd = obj . command ( cmd_name ) if not cmd : logger . warning ( \"command not found\" ) return def f ( args ): if args : cmd ( args ) self . start_input ( prompt , f , completer )","title":"Parameters"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt.info","text":"Returns a dictionary of info for this object Source code in libqtile/widget/prompt.py 681 682 683 684 685 686 687 688 689 @expose_command () def info ( self ): \"\"\"Returns a dictionary of info for this object\"\"\" return dict ( name = self . name , width = self . width , text = self . text , active = self . active , )","title":"info()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt.process_key_press","text":"Key press handler for the minibuffer. Currently only supports ASCII characters. Source code in libqtile/widget/prompt.py 665 666 667 668 669 670 671 672 673 674 675 def process_key_press ( self , keysym : int ): \"\"\"Key press handler for the minibuffer. Currently only supports ASCII characters. \"\"\" handle_key = self . _get_keyhandler ( keysym ) if handle_key : handle_key () del self . key self . _update ()","title":"process_key_press()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt.start_input","text":"Run the prompt Displays a prompt and starts to take one line of keyboard input from the user. When done, calls the callback with the input string as argument. If history record is enabled, also allows to browse between previous commands with \u2191 and \u2193, and execute them (untouched or modified). When history is exhausted, fires an alert. It tries to mimic, in some way, the shell behavior.","title":"start_input()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.Prompt.start_input--parameters","text":"complete : Tab-completion. Can be None, \"cmd\", \"file\", \"group\", \"qshell\" or \"window\". prompt : text displayed at the prompt, e.g. \"spawn: \" callback : function to call with returned value. complete : completer to use. strict_completer : When True the return value wil be the exact completer result where available. allow_empty_input : When True, an empty value will still call the callback function Source code in libqtile/widget/prompt.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def start_input ( self , prompt , callback , complete = None , strict_completer = False , allow_empty_input = False ) -> None : \"\"\"Run the prompt Displays a prompt and starts to take one line of keyboard input from the user. When done, calls the callback with the input string as argument. If history record is enabled, also allows to browse between previous commands with \u2191 and \u2193, and execute them (untouched or modified). When history is exhausted, fires an alert. It tries to mimic, in some way, the shell behavior. Parameters ========== complete : Tab-completion. Can be None, \"cmd\", \"file\", \"group\", \"qshell\" or \"window\". prompt : text displayed at the prompt, e.g. \"spawn: \" callback : function to call with returned value. complete : completer to use. strict_completer : When True the return value wil be the exact completer result where available. allow_empty_input : When True, an empty value will still call the callback function \"\"\" if self . cursor and self . cursorblink and not self . active : self . timeout_add ( self . cursorblink , self . _blink ) self . display = self . prompt . format ( prompt = prompt ) self . display = pangocffi . markup_escape_text ( self . display ) self . active = True self . user_input = \"\" self . archived_input = \"\" self . show_cursor = self . cursor self . cursor_position = 0 self . callback = callback self . completer = self . completers [ complete ]( self . qtile ) self . strict_completer = strict_completer self . allow_empty_input = allow_empty_input self . _update () self . bar . widget_grab_keyboard ( self ) if self . record_history : self . completer_history = self . history [ complete ] self . position = len ( self . completer_history )","title":"Parameters"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.WindowCompleter","text":"Bases: AbstractCompleter Source code in libqtile/widget/prompt.py 219 220 221 222 223 def __init__ ( self , qtile : CommandObject ) -> None : self . qtile = qtile self . thisfinal = None # type: str | None self . lookup = None # type: list[tuple[str, str]] | None self . offset = - 1","title":"WindowCompleter"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.WindowCompleter.actual","text":"Returns the current actual value Source code in libqtile/widget/prompt.py 225 226 227 def actual ( self ) -> str | None : \"\"\"Returns the current actual value\"\"\" return self . thisfinal","title":"actual()"},{"location":"reference/libqtile/widget/prompt/#libqtile.widget.prompt.WindowCompleter.complete","text":"Returns the next completion for txt, or None if there is no completion Source code in libqtile/widget/prompt.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def complete ( self , txt : str ) -> str : \"\"\"Returns the next completion for txt, or None if there is no completion\"\"\" if self . lookup is None : self . lookup = [] for wid , window in self . qtile . windows_map . items (): if window . group and window . name . lower () . startswith ( txt ): self . lookup . append (( window . name , wid )) self . lookup . sort () self . offset = - 1 self . lookup . append (( txt , txt )) self . offset += 1 if self . offset >= len ( self . lookup ): self . offset = 0 ret = self . lookup [ self . offset ] self . thisfinal = ret [ 1 ] return ret [ 0 ]","title":"complete()"},{"location":"reference/libqtile/widget/pulse_volume/","text":"PulseVolume ( ** config ) Bases: Volume Source code in libqtile/widget/pulse_volume.py 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , ** config ): Volume . __init__ ( self , ** config ) self . add_defaults ( PulseVolume . defaults ) self . connected = None self . _subscribed = False self . default_sink_name = None self . default_sink = None self . handle = ffi . new_handle ( self ) self . client_name = ffi . new ( \"char[]\" , b \"Qtile-pulse\" ) change_volume ( volume ) order pulseaudio to apply new volume Source code in libqtile/widget/pulse_volume.py 152 153 154 155 156 157 158 159 160 161 162 163 def change_volume ( self , volume ): \"\"\" order pulseaudio to apply new volume \"\"\" # store new volume to \"speed up\" widget update so that we don't have # to wait a callback from pulseaudio self . default_sink [ \"values\" ] = list ( volume . values ) op = lib . pa_context_set_sink_volume_by_index ( self . context , self . default_sink [ \"index\" ], volume , ffi . NULL , ffi . NULL ) if op : self . wait_for_operation ( op ) connect () issue a connection to pulse audio server. result of a connection would be passed to on_connection_change method Source code in libqtile/widget/pulse_volume.py 66 67 68 69 70 71 72 73 74 75 76 77 def connect ( self ): \"\"\" issue a connection to pulse audio server. result of a connection would be passed to `on_connection_change` method \"\"\" # create a loop and api entry point self . loop = lib . pa_mainloop_new () self . api = lib . pa_mainloop_get_api ( self . loop ) # create context (e.g. connection) self . context = lib . pa_context_new ( self . api , self . client_name ) lib . pa_context_connect ( self . context , ffi . NULL , 0 , ffi . NULL ) lib . pa_context_set_state_callback ( self . context , lib . qtile_pa_context_changed , self . handle ) on_connection_change ( context ) a callback from pulse lib indicating connection status Source code in libqtile/widget/pulse_volume.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def on_connection_change ( self , context ): \"\"\"a callback from pulse lib indicating connection status\"\"\" state = lib . pa_context_get_state ( context ) if state == lib . PA_CONTEXT_READY : # ready self . connected = True # once onnection is established we need to get server information self . timeout_add ( 0.1 , self . get_server_info ) log . debug ( \"Connection to pulseaudio ready\" ) elif state == lib . PA_CONTEXT_FAILED : # failed to connect self . connected = False self . _subscribed = False log . warning ( \"Failed to connect to pulseaudio, retrying in 10s\" ) self . timeout_add ( 10 , self . connect ) elif state == lib . PA_CONTEXT_TERMINATED : # done self . connected = False self . _subscribed = False log . debug ( \"Connection to pulseaudio terminated cleanly\" ) elif state == lib . PA_CONTEXT_UNCONNECTED : self . connected = False self . _subscribed = False log . warning ( \"Disconnected from pulseaudio\" ) update () same method as in Volume widgets except that here we don't need to manually re-schedule update Source code in libqtile/widget/pulse_volume.py 224 225 226 227 228 229 230 231 232 233 234 235 def update ( self ): \"\"\" same method as in Volume widgets except that here we don't need to manually re-schedule update \"\"\" vol = self . get_volume () if vol != self . volume : self . volume = vol # Update the underlying canvas size before actually attempting # to figure out how big it is and draw it. self . _update_drawer () self . bar . draw () qtile_on_server_info ( context , info , userdata ) callback with a pulseaudio server info Source code in libqtile/widget/pulse_volume.py 25 26 27 28 29 @ffi . def_extern () def qtile_on_server_info ( context , info , userdata ): \"\"\"callback with a pulseaudio server info\"\"\" widget = ffi . from_handle ( userdata ) widget . on_server_info ( info ) qtile_on_sink_info ( context , info , eol , userdata ) callback for each output sink that pulseaudio server has Source code in libqtile/widget/pulse_volume.py 18 19 20 21 22 @ffi . def_extern () def qtile_on_sink_info ( context , info , eol , userdata ): \"\"\"callback for each output sink that pulseaudio server has\"\"\" widget = ffi . from_handle ( userdata ) widget . on_sink_info ( info , eol ) qtile_on_sink_update ( context , event_type , sink_index , userdata ) callback for updates made to sinks Source code in libqtile/widget/pulse_volume.py 32 33 34 35 36 @ffi . def_extern () def qtile_on_sink_update ( context , event_type , sink_index , userdata ): \"\"\"callback for updates made to sinks\"\"\" widget = ffi . from_handle ( userdata ) widget . on_sink_update ( event_type , sink_index ) qtile_pa_context_changed ( context , userdata ) callback for connecting status update Source code in libqtile/widget/pulse_volume.py 11 12 13 14 15 @ffi . def_extern () def qtile_pa_context_changed ( context , userdata ): \"\"\"callback for connecting status update\"\"\" widget = ffi . from_handle ( userdata ) widget . on_connection_change ( context )","title":"pulse_volume"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.PulseVolume","text":"Bases: Volume Source code in libqtile/widget/pulse_volume.py 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , ** config ): Volume . __init__ ( self , ** config ) self . add_defaults ( PulseVolume . defaults ) self . connected = None self . _subscribed = False self . default_sink_name = None self . default_sink = None self . handle = ffi . new_handle ( self ) self . client_name = ffi . new ( \"char[]\" , b \"Qtile-pulse\" )","title":"PulseVolume"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.PulseVolume.change_volume","text":"order pulseaudio to apply new volume Source code in libqtile/widget/pulse_volume.py 152 153 154 155 156 157 158 159 160 161 162 163 def change_volume ( self , volume ): \"\"\" order pulseaudio to apply new volume \"\"\" # store new volume to \"speed up\" widget update so that we don't have # to wait a callback from pulseaudio self . default_sink [ \"values\" ] = list ( volume . values ) op = lib . pa_context_set_sink_volume_by_index ( self . context , self . default_sink [ \"index\" ], volume , ffi . NULL , ffi . NULL ) if op : self . wait_for_operation ( op )","title":"change_volume()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.PulseVolume.connect","text":"issue a connection to pulse audio server. result of a connection would be passed to on_connection_change method Source code in libqtile/widget/pulse_volume.py 66 67 68 69 70 71 72 73 74 75 76 77 def connect ( self ): \"\"\" issue a connection to pulse audio server. result of a connection would be passed to `on_connection_change` method \"\"\" # create a loop and api entry point self . loop = lib . pa_mainloop_new () self . api = lib . pa_mainloop_get_api ( self . loop ) # create context (e.g. connection) self . context = lib . pa_context_new ( self . api , self . client_name ) lib . pa_context_connect ( self . context , ffi . NULL , 0 , ffi . NULL ) lib . pa_context_set_state_callback ( self . context , lib . qtile_pa_context_changed , self . handle )","title":"connect()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.PulseVolume.on_connection_change","text":"a callback from pulse lib indicating connection status Source code in libqtile/widget/pulse_volume.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def on_connection_change ( self , context ): \"\"\"a callback from pulse lib indicating connection status\"\"\" state = lib . pa_context_get_state ( context ) if state == lib . PA_CONTEXT_READY : # ready self . connected = True # once onnection is established we need to get server information self . timeout_add ( 0.1 , self . get_server_info ) log . debug ( \"Connection to pulseaudio ready\" ) elif state == lib . PA_CONTEXT_FAILED : # failed to connect self . connected = False self . _subscribed = False log . warning ( \"Failed to connect to pulseaudio, retrying in 10s\" ) self . timeout_add ( 10 , self . connect ) elif state == lib . PA_CONTEXT_TERMINATED : # done self . connected = False self . _subscribed = False log . debug ( \"Connection to pulseaudio terminated cleanly\" ) elif state == lib . PA_CONTEXT_UNCONNECTED : self . connected = False self . _subscribed = False log . warning ( \"Disconnected from pulseaudio\" )","title":"on_connection_change()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.PulseVolume.update","text":"same method as in Volume widgets except that here we don't need to manually re-schedule update Source code in libqtile/widget/pulse_volume.py 224 225 226 227 228 229 230 231 232 233 234 235 def update ( self ): \"\"\" same method as in Volume widgets except that here we don't need to manually re-schedule update \"\"\" vol = self . get_volume () if vol != self . volume : self . volume = vol # Update the underlying canvas size before actually attempting # to figure out how big it is and draw it. self . _update_drawer () self . bar . draw ()","title":"update()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.qtile_on_server_info","text":"callback with a pulseaudio server info Source code in libqtile/widget/pulse_volume.py 25 26 27 28 29 @ffi . def_extern () def qtile_on_server_info ( context , info , userdata ): \"\"\"callback with a pulseaudio server info\"\"\" widget = ffi . from_handle ( userdata ) widget . on_server_info ( info )","title":"qtile_on_server_info()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.qtile_on_sink_info","text":"callback for each output sink that pulseaudio server has Source code in libqtile/widget/pulse_volume.py 18 19 20 21 22 @ffi . def_extern () def qtile_on_sink_info ( context , info , eol , userdata ): \"\"\"callback for each output sink that pulseaudio server has\"\"\" widget = ffi . from_handle ( userdata ) widget . on_sink_info ( info , eol )","title":"qtile_on_sink_info()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.qtile_on_sink_update","text":"callback for updates made to sinks Source code in libqtile/widget/pulse_volume.py 32 33 34 35 36 @ffi . def_extern () def qtile_on_sink_update ( context , event_type , sink_index , userdata ): \"\"\"callback for updates made to sinks\"\"\" widget = ffi . from_handle ( userdata ) widget . on_sink_update ( event_type , sink_index )","title":"qtile_on_sink_update()"},{"location":"reference/libqtile/widget/pulse_volume/#libqtile.widget.pulse_volume.qtile_pa_context_changed","text":"callback for connecting status update Source code in libqtile/widget/pulse_volume.py 11 12 13 14 15 @ffi . def_extern () def qtile_pa_context_changed ( context , userdata ): \"\"\"callback for connecting status update\"\"\" widget = ffi . from_handle ( userdata ) widget . on_connection_change ( context )","title":"qtile_pa_context_changed()"},{"location":"reference/libqtile/widget/pulseaudio_ffi/","text":"","title":"pulseaudio_ffi"},{"location":"reference/libqtile/widget/quick_exit/","text":"QuickExit ( ** config ) Bases: base . _TextBox A button to shut down Qtile. When clicked, a countdown starts. Clicking the button again stops the countdown and prevents Qtile from shutting down. Source code in libqtile/widget/quick_exit.py 37 38 39 40 41 42 43 44 45 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( QuickExit . defaults ) self . is_counting = False self . text = self . default_text self . countdown = self . countdown_start self . add_callbacks ({ \"Button1\" : self . trigger })","title":"quick_exit"},{"location":"reference/libqtile/widget/quick_exit/#libqtile.widget.quick_exit.QuickExit","text":"Bases: base . _TextBox A button to shut down Qtile. When clicked, a countdown starts. Clicking the button again stops the countdown and prevents Qtile from shutting down. Source code in libqtile/widget/quick_exit.py 37 38 39 40 41 42 43 44 45 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"\" , ** config ) self . add_defaults ( QuickExit . defaults ) self . is_counting = False self . text = self . default_text self . countdown = self . countdown_start self . add_callbacks ({ \"Button1\" : self . trigger })","title":"QuickExit"},{"location":"reference/libqtile/widget/sensors/","text":"ThermalSensor ( ** config ) Bases: base . InLoopPollText Widget to display temperature sensor information For using the thermal sensor widget you need to have lm-sensors installed. You can get a list of the tag_sensors executing \"sensors\" in your terminal. Then you can choose which you want, otherwise it will display the first available. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/sensors.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( ThermalSensor . defaults ) temp_values = self . get_temp_sensors () self . foreground_normal = self . foreground if temp_values is None : self . data = \"sensors command not found\" elif len ( temp_values ) == 0 : self . data = \"Temperature sensors not found\" elif self . tag_sensor is None : for k in temp_values : self . tag_sensor = k break get_temp_sensors () Reads temperatures from sys-fs via psutil. Output will be read Fahrenheit if user has specified it to be. Source code in libqtile/widget/sensors.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_temp_sensors ( self ): \"\"\" Reads temperatures from sys-fs via psutil. Output will be read Fahrenheit if user has specified it to be. \"\"\" temperature_list = {} temps = psutil . sensors_temperatures ( fahrenheit = not self . metric ) empty_index = 0 for kernel_module in temps : for sensor in temps [ kernel_module ]: label = sensor . label if not label : label = \" {} - {} \" . format ( kernel_module if kernel_module else \"UNKNOWN\" , str ( empty_index ) ) empty_index += 1 temperature_list [ label ] = sensor . current return temperature_list","title":"sensors"},{"location":"reference/libqtile/widget/sensors/#libqtile.widget.sensors.ThermalSensor","text":"Bases: base . InLoopPollText Widget to display temperature sensor information For using the thermal sensor widget you need to have lm-sensors installed. You can get a list of the tag_sensors executing \"sensors\" in your terminal. Then you can choose which you want, otherwise it will display the first available. Widget requirements: psutil_. .. _psutil: https://pypi.org/project/psutil/ Source code in libqtile/widget/sensors.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( ThermalSensor . defaults ) temp_values = self . get_temp_sensors () self . foreground_normal = self . foreground if temp_values is None : self . data = \"sensors command not found\" elif len ( temp_values ) == 0 : self . data = \"Temperature sensors not found\" elif self . tag_sensor is None : for k in temp_values : self . tag_sensor = k break","title":"ThermalSensor"},{"location":"reference/libqtile/widget/sensors/#libqtile.widget.sensors.ThermalSensor.get_temp_sensors","text":"Reads temperatures from sys-fs via psutil. Output will be read Fahrenheit if user has specified it to be. Source code in libqtile/widget/sensors.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_temp_sensors ( self ): \"\"\" Reads temperatures from sys-fs via psutil. Output will be read Fahrenheit if user has specified it to be. \"\"\" temperature_list = {} temps = psutil . sensors_temperatures ( fahrenheit = not self . metric ) empty_index = 0 for kernel_module in temps : for sensor in temps [ kernel_module ]: label = sensor . label if not label : label = \" {} - {} \" . format ( kernel_module if kernel_module else \"UNKNOWN\" , str ( empty_index ) ) empty_index += 1 temperature_list [ label ] = sensor . current return temperature_list","title":"get_temp_sensors()"},{"location":"reference/libqtile/widget/sep/","text":"Sep ( ** config ) Bases: base . _Widget A visible widget separator Source code in libqtile/widget/sep.py 40 41 42 43 44 def __init__ ( self , ** config ): length = config . get ( \"padding\" , 2 ) * 2 + config . get ( \"linewidth\" , 1 ) base . _Widget . __init__ ( self , length , ** config ) self . add_defaults ( Sep . defaults ) self . length = self . padding + self . linewidth","title":"sep"},{"location":"reference/libqtile/widget/sep/#libqtile.widget.sep.Sep","text":"Bases: base . _Widget A visible widget separator Source code in libqtile/widget/sep.py 40 41 42 43 44 def __init__ ( self , ** config ): length = config . get ( \"padding\" , 2 ) * 2 + config . get ( \"linewidth\" , 1 ) base . _Widget . __init__ ( self , length , ** config ) self . add_defaults ( Sep . defaults ) self . length = self . padding + self . linewidth","title":"Sep"},{"location":"reference/libqtile/widget/she/","text":"She ( ** config ) Bases: base . InLoopPollText Widget to display the Super Hybrid Engine status Can display either the mode or CPU speed on eeepc computers. Source code in libqtile/widget/she.py 37 38 39 40 41 42 43 44 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( She . defaults ) self . modes = { \"0x300\" : { \"name\" : \"Performance\" , \"speed\" : \"1.6GHz\" }, \"0x301\" : { \"name\" : \"Normal\" , \"speed\" : \"1.2GHz\" }, \"0x302\" : { \"name\" : \"PoswerSave\" , \"speed\" : \"800MHz\" }, }","title":"she"},{"location":"reference/libqtile/widget/she/#libqtile.widget.she.She","text":"Bases: base . InLoopPollText Widget to display the Super Hybrid Engine status Can display either the mode or CPU speed on eeepc computers. Source code in libqtile/widget/she.py 37 38 39 40 41 42 43 44 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( She . defaults ) self . modes = { \"0x300\" : { \"name\" : \"Performance\" , \"speed\" : \"1.6GHz\" }, \"0x301\" : { \"name\" : \"Normal\" , \"speed\" : \"1.2GHz\" }, \"0x302\" : { \"name\" : \"PoswerSave\" , \"speed\" : \"800MHz\" }, }","title":"She"},{"location":"reference/libqtile/widget/spacer/","text":"Spacer ( length = bar . STRETCH , ** config ) Bases: base . _Widget Just an empty space on the bar Often used with length equal to bar.STRETCH to push bar widgets to the right or bottom edge of the screen. Parameters length : Length of the widget. Can be either bar.STRETCH or a length in pixels. width : DEPRECATED, same as length . Source code in libqtile/widget/spacer.py 49 50 51 52 def __init__ ( self , length = bar . STRETCH , ** config ): \"\"\" \"\"\" base . _Widget . __init__ ( self , length , ** config ) self . add_defaults ( Spacer . defaults )","title":"spacer"},{"location":"reference/libqtile/widget/spacer/#libqtile.widget.spacer.Spacer","text":"Bases: base . _Widget Just an empty space on the bar Often used with length equal to bar.STRETCH to push bar widgets to the right or bottom edge of the screen.","title":"Spacer"},{"location":"reference/libqtile/widget/spacer/#libqtile.widget.spacer.Spacer--parameters","text":"length : Length of the widget. Can be either bar.STRETCH or a length in pixels. width : DEPRECATED, same as length . Source code in libqtile/widget/spacer.py 49 50 51 52 def __init__ ( self , length = bar . STRETCH , ** config ): \"\"\" \"\"\" base . _Widget . __init__ ( self , length , ** config ) self . add_defaults ( Spacer . defaults )","title":"Parameters"},{"location":"reference/libqtile/widget/statusnotifier/","text":"StatusNotifier ( ** config ) Bases: base . _Widget A 'system tray' widget using the freedesktop StatusNotifierItem specification. As per the specification, app icons are first retrieved from the user's current theme. If this is not available then the app may provide its own icon. In order to use this functionality, users are recommended to install the pyxdg <https://pypi.org/project/pyxdg/> __ module to support retrieving icons from the selected theme. Letf-clicking an icon will trigger an activate event. .. note:: Context menus are not currently supported by the official widget. However, a modded version of the widget which provides basic menu support is available from elParaguayo's `qtile-extras <https://github.com/elParaguayo/qtile-extras>`_ repo. Source code in libqtile/widget/statusnotifier.py 605 606 607 608 609 610 611 612 613 def __init__ ( self , ** config ): base . _Widget . __init__ ( self , bar . CALCULATED , ** config ) self . add_defaults ( StatusNotifier . defaults ) self . add_callbacks ( { \"Button1\" : self . activate , } ) self . selected_item : Optional [ StatusNotifierItem ] = None activate () Primary action when clicking on an icon Source code in libqtile/widget/statusnotifier.py 691 692 693 694 695 def activate ( self ): \"\"\"Primary action when clicking on an icon\"\"\" if not self . selected_item : return self . selected_item . activate () find_icon_at_pos ( x , y ) returns StatusNotifierItem object for icon in given position Source code in libqtile/widget/statusnotifier.py 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 def find_icon_at_pos ( self , x , y ): \"\"\"returns StatusNotifierItem object for icon in given position\"\"\" offset = self . padding val = x if self . bar . horizontal else y if val < offset : return None for icon in self . available_icons : offset += self . icon_size if val < offset : return icon offset += self . padding return None StatusNotifierHost () Host object to act as a bridge between the widget and the DBus objects. The Host collates items returned from multiple watcher interfaces and collates them into a single list for the widget to access. Source code in libqtile/widget/statusnotifier.py 483 484 485 486 487 488 489 490 491 def __init__ ( self ): self . watchers : List [ StatusNotifierWatcher ] = [] self . items : List [ StatusNotifierItem ] = [] self . name = \"qtile\" self . icon_theme : str = None self . started = False self . _on_item_added : List [ Callable ] = [] self . _on_item_removed : List [ Callable ] = [] self . _on_icon_changed : List [ Callable ] = [] add_item ( service , path = None ) Creates a StatusNotifierItem for the given service and tries to start it. Source code in libqtile/widget/statusnotifier.py 549 550 551 552 553 554 555 556 557 558 def add_item ( self , service , path = None ): \"\"\" Creates a StatusNotifierItem for the given service and tries to start it. \"\"\" item = StatusNotifierItem ( self . bus , service , path = path , icon_theme = self . icon_theme ) item . on_icon_changed = self . item_icon_changed if item not in self . items : task = asyncio . create_task ( item . start ()) task . add_done_callback ( partial ( self . item_added , item , service )) start ( on_item_added = None , on_item_removed = None , on_icon_changed = None ) async Starts the host if not already started. Widgets should register their callbacks via this method. Source code in libqtile/widget/statusnotifier.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 async def start ( self , on_item_added : Optional [ Callable ] = None , on_item_removed : Optional [ Callable ] = None , on_icon_changed : Optional [ Callable ] = None , ): \"\"\" Starts the host if not already started. Widgets should register their callbacks via this method. \"\"\" if on_item_added : self . _on_item_added . append ( on_item_added ) if on_item_removed : self . _on_item_removed . append ( on_item_removed ) if on_icon_changed : self . _on_icon_changed . append ( on_icon_changed ) if self . started : if on_item_added : for item in self . items : on_item_added ( item ) return self . bus = await MessageBus () . connect () for iface in BUS_NAMES : w = StatusNotifierWatcher ( iface ) w . on_item_added = self . add_item w . on_item_removed = self . remove_item await w . start () # Not quite following spec here as we're not registering # the host on the bus. w . RegisterStatusNotifierHost ( self . name ) self . watchers . append ( w ) self . started = True StatusNotifierItem ( bus , service , path = None , icon_theme = None ) Class object which represents an StatusNotiferItem object. The item is responsible for interacting with the application. Source code in libqtile/widget/statusnotifier.py 73 74 75 76 77 78 79 80 81 82 83 84 def __init__ ( self , bus , service , path = None , icon_theme = None ): self . bus = bus self . service = service self . surfaces = {} self . _pixmaps = {} self . _icon = None self . _overlay_icon = None self . _attention_icon = None self . on_icon_changed = None self . icon_theme = icon_theme self . icon = None self . path = path if path else STATUSNOTIFIER_PATH get_icon ( size ) Returns a cairo ImageSurface for the selected size . Will pick the appropriate icon and add any overlay as required. Source code in libqtile/widget/statusnotifier.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def get_icon ( self , size ): \"\"\" Returns a cairo ImageSurface for the selected `size`. Will pick the appropriate icon and add any overlay as required. \"\"\" # Use existing icon if generated previously if size in self . surfaces : return self . surfaces [ size ] # Create a blank ImageSurface to hold the icon icon = cairocffi . ImageSurface ( cairocffi . FORMAT_ARGB32 , size , size ) if self . icon : base_icon = self . icon . surface icon_size = base_icon . get_width () overlay = None else : # Find best matching icon size: # We get all available sizes and filter this list so it only shows # the icon sizes bigger than the requested size (we prefer to # shrink icons rather than scale them up) all_sizes = self . _get_sizes () sizes = [ s for s in all_sizes if s >= size ] # TODO: This is messy. Shouldn't return blank icon # If there are no sizes at all (i.e. no icon) then we return empty # icon if not all_sizes : return icon # Choose the first available size. If there are none (i.e. we # request icon size bigger than the largest provided by the app), # we just take the largest icon icon_size = sizes [ 0 ] if sizes else all_sizes [ - 1 ] srfs = self . _get_surfaces ( icon_size ) # TODO: This shouldn't happen... if not srfs : return icon # TODO: Check spec for when to use \"attention\" base_icon = srfs . get ( \"Attention\" , srfs [ \"Icon\" ]) overlay = srfs . get ( \"Overlay\" , None ) with cairocffi . Context ( icon ) as ctx : scale = size / icon_size ctx . scale ( scale , scale ) ctx . set_source_surface ( base_icon ) ctx . paint () if overlay : ctx . set_source_surface ( overlay ) ctx . paint () # Store the surface for next time self . surfaces [ size ] = icon return icon StatusNotifierWatcher ( service ) Bases: ServiceInterface DBus service that creates a StatusNotifierWatcher interface on the bus and listens for applications wanting to register items. Source code in libqtile/widget/statusnotifier.py 348 349 350 351 352 353 354 355 356 def __init__ ( self , service : str ): super () . __init__ ( service ) self . _items : List [ str ] = [] self . _hosts : List [ str ] = [] self . service = service self . on_item_added : Optional [ Callable ] = None self . on_host_added : Optional [ Callable ] = None self . on_item_removed : Optional [ Callable ] = None self . on_host_removed : Optional [ Callable ] = None","title":"statusnotifier"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifier","text":"Bases: base . _Widget A 'system tray' widget using the freedesktop StatusNotifierItem specification. As per the specification, app icons are first retrieved from the user's current theme. If this is not available then the app may provide its own icon. In order to use this functionality, users are recommended to install the pyxdg <https://pypi.org/project/pyxdg/> __ module to support retrieving icons from the selected theme. Letf-clicking an icon will trigger an activate event. .. note:: Context menus are not currently supported by the official widget. However, a modded version of the widget which provides basic menu support is available from elParaguayo's `qtile-extras <https://github.com/elParaguayo/qtile-extras>`_ repo. Source code in libqtile/widget/statusnotifier.py 605 606 607 608 609 610 611 612 613 def __init__ ( self , ** config ): base . _Widget . __init__ ( self , bar . CALCULATED , ** config ) self . add_defaults ( StatusNotifier . defaults ) self . add_callbacks ( { \"Button1\" : self . activate , } ) self . selected_item : Optional [ StatusNotifierItem ] = None","title":"StatusNotifier"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifier.activate","text":"Primary action when clicking on an icon Source code in libqtile/widget/statusnotifier.py 691 692 693 694 695 def activate ( self ): \"\"\"Primary action when clicking on an icon\"\"\" if not self . selected_item : return self . selected_item . activate ()","title":"activate()"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifier.find_icon_at_pos","text":"returns StatusNotifierItem object for icon in given position Source code in libqtile/widget/statusnotifier.py 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 def find_icon_at_pos ( self , x , y ): \"\"\"returns StatusNotifierItem object for icon in given position\"\"\" offset = self . padding val = x if self . bar . horizontal else y if val < offset : return None for icon in self . available_icons : offset += self . icon_size if val < offset : return icon offset += self . padding return None","title":"find_icon_at_pos()"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifierHost","text":"Host object to act as a bridge between the widget and the DBus objects. The Host collates items returned from multiple watcher interfaces and collates them into a single list for the widget to access. Source code in libqtile/widget/statusnotifier.py 483 484 485 486 487 488 489 490 491 def __init__ ( self ): self . watchers : List [ StatusNotifierWatcher ] = [] self . items : List [ StatusNotifierItem ] = [] self . name = \"qtile\" self . icon_theme : str = None self . started = False self . _on_item_added : List [ Callable ] = [] self . _on_item_removed : List [ Callable ] = [] self . _on_icon_changed : List [ Callable ] = []","title":"StatusNotifierHost"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifierHost.add_item","text":"Creates a StatusNotifierItem for the given service and tries to start it. Source code in libqtile/widget/statusnotifier.py 549 550 551 552 553 554 555 556 557 558 def add_item ( self , service , path = None ): \"\"\" Creates a StatusNotifierItem for the given service and tries to start it. \"\"\" item = StatusNotifierItem ( self . bus , service , path = path , icon_theme = self . icon_theme ) item . on_icon_changed = self . item_icon_changed if item not in self . items : task = asyncio . create_task ( item . start ()) task . add_done_callback ( partial ( self . item_added , item , service ))","title":"add_item()"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifierHost.start","text":"Starts the host if not already started. Widgets should register their callbacks via this method. Source code in libqtile/widget/statusnotifier.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 async def start ( self , on_item_added : Optional [ Callable ] = None , on_item_removed : Optional [ Callable ] = None , on_icon_changed : Optional [ Callable ] = None , ): \"\"\" Starts the host if not already started. Widgets should register their callbacks via this method. \"\"\" if on_item_added : self . _on_item_added . append ( on_item_added ) if on_item_removed : self . _on_item_removed . append ( on_item_removed ) if on_icon_changed : self . _on_icon_changed . append ( on_icon_changed ) if self . started : if on_item_added : for item in self . items : on_item_added ( item ) return self . bus = await MessageBus () . connect () for iface in BUS_NAMES : w = StatusNotifierWatcher ( iface ) w . on_item_added = self . add_item w . on_item_removed = self . remove_item await w . start () # Not quite following spec here as we're not registering # the host on the bus. w . RegisterStatusNotifierHost ( self . name ) self . watchers . append ( w ) self . started = True","title":"start()"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifierItem","text":"Class object which represents an StatusNotiferItem object. The item is responsible for interacting with the application. Source code in libqtile/widget/statusnotifier.py 73 74 75 76 77 78 79 80 81 82 83 84 def __init__ ( self , bus , service , path = None , icon_theme = None ): self . bus = bus self . service = service self . surfaces = {} self . _pixmaps = {} self . _icon = None self . _overlay_icon = None self . _attention_icon = None self . on_icon_changed = None self . icon_theme = icon_theme self . icon = None self . path = path if path else STATUSNOTIFIER_PATH","title":"StatusNotifierItem"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifierItem.get_icon","text":"Returns a cairo ImageSurface for the selected size . Will pick the appropriate icon and add any overlay as required. Source code in libqtile/widget/statusnotifier.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def get_icon ( self , size ): \"\"\" Returns a cairo ImageSurface for the selected `size`. Will pick the appropriate icon and add any overlay as required. \"\"\" # Use existing icon if generated previously if size in self . surfaces : return self . surfaces [ size ] # Create a blank ImageSurface to hold the icon icon = cairocffi . ImageSurface ( cairocffi . FORMAT_ARGB32 , size , size ) if self . icon : base_icon = self . icon . surface icon_size = base_icon . get_width () overlay = None else : # Find best matching icon size: # We get all available sizes and filter this list so it only shows # the icon sizes bigger than the requested size (we prefer to # shrink icons rather than scale them up) all_sizes = self . _get_sizes () sizes = [ s for s in all_sizes if s >= size ] # TODO: This is messy. Shouldn't return blank icon # If there are no sizes at all (i.e. no icon) then we return empty # icon if not all_sizes : return icon # Choose the first available size. If there are none (i.e. we # request icon size bigger than the largest provided by the app), # we just take the largest icon icon_size = sizes [ 0 ] if sizes else all_sizes [ - 1 ] srfs = self . _get_surfaces ( icon_size ) # TODO: This shouldn't happen... if not srfs : return icon # TODO: Check spec for when to use \"attention\" base_icon = srfs . get ( \"Attention\" , srfs [ \"Icon\" ]) overlay = srfs . get ( \"Overlay\" , None ) with cairocffi . Context ( icon ) as ctx : scale = size / icon_size ctx . scale ( scale , scale ) ctx . set_source_surface ( base_icon ) ctx . paint () if overlay : ctx . set_source_surface ( overlay ) ctx . paint () # Store the surface for next time self . surfaces [ size ] = icon return icon","title":"get_icon()"},{"location":"reference/libqtile/widget/statusnotifier/#libqtile.widget.statusnotifier.StatusNotifierWatcher","text":"Bases: ServiceInterface DBus service that creates a StatusNotifierWatcher interface on the bus and listens for applications wanting to register items. Source code in libqtile/widget/statusnotifier.py 348 349 350 351 352 353 354 355 356 def __init__ ( self , service : str ): super () . __init__ ( service ) self . _items : List [ str ] = [] self . _hosts : List [ str ] = [] self . service = service self . on_item_added : Optional [ Callable ] = None self . on_host_added : Optional [ Callable ] = None self . on_item_removed : Optional [ Callable ] = None self . on_host_removed : Optional [ Callable ] = None","title":"StatusNotifierWatcher"},{"location":"reference/libqtile/widget/stock_ticker/","text":"StockTicker ( ** config ) Bases: GenPollUrl A stock ticker widget, based on the alphavantage API. Users must acquire an API key from https://www.alphavantage.co/support/#api-key The widget defaults to the TIME_SERIES_INTRADAY API function (i.e. stock symbols), but arbitrary Alpha Vantage API queries can be made by passing extra arguments to the constructor. :: # Display AMZN widget.StockTicker(apikey=..., symbol=\"AMZN\") # Display BTC widget.StockTicker( apikey=..., function=\"DIGITAL_CURRENCY_INTRADAY\", symbol=\"BTC\", market=\"USD\" ) Source code in libqtile/widget/stock_ticker.py 54 55 56 57 58 59 60 61 62 63 def __init__ ( self , ** config ): if \"function\" in config : logger . warning ( \"`function` parameter is deprecated. Please rename to `func`\" ) config [ \"func\" ] = config . pop ( \"function\" ) GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( StockTicker . defaults ) self . sign = locale . localeconv ()[ \"currency_symbol\" ] self . query = { \"interval\" : self . interval , \"outputsize\" : \"compact\" , \"function\" : self . func } for k , v in config . items (): self . query [ k ] = v","title":"stock_ticker"},{"location":"reference/libqtile/widget/stock_ticker/#libqtile.widget.stock_ticker.StockTicker","text":"Bases: GenPollUrl A stock ticker widget, based on the alphavantage API. Users must acquire an API key from https://www.alphavantage.co/support/#api-key The widget defaults to the TIME_SERIES_INTRADAY API function (i.e. stock symbols), but arbitrary Alpha Vantage API queries can be made by passing extra arguments to the constructor. :: # Display AMZN widget.StockTicker(apikey=..., symbol=\"AMZN\") # Display BTC widget.StockTicker( apikey=..., function=\"DIGITAL_CURRENCY_INTRADAY\", symbol=\"BTC\", market=\"USD\" ) Source code in libqtile/widget/stock_ticker.py 54 55 56 57 58 59 60 61 62 63 def __init__ ( self , ** config ): if \"function\" in config : logger . warning ( \"`function` parameter is deprecated. Please rename to `func`\" ) config [ \"func\" ] = config . pop ( \"function\" ) GenPollUrl . __init__ ( self , ** config ) self . add_defaults ( StockTicker . defaults ) self . sign = locale . localeconv ()[ \"currency_symbol\" ] self . query = { \"interval\" : self . interval , \"outputsize\" : \"compact\" , \"function\" : self . func } for k , v in config . items (): self . query [ k ] = v","title":"StockTicker"},{"location":"reference/libqtile/widget/systray/","text":"Systray ( ** config ) Bases: base . _Widget , window . _Window A widget that manages system tray. Only one Systray widget is allowed. Adding additional Systray widgets will result in a ConfigError. .. note:: Icons will not render correctly where the bar/widget is drawn with a semi-transparent background. Instead, icons will be drawn with a transparent background. If using this widget it is therefore recommended to use a fully opaque background colour or a fully transparent one. Source code in libqtile/widget/systray.py 131 132 133 134 135 136 137 def __init__ ( self , ** config ): base . _Widget . __init__ ( self , bar . CALCULATED , ** config ) self . add_defaults ( Systray . defaults ) self . tray_icons = [] self . screen = 0 self . _name = config . get ( \"name\" , \"systray\" ) self . _wm_class : list [ str ] | None = None create_mirror () Systray cannot be mirrored as we do not use a Drawer object to render icons. Return new, unconfigured instance so that, when the bar tries to configure it again, a ConfigError is raised. Source code in libqtile/widget/systray.py 203 204 205 206 207 208 209 210 def create_mirror ( self ): \"\"\" Systray cannot be mirrored as we do not use a Drawer object to render icons. Return new, unconfigured instance so that, when the bar tries to configure it again, a ConfigError is raised. \"\"\" return Systray ()","title":"systray"},{"location":"reference/libqtile/widget/systray/#libqtile.widget.systray.Systray","text":"Bases: base . _Widget , window . _Window A widget that manages system tray. Only one Systray widget is allowed. Adding additional Systray widgets will result in a ConfigError. .. note:: Icons will not render correctly where the bar/widget is drawn with a semi-transparent background. Instead, icons will be drawn with a transparent background. If using this widget it is therefore recommended to use a fully opaque background colour or a fully transparent one. Source code in libqtile/widget/systray.py 131 132 133 134 135 136 137 def __init__ ( self , ** config ): base . _Widget . __init__ ( self , bar . CALCULATED , ** config ) self . add_defaults ( Systray . defaults ) self . tray_icons = [] self . screen = 0 self . _name = config . get ( \"name\" , \"systray\" ) self . _wm_class : list [ str ] | None = None","title":"Systray"},{"location":"reference/libqtile/widget/systray/#libqtile.widget.systray.Systray.create_mirror","text":"Systray cannot be mirrored as we do not use a Drawer object to render icons. Return new, unconfigured instance so that, when the bar tries to configure it again, a ConfigError is raised. Source code in libqtile/widget/systray.py 203 204 205 206 207 208 209 210 def create_mirror ( self ): \"\"\" Systray cannot be mirrored as we do not use a Drawer object to render icons. Return new, unconfigured instance so that, when the bar tries to configure it again, a ConfigError is raised. \"\"\" return Systray ()","title":"create_mirror()"},{"location":"reference/libqtile/widget/tasklist/","text":"TaskList ( ** config ) Bases: base . _Widget , base . PaddingMixin , base . MarginMixin Displays the icon and name of each window in the current group Contrary to WindowTabs this is an interactive widget. The window that currently has focus is highlighted. Optional requirements: pyxdg <https://pypi.org/project/pyxdg/> __ is needed to use theme icons and to display icons on Wayland. Source code in libqtile/widget/tasklist.py 169 170 171 172 173 174 175 176 177 178 179 180 181 def __init__ ( self , ** config ): base . _Widget . __init__ ( self , bar . STRETCH , ** config ) self . add_defaults ( TaskList . defaults ) self . add_defaults ( base . PaddingMixin . defaults ) self . add_defaults ( base . MarginMixin . defaults ) self . _icons_cache = {} self . _box_end_positions = [] self . markup = False self . clicked = None if self . spacing is None : self . spacing = self . margin_x self . add_callbacks ({ \"Button1\" : self . select_window }) box_width ( text ) calculate box width for given text. If max_title_width is given, the returned width is limited to it. Source code in libqtile/widget/tasklist.py 183 184 185 186 187 188 189 190 191 192 def box_width ( self , text ): \"\"\" calculate box width for given text. If max_title_width is given, the returned width is limited to it. \"\"\" if self . markup : text = re . sub ( \"<[^<]+?>\" , \"\" , text ) width , _ = self . drawer . max_layout_size ([ text ], self . font , self . fontsize ) width = width + 2 * ( self . padding_x + self . borderwidth ) return width calc_box_widths () Calculate box width for each window in current group. If the available space is less than overall size of boxes, the boxes are shrunk by percentage if greater than average. Source code in libqtile/widget/tasklist.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def calc_box_widths ( self ): \"\"\" Calculate box width for each window in current group. If the available space is less than overall size of boxes, the boxes are shrunk by percentage if greater than average. \"\"\" windows = self . windows window_count = len ( windows ) # if no windows present for current group just return empty list if not window_count : return [] # Determine available and max average width for task name boxes. width_total = self . width - 2 * self . margin_x - ( window_count - 1 ) * self . spacing width_avg = width_total / window_count names = [ self . get_taskname ( w ) for w in windows ] if self . icon_size == 0 : icons = len ( windows ) * [ None ] else : icons = [ self . get_window_icon ( w ) for w in windows ] # Obey title_width_method if specified if self . title_width_method == \"uniform\" : width_uniform = width_total // window_count width_boxes = [ width_uniform for w in range ( window_count )] else : # Default behaviour: calculated width for each task according to # icon and task name consisting # of state abbreviation and window name width_boxes = [ ( self . box_width ( names [ idx ]) + (( self . icon_size + self . padding_x ) if icons [ idx ] else 0 ) ) for idx in range ( window_count ) ] # Obey max_title_width if specified if self . max_title_width : width_boxes = [ min ( w , self . max_title_width ) for w in width_boxes ] width_sum = sum ( width_boxes ) # calculated box width are to wide for available widget space: if width_sum > width_total : # sum the width of tasks shorter than calculated average # and calculate a ratio to shrink boxes greater than width_avg width_shorter_sum = sum ([ w for w in width_boxes if w < width_avg ]) ratio = ( width_total - width_shorter_sum ) / ( width_sum - width_shorter_sum ) # determine new box widths by shrinking boxes greater than avg width_boxes = [( w if w < width_avg else w * ratio ) for w in width_boxes ] return zip ( windows , icons , names , width_boxes ) get_taskname ( window ) Get display name for given window. Depending on its state minimized, maximized and floating appropriate characters are prepended. Source code in libqtile/widget/tasklist.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def get_taskname ( self , window ): \"\"\" Get display name for given window. Depending on its state minimized, maximized and floating appropriate characters are prepended. \"\"\" state = \"\" markup_str = self . markup_normal # Enforce markup and new string format behaviour when # at least one markup_* option is used. # Mixing non markup and markup may cause problems. if ( self . markup_minimized or self . markup_maximized or self . markup_floating or self . markup_focused ): enforce_markup = True else : enforce_markup = False if window is None : pass elif window . minimized : state = self . txt_minimized markup_str = self . markup_minimized elif window . maximized : state = self . txt_maximized markup_str = self . markup_maximized elif window . floating : state = self . txt_floating markup_str = self . markup_floating elif window is window . group . current_window : markup_str = self . markup_focused window_name = window . name if window and window . name else \"?\" if callable ( self . parse_text ): try : window_name = self . parse_text ( window_name ) except : # noqa: E722 logger . exception ( \"parse_text function failed:\" ) # Emulate default widget behavior if markup_str is None if enforce_markup and markup_str is None : markup_str = \" %s{} \" % ( state ) if markup_str is not None : self . markup = True window_name = pangocffi . markup_escape_text ( window_name ) return markup_str . format ( window_name ) return \" %s%s \" % ( state , window_name )","title":"tasklist"},{"location":"reference/libqtile/widget/tasklist/#libqtile.widget.tasklist.TaskList","text":"Bases: base . _Widget , base . PaddingMixin , base . MarginMixin Displays the icon and name of each window in the current group Contrary to WindowTabs this is an interactive widget. The window that currently has focus is highlighted. Optional requirements: pyxdg <https://pypi.org/project/pyxdg/> __ is needed to use theme icons and to display icons on Wayland. Source code in libqtile/widget/tasklist.py 169 170 171 172 173 174 175 176 177 178 179 180 181 def __init__ ( self , ** config ): base . _Widget . __init__ ( self , bar . STRETCH , ** config ) self . add_defaults ( TaskList . defaults ) self . add_defaults ( base . PaddingMixin . defaults ) self . add_defaults ( base . MarginMixin . defaults ) self . _icons_cache = {} self . _box_end_positions = [] self . markup = False self . clicked = None if self . spacing is None : self . spacing = self . margin_x self . add_callbacks ({ \"Button1\" : self . select_window })","title":"TaskList"},{"location":"reference/libqtile/widget/tasklist/#libqtile.widget.tasklist.TaskList.box_width","text":"calculate box width for given text. If max_title_width is given, the returned width is limited to it. Source code in libqtile/widget/tasklist.py 183 184 185 186 187 188 189 190 191 192 def box_width ( self , text ): \"\"\" calculate box width for given text. If max_title_width is given, the returned width is limited to it. \"\"\" if self . markup : text = re . sub ( \"<[^<]+?>\" , \"\" , text ) width , _ = self . drawer . max_layout_size ([ text ], self . font , self . fontsize ) width = width + 2 * ( self . padding_x + self . borderwidth ) return width","title":"box_width()"},{"location":"reference/libqtile/widget/tasklist/#libqtile.widget.tasklist.TaskList.calc_box_widths","text":"Calculate box width for each window in current group. If the available space is less than overall size of boxes, the boxes are shrunk by percentage if greater than average. Source code in libqtile/widget/tasklist.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def calc_box_widths ( self ): \"\"\" Calculate box width for each window in current group. If the available space is less than overall size of boxes, the boxes are shrunk by percentage if greater than average. \"\"\" windows = self . windows window_count = len ( windows ) # if no windows present for current group just return empty list if not window_count : return [] # Determine available and max average width for task name boxes. width_total = self . width - 2 * self . margin_x - ( window_count - 1 ) * self . spacing width_avg = width_total / window_count names = [ self . get_taskname ( w ) for w in windows ] if self . icon_size == 0 : icons = len ( windows ) * [ None ] else : icons = [ self . get_window_icon ( w ) for w in windows ] # Obey title_width_method if specified if self . title_width_method == \"uniform\" : width_uniform = width_total // window_count width_boxes = [ width_uniform for w in range ( window_count )] else : # Default behaviour: calculated width for each task according to # icon and task name consisting # of state abbreviation and window name width_boxes = [ ( self . box_width ( names [ idx ]) + (( self . icon_size + self . padding_x ) if icons [ idx ] else 0 ) ) for idx in range ( window_count ) ] # Obey max_title_width if specified if self . max_title_width : width_boxes = [ min ( w , self . max_title_width ) for w in width_boxes ] width_sum = sum ( width_boxes ) # calculated box width are to wide for available widget space: if width_sum > width_total : # sum the width of tasks shorter than calculated average # and calculate a ratio to shrink boxes greater than width_avg width_shorter_sum = sum ([ w for w in width_boxes if w < width_avg ]) ratio = ( width_total - width_shorter_sum ) / ( width_sum - width_shorter_sum ) # determine new box widths by shrinking boxes greater than avg width_boxes = [( w if w < width_avg else w * ratio ) for w in width_boxes ] return zip ( windows , icons , names , width_boxes )","title":"calc_box_widths()"},{"location":"reference/libqtile/widget/tasklist/#libqtile.widget.tasklist.TaskList.get_taskname","text":"Get display name for given window. Depending on its state minimized, maximized and floating appropriate characters are prepended. Source code in libqtile/widget/tasklist.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def get_taskname ( self , window ): \"\"\" Get display name for given window. Depending on its state minimized, maximized and floating appropriate characters are prepended. \"\"\" state = \"\" markup_str = self . markup_normal # Enforce markup and new string format behaviour when # at least one markup_* option is used. # Mixing non markup and markup may cause problems. if ( self . markup_minimized or self . markup_maximized or self . markup_floating or self . markup_focused ): enforce_markup = True else : enforce_markup = False if window is None : pass elif window . minimized : state = self . txt_minimized markup_str = self . markup_minimized elif window . maximized : state = self . txt_maximized markup_str = self . markup_maximized elif window . floating : state = self . txt_floating markup_str = self . markup_floating elif window is window . group . current_window : markup_str = self . markup_focused window_name = window . name if window and window . name else \"?\" if callable ( self . parse_text ): try : window_name = self . parse_text ( window_name ) except : # noqa: E722 logger . exception ( \"parse_text function failed:\" ) # Emulate default widget behavior if markup_str is None if enforce_markup and markup_str is None : markup_str = \" %s{} \" % ( state ) if markup_str is not None : self . markup = True window_name = pangocffi . markup_escape_text ( window_name ) return markup_str . format ( window_name ) return \" %s%s \" % ( state , window_name )","title":"get_taskname()"},{"location":"reference/libqtile/widget/textbox/","text":"TextBox ( text = ' ' , width = bar . CALCULATED , ** config ) Bases: base . _TextBox A flexible textbox that can be updated from bound keys, scripts, and qshell. Source code in libqtile/widget/textbox.py 44 45 def __init__ ( self , text = \" \" , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , text = text , width = width , ** config ) get () Retrieve the text in a TextBox widget Source code in libqtile/widget/textbox.py 47 48 49 50 @expose_command () def get ( self ): \"\"\"Retrieve the text in a TextBox widget\"\"\" return self . text","title":"textbox"},{"location":"reference/libqtile/widget/textbox/#libqtile.widget.textbox.TextBox","text":"Bases: base . _TextBox A flexible textbox that can be updated from bound keys, scripts, and qshell. Source code in libqtile/widget/textbox.py 44 45 def __init__ ( self , text = \" \" , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , text = text , width = width , ** config )","title":"TextBox"},{"location":"reference/libqtile/widget/textbox/#libqtile.widget.textbox.TextBox.get","text":"Retrieve the text in a TextBox widget Source code in libqtile/widget/textbox.py 47 48 49 50 @expose_command () def get ( self ): \"\"\"Retrieve the text in a TextBox widget\"\"\" return self . text","title":"get()"},{"location":"reference/libqtile/widget/thermal_zone/","text":"ThermalZone ( ** config ) Bases: base . ThreadPoolText Thermal zone widget. This widget was made to read thermal zone files and transform values to human readable format. You can set zone parameter to any standard thermal zone file from /sys/class/thermal directory. Source code in libqtile/widget/thermal_zone.py 27 28 29 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( ThermalZone . defaults )","title":"thermal_zone"},{"location":"reference/libqtile/widget/thermal_zone/#libqtile.widget.thermal_zone.ThermalZone","text":"Bases: base . ThreadPoolText Thermal zone widget. This widget was made to read thermal zone files and transform values to human readable format. You can set zone parameter to any standard thermal zone file from /sys/class/thermal directory. Source code in libqtile/widget/thermal_zone.py 27 28 29 def __init__ ( self , ** config ): super () . __init__ ( \"\" , ** config ) self . add_defaults ( ThermalZone . defaults )","title":"ThermalZone"},{"location":"reference/libqtile/widget/volume/","text":"Volume ( ** config ) Bases: base . _TextBox Widget that display and change volume By default, this widget uses amixer to get and set the volume so users will need to make sure this is installed. Alternatively, users may set the relevant parameters for the widget to use a different application. If theme_path is set it draw widget as icons. Source code in libqtile/widget/volume.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"0\" , ** config ) self . add_defaults ( Volume . defaults ) self . surfaces = {} self . volume = None self . add_callbacks ( { \"Button1\" : self . mute , \"Button3\" : self . run_app , \"Button4\" : self . increase_vol , \"Button5\" : self . decrease_vol , } )","title":"volume"},{"location":"reference/libqtile/widget/volume/#libqtile.widget.volume.Volume","text":"Bases: base . _TextBox Widget that display and change volume By default, this widget uses amixer to get and set the volume so users will need to make sure this is installed. Alternatively, users may set the relevant parameters for the widget to use a different application. If theme_path is set it draw widget as icons. Source code in libqtile/widget/volume.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self , ** config ): base . _TextBox . __init__ ( self , \"0\" , ** config ) self . add_defaults ( Volume . defaults ) self . surfaces = {} self . volume = None self . add_callbacks ( { \"Button1\" : self . mute , \"Button3\" : self . run_app , \"Button4\" : self . increase_vol , \"Button5\" : self . decrease_vol , } )","title":"Volume"},{"location":"reference/libqtile/widget/wallpaper/","text":"","title":"wallpaper"},{"location":"reference/libqtile/widget/widgetbox/","text":"WidgetBox ( _widgets = None , ** config ) Bases: base . _Widget A widget to declutter your bar. WidgetBox is a widget that hides widgets by default but shows them when the box is opened. Widgets that are hidden will still update etc. as if they were on the main bar. Button clicks are passed to widgets when they are visible so callbacks will work. Widgets in the box also remain accessible via command interfaces. Widgets can only be added to the box via the configuration file. The widget is configured by adding widgets to the \"widgets\" parameter as follows:: widget.WidgetBox(widgets=[ widget.TextBox(text=\"This widget is in the box\"), widget.Memory() ] ), Source code in libqtile/widget/widgetbox.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , _widgets : list [ base . _Widget ] | None = None , ** config ): base . _Widget . __init__ ( self , bar . CALCULATED , ** config ) self . add_defaults ( WidgetBox . defaults ) self . box_is_open = False self . add_callbacks ({ \"Button1\" : self . toggle }) if _widgets : logger . warning ( \"The use of a positional argument in WidgetBox is deprecated. \" \"Please update your config to use widgets=[...].\" ) self . widgets = _widgets self . close_button_location : str if self . close_button_location not in [ \"left\" , \"right\" ]: val = self . close_button_location logger . warning ( \"Invalid value for 'close_button_location': %s \" , val ) self . close_button_location = \"left\" toggle () Toggle box state Source code in libqtile/widget/widgetbox.py 171 172 173 174 175 176 177 @expose_command () def toggle ( self ): \"\"\"Toggle box state\"\"\" self . box_is_open = not self . box_is_open self . toggle_widgets () self . set_box_label () self . bar . draw ()","title":"widgetbox"},{"location":"reference/libqtile/widget/widgetbox/#libqtile.widget.widgetbox.WidgetBox","text":"Bases: base . _Widget A widget to declutter your bar. WidgetBox is a widget that hides widgets by default but shows them when the box is opened. Widgets that are hidden will still update etc. as if they were on the main bar. Button clicks are passed to widgets when they are visible so callbacks will work. Widgets in the box also remain accessible via command interfaces. Widgets can only be added to the box via the configuration file. The widget is configured by adding widgets to the \"widgets\" parameter as follows:: widget.WidgetBox(widgets=[ widget.TextBox(text=\"This widget is in the box\"), widget.Memory() ] ), Source code in libqtile/widget/widgetbox.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , _widgets : list [ base . _Widget ] | None = None , ** config ): base . _Widget . __init__ ( self , bar . CALCULATED , ** config ) self . add_defaults ( WidgetBox . defaults ) self . box_is_open = False self . add_callbacks ({ \"Button1\" : self . toggle }) if _widgets : logger . warning ( \"The use of a positional argument in WidgetBox is deprecated. \" \"Please update your config to use widgets=[...].\" ) self . widgets = _widgets self . close_button_location : str if self . close_button_location not in [ \"left\" , \"right\" ]: val = self . close_button_location logger . warning ( \"Invalid value for 'close_button_location': %s \" , val ) self . close_button_location = \"left\"","title":"WidgetBox"},{"location":"reference/libqtile/widget/widgetbox/#libqtile.widget.widgetbox.WidgetBox.toggle","text":"Toggle box state Source code in libqtile/widget/widgetbox.py 171 172 173 174 175 176 177 @expose_command () def toggle ( self ): \"\"\"Toggle box state\"\"\" self . box_is_open = not self . box_is_open self . toggle_widgets () self . set_box_label () self . bar . draw ()","title":"toggle()"},{"location":"reference/libqtile/widget/window_count/","text":"WindowCount ( width = bar . CALCULATED , ** config ) Bases: base . _TextBox A simple widget to display the number of windows in the current group of the screen on which the widget is. Source code in libqtile/widget/window_count.py 46 47 48 49 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , width = width , ** config ) self . add_defaults ( WindowCount . defaults ) self . _count = 0 get () Retrieve the current text. Source code in libqtile/widget/window_count.py 86 87 88 89 @expose_command () def get ( self ): \"\"\"Retrieve the current text.\"\"\" return self . text","title":"window_count"},{"location":"reference/libqtile/widget/window_count/#libqtile.widget.window_count.WindowCount","text":"Bases: base . _TextBox A simple widget to display the number of windows in the current group of the screen on which the widget is. Source code in libqtile/widget/window_count.py 46 47 48 49 def __init__ ( self , width = bar . CALCULATED , ** config ): base . _TextBox . __init__ ( self , width = width , ** config ) self . add_defaults ( WindowCount . defaults ) self . _count = 0","title":"WindowCount"},{"location":"reference/libqtile/widget/window_count/#libqtile.widget.window_count.WindowCount.get","text":"Retrieve the current text. Source code in libqtile/widget/window_count.py 86 87 88 89 @expose_command () def get ( self ): \"\"\"Retrieve the current text.\"\"\" return self . text","title":"get()"},{"location":"reference/libqtile/widget/windowname/","text":"WindowName ( width = bar . STRETCH , ** config ) Bases: base . _TextBox Displays the name of the window that currently has focus Source code in libqtile/widget/windowname.py 57 58 59 def __init__ ( self , width = bar . STRETCH , ** config ): base . _TextBox . __init__ ( self , width = width , ** config ) self . add_defaults ( WindowName . defaults )","title":"windowname"},{"location":"reference/libqtile/widget/windowname/#libqtile.widget.windowname.WindowName","text":"Bases: base . _TextBox Displays the name of the window that currently has focus Source code in libqtile/widget/windowname.py 57 58 59 def __init__ ( self , width = bar . STRETCH , ** config ): base . _TextBox . __init__ ( self , width = width , ** config ) self . add_defaults ( WindowName . defaults )","title":"WindowName"},{"location":"reference/libqtile/widget/windowtabs/","text":"WindowTabs ( ** config ) Bases: base . _TextBox Displays the name of each window in the current group. Contrary to TaskList this is not an interactive widget. The window that currently has focus is highlighted. Source code in libqtile/widget/windowtabs.py 54 55 56 57 58 59 def __init__ ( self , ** config ): width = config . pop ( \"width\" , bar . STRETCH ) base . _TextBox . __init__ ( self , width = width , ** config ) self . add_defaults ( WindowTabs . defaults ) if not isinstance ( self . selected , ( tuple , list )): self . selected = ( self . selected , self . selected )","title":"windowtabs"},{"location":"reference/libqtile/widget/windowtabs/#libqtile.widget.windowtabs.WindowTabs","text":"Bases: base . _TextBox Displays the name of each window in the current group. Contrary to TaskList this is not an interactive widget. The window that currently has focus is highlighted. Source code in libqtile/widget/windowtabs.py 54 55 56 57 58 59 def __init__ ( self , ** config ): width = config . pop ( \"width\" , bar . STRETCH ) base . _TextBox . __init__ ( self , width = width , ** config ) self . add_defaults ( WindowTabs . defaults ) if not isinstance ( self . selected , ( tuple , list )): self . selected = ( self . selected , self . selected )","title":"WindowTabs"},{"location":"reference/libqtile/widget/wlan/","text":"Wlan ( ** config ) Bases: base . InLoopPollText Displays Wifi SSID and quality. Widget requirements: iwlib_. .. _iwlib: https://pypi.org/project/iwlib/ Source code in libqtile/widget/wlan.py 65 66 67 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Wlan . defaults )","title":"wlan"},{"location":"reference/libqtile/widget/wlan/#libqtile.widget.wlan.Wlan","text":"Bases: base . InLoopPollText Displays Wifi SSID and quality. Widget requirements: iwlib_. .. _iwlib: https://pypi.org/project/iwlib/ Source code in libqtile/widget/wlan.py 65 66 67 def __init__ ( self , ** config ): base . InLoopPollText . __init__ ( self , ** config ) self . add_defaults ( Wlan . defaults )","title":"Wlan"},{"location":"reference/libqtile/widget/wttr/","text":"Wttr ( ** config ) Bases: GenPollUrl Display weather widget provided by wttr.in_. .. _wttr.in: https://github.com/chubin/wttr.in/ To specify your own custom output format, use the special %-notation (example: 'My_city: %t(%f), wind: %w'): - %c Weather condition, - %C Weather condition textual name, - %h Humidity, - %t Temperature (Actual), - %f Temperature (Feels Like), - %w Wind, - %l Location, - %m Moonphase \ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18, - %M Moonday, - %p precipitation (mm), - %P pressure (hPa), - %D Dawn !, - %S Sunrise !, - %z Zenith !, - %s Sunset !, - %d Dusk !. (!times are shown in the local timezone) Add the character ~ at the beginning to get weather for some special location: ~Vostok Station or ~Eiffel Tower . Also can use IP-addresses (direct) or domain names (prefixed with @) to specify a location: @github.com , 123.456.678.123 Specify multiple locations as dictionary :: location={ 'Minsk': 'Minsk', '64.127146,-21.873472': 'Reykjavik', } Cities will change randomly every update. Source code in libqtile/widget/wttr.py 83 84 85 86 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , json = False , ** config ) self . add_defaults ( Wttr . defaults ) self . url = self . _get_url ()","title":"wttr"},{"location":"reference/libqtile/widget/wttr/#libqtile.widget.wttr.Wttr","text":"Bases: GenPollUrl Display weather widget provided by wttr.in_. .. _wttr.in: https://github.com/chubin/wttr.in/ To specify your own custom output format, use the special %-notation (example: 'My_city: %t(%f), wind: %w'): - %c Weather condition, - %C Weather condition textual name, - %h Humidity, - %t Temperature (Actual), - %f Temperature (Feels Like), - %w Wind, - %l Location, - %m Moonphase \ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18, - %M Moonday, - %p precipitation (mm), - %P pressure (hPa), - %D Dawn !, - %S Sunrise !, - %z Zenith !, - %s Sunset !, - %d Dusk !. (!times are shown in the local timezone) Add the character ~ at the beginning to get weather for some special location: ~Vostok Station or ~Eiffel Tower . Also can use IP-addresses (direct) or domain names (prefixed with @) to specify a location: @github.com , 123.456.678.123 Specify multiple locations as dictionary :: location={ 'Minsk': 'Minsk', '64.127146,-21.873472': 'Reykjavik', } Cities will change randomly every update. Source code in libqtile/widget/wttr.py 83 84 85 86 def __init__ ( self , ** config ): GenPollUrl . __init__ ( self , json = False , ** config ) self . add_defaults ( Wttr . defaults ) self . url = self . _get_url ()","title":"Wttr"}]}