{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#everything-you-need-to-know-about-qtile","title":"Everything you need to know about Qtile","text":"<p>Qtile is a full-featured, hackable tiling window manager written and configured in Python. It's available both as an X11 window manager and also as a Wayland compositor.</p> <p>This documentation is designed to help you install and configure Qtile. Once it's up and running you'll probably want to start adding your own customisations to have it running exactly the way you want.</p> <p>You'll find a lot of what you need within these docs but, if you still have some questions, you can find support in the following places:</p> <ul> <li>IRC: irc://irc.oftc.net:6667/qtile</li> <li>Discord: https://discord.gg/ehh233wCrC (Bridged with IRC)</li> <li>Q&amp;A: https://github.com/qtile/qtile/discussions/categories/q-a</li> <li>Mailing List: https://groups.google.com/group/qtile-dev</li> </ul>"},{"location":"manual/changelog/","title":"Changelog","text":"<p>Qtile x.xx.x, released XXXX-XX-XX:     !!! breaking changes !!!       - this release drops support for python 3.9       - deleted the (very old) libqtile/command_* deprecation wrappers       - SIGUSR2 no longer restarts qtile, instead it dumps stack traces       - lazy."},{"location":"manual/changelog/#vim-set-ts4-sw4-sts4-et","title":"Changelog","text":""},{"location":"manual/contributing/","title":"Contributing","text":""},{"location":"manual/contributing/#reporting-bugs","title":"Reporting bugs","text":"<p>Perhaps the easiest way to contribute to Qtile is to report any bugs you run into on the GitHub issue tracker.</p> <p>Useful bug reports are ones that get bugs fixed. A useful bug report normally has two qualities:</p> <ol> <li> <p>Reproducible. If your bug is not reproducible it will never get fixed.    You should clearly mention the steps to reproduce the bug. Do not assume or    skip any reproducing step. Describe the issue, step-by-step, so that it is    easy to reproduce and fix.</p> </li> <li> <p>Specific. Do not write an essay about the problem. Be specific and to the    point. Try to summarize the problem in a succinct manner. Do not combine multiple problems even if they seem to be similar. Write    different reports for each problem.</p> </li> </ol> <p>Ensure to include any appropriate log entries from <code>~/.local/share/qtile/qtile.log</code> and/or <code>~/.xsession-errors</code>! Sometimes, an <code>xtrace</code> is requested. If that is the case, refer to capturing an xtrace.</p>"},{"location":"manual/contributing/#writing-code","title":"Writing code","text":"<p>To get started writing code for Qtile, check out our guide to Hacking on Qtile. A more detailed page on creating widgets is available here.</p> <p>Important</p> <p> Use a separate git branch to make rebasing easy. Ideally, you would <code>git checkout -b &lt;my_feature_branch_name&gt;</code> before starting your work.</p> <p>See also: using <code>git</code>.</p>"},{"location":"manual/contributing/#submit-a-pull-request","title":"Submit a pull request","text":"<p>You've done your hacking and are ready to submit your patch to Qtile. Great! Now it's time to submit a pull request to our issue tracker on GitHub.</p> <p>Important</p> <p> Pull requests are not considered complete until they include all of the following:</p> <ul> <li>Code that conforms to our linters and formatters.   Run <code>pre-commit install</code> to install pre-commit hooks that will   make sure your code is compliant before any commit.</li> <li>Unit tests that pass locally and in our CI environment (More below).   Please add unit tests to ensure that your code works and stays working!</li> <li>Documentation updates on an as needed basis.</li> <li>A <code>qtile migrate</code> migration is required for config-breaking changes.   See qtile-migrate    for current migrations and see below for further information.</li> <li>Code that does not include unrelated changes. Examples for this are   formatting changes, replacing quotes or whitespace in other parts of the   code or \"fixing\" linter warnings popping up in your editor on existing   code. Do not include anything like the above!</li> <li>Widgets don't need to catch their own exceptions, or introduce their   own polling infrastructure. The code in <code>libqtile.widget.base.*</code> does   all of this. Your widget should generally only include whatever   parsing/rendering code is necessary, any other changes should go at the   framework level. Make sure to double-check that you are not   re-implementing parts of <code>libqtile.widget.base</code>.</li> <li>Commit messages are more important that Github PR notes, since this is   what people see when they are spelunking via <code>git blame</code>. Please include   all relevant detail in the actual git commit message (things like exact   stack traces, copy/pastes of discussion in IRC/mailing lists, links to   specifications or other API docs are all good). If your PR fixes a Github   issue, it might also be wise to link to it with <code>#1234</code> in the commit   message.</li> <li>PRs with multiple commits should not introduce code in one patch to   then change it in a later patch. Please do a patch-by-patch review of your   PR, and make sure each commit passes CI and makes logical sense on its   own. In other words: do introduce your feature in one commit and maybe   add the tests and documentation in a seperate commit. Don't push commits   that partially implement a feature and are basically broken.</li> </ul> <p>Note</p> <p>Others might ban force-pushes, we allow them and prefer them over incomplete commits or commits that have a bad and meaningless commit description.</p> <p>Feel free to add your contribution (no matter how small) to the appropriate place in the CHANGELOG as well!</p>"},{"location":"manual/contributing/#unit-testing","title":"Unit testing","text":"<p>We must test each unit of code to ensure that new changes to the code do not break existing functionality. The framework we use to test Qtile is pytest. How pytest works is outside of the scope of this documentation, but there are tutorials online that explain how it is used.</p> <p>Our tests are written inside the <code>test</code> folder at the top level of the repository. Reading through these, you can get a feel for the approach we take to test a given unit. Most of the tests involve an object called <code>manager</code>. This is the test manager (defined in test/helpers.py), which exposes a command client at <code>manager.c</code> that we use to test a Qtile instance running in a separate thread as if we were using a command client from within a running Qtile session.</p> <p>For any Qtile-specific question on testing, feel free to ask on our issue tracker or on IRC (#qtile on irc.oftc.net).</p>"},{"location":"manual/contributing/#running-tests-locally","title":"Running tests locally","text":"<p>This section gives an overview about <code>tox</code> so that you don't have to search its documentation just to get started.</p> <p>Checks are grouped in so-called <code>environments</code>. Some of them are configured to check that the code works (the usual unit test, e.g. <code>py39</code>, <code>pypy3</code>), others make sure that your code conforms to the style guide (<code>pep8</code>, <code>codestyle</code>, <code>mypy</code>). A third kind of test verifies that the documentation and packaging processes work (<code>docs</code>, <code>docstyle</code>, <code>packaging</code>).</p> <p>We have configured <code>tox</code> to run the full suite of tests whenever a pull request is submitted/updated. To reduce the amount of time taken by these tests, we have created separate environments for both python versions and backends (e.g. tests for x11 and wayland run in parallel for each python version that we currently support).</p> <p>These environments were designed with automation in mind so there are separate <code>test</code> environments which should be used for running qtile's tests locally. By default, tests will only run on x11 backend (but see below for information on how to set the backend).</p> <p>The following examples show how to run tests locally:</p> <ul> <li>To run the functional tests, use <code>tox -e test</code>. You can specify to only   run a specific test file or even a specific test within that file with   the following commands:</li> </ul> <pre><code>tox -e test # Run all tests in default python version\ntox -e test -- -x test/widgets/test_widgetbox.py  # run a single file\ntox -e test -- -x test/widgets/test_widgetbox.py::test_widgetbox_widget\ntox -e test -- --backend=wayland --backend=x11  # run tests on both backends\ntox -e test-both  # same as above \ntox -e test-wayland  # Just run tests on wayland backend\n</code></pre> <ul> <li>To run style and building checks, use <code>tox -e docs,packaging,pep8,...</code>.   You can use <code>-p auto</code> to run the environments in parallel.</li> </ul> <p>IMPORTANT:   The CI is configured to run all the environments. Hence it can be time-   consuming to make all the tests pass. As stated above, pull requests   that don't pass the tests are considered incomplete. Don't forget that   this does not only include the functionality, but the style, typing   annotations (if necessary) and documentation as well!</p>"},{"location":"manual/contributing/#writing-migrations","title":"Writing migrations","text":"<p>Migrations are needed when a commit introduces a change which makes a breaking change to a user's config. Examples include renaming classes, methods, arguments and moving modules or class definitions.</p> <p>Where these changes are made, it is strongly encouraged to support the old syntax where possible and warn the user about the deprecations. </p> <p>Whether or not a deprecation warning is provided, a migration script should be provided that will modify the user's config when they run <code>qtile migrate</code>.</p> <p>Click here for detailed instructions on how to migrate.</p>"},{"location":"manual/faq/","title":"Frequently Asked Questions","text":""},{"location":"manual/faq/#why-the-name-qtile","title":"Why the name Qtile?","text":"<p>Users often wonder, why the Q? Does it have something to do with Qt? No. Below is an IRC excerpt where cortesi explains the great trial that ultimately brought Qtile into existence, thanks to the benevolence of the Open Source Gods. Praise be to the OSG!</p> <pre><code>ramnes:  what does Qtile mean?\nramnes:  what's the Q?\n@tych0:  ramnes: it doesn't :)\n@tych0:  cortesi was just looking for the first letter that wasn't registered\n            in a domain name with \"tile\" as a suffix\n@tych0:  qtile it was :)\ncortesi: tych0, dx: we really should have something more compelling to\n            explain the name. one day i was swimming at manly beach in sydney,\n            where i lived at the time. suddenly, i saw an enormous great white\n            right beside me. it went for my leg with massive, gaping jaws, but\n            quick as a flash, i thumb-punched it in both eyes. when it reared\n            back in agony, i saw that it had a jagged, gnarly scar on its\n            stomach... a scar shaped like the letter \"Q\".\ncortesi: while it was distracted, i surfed a wave to shore. i knew that i\n            had to dedicate my next open source project to the ocean gods, in\n            thanks for my lucky escape. and thus, qtile got its name...\n</code></pre>"},{"location":"manual/faq/#when-i-first-start-xtermurxvtrxvt-containing-an-instance-of-vim-i-see-text-and-layout-corruption-what-gives","title":"When I first start xterm/urxvt/rxvt containing an instance of Vim, I see text and layout corruption. What gives?","text":"<p>Vim is not handling terminal resizes correctly. You can fix the problem by starting your xterm with the \"-wf\" option, like so:</p> <pre><code>xterm -wf -e vim\n</code></pre> <p>Alternatively, you can just cycle through your layouts a few times, which usually seems to fix it.</p>"},{"location":"manual/faq/#how-do-i-know-which-modifier-specification-maps-to-which-key","title":"How do I know which modifier specification maps to which key?","text":"<p>To see a list of modifier names and their matching keys, use the <code>xmodmap</code> command. On my system, the output looks like this:</p> <pre><code>$ xmodmap\nxmodmap:  up to 3 keys per modifier, (keycodes in parentheses):\n\nshift       Shift_L (0x32),  Shift_R (0x3e)\nlock        Caps_Lock (0x9)\ncontrol     Control_L (0x25),  Control_R (0x69)\nmod1        Alt_L (0x40),  Alt_R (0x6c),  Meta_L (0xcd)\nmod2        Num_Lock (0x4d)\nmod3\nmod4        Super_L (0xce),  Hyper_L (0xcf)\nmod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)\n</code></pre>"},{"location":"manual/faq/#my-pointer-mouse-cursor-isnt-the-one-i-expect-it-to-be","title":"My \"pointer mouse cursor\" isn't the one I expect it to be!","text":"<p>Qtile should set the default cursor to left_ptr, you must install xcb-util-cursor if you want support for themed cursors.</p>"},{"location":"manual/faq/#libreoffice-menus-dont-appear-or-dont-stay-visible","title":"LibreOffice menus don't appear or don't stay visible","text":"<p>A workaround for problem with the mouse in libreoffice is setting the environment variable \u00bbSAL_USE_VCLPLUGIN=gen\u00ab. It is dependent on your system configuration as to where to do this. e.g. ArchLinux with libreoffice-fresh in /etc/profile.d/libreoffice-fresh.sh.</p>"},{"location":"manual/faq/#how-can-i-get-my-groups-to-stick-to-screens","title":"How can I get my groups to stick to screens?","text":"<p>This behaviour can be replicated by configuring your keybindings to not move groups between screens. For example if you want groups <code>\"1\"</code>, <code>\"2\"</code> and <code>\"3\"</code> on one screen and <code>\"q\"</code>, <code>\"w\"</code>, and <code>\"e\"</code> on the other, instead of binding keys to <code>lazy.group[name].toscreen()</code>, use this:</p> <pre><code>groups = [\n    # Screen affinity here is used to make\n    # sure the groups startup on the right screens\n    Group(name=\"1\", screen_affinity=0),\n    Group(name=\"2\", screen_affinity=0),\n    Group(name=\"3\", screen_affinity=0),\n    Group(name=\"q\", screen_affinity=1),\n    Group(name=\"w\", screen_affinity=1),\n    Group(name=\"e\", screen_affinity=1),\n]\n\ndef go_to_group(name: str):\n    def _inner(qtile):\n        if len(qtile.screens) == 1:\n            qtile.groups_map[name].toscreen()\n            return\n\n        if name in '123':\n            qtile.focus_screen(0)\n            qtile.groups_map[name].toscreen()\n        else:\n            qtile.focus_screen(1)\n            qtile.groups_map[name].toscreen()\n\n    return _inner\n\nfor i in groups:\n    keys.append(Key([mod], i.name, lazy.function(go_to_group(i.name))))\n</code></pre> <p>To be able to move windows across these groups which switching groups, a similar function can be used:</p> <p><pre><code>def go_to_group_and_move_window(name: str):\n    def _inner(qtile):\n        if len(qtile.screens) == 1:\n            qtile.current_window.togroup(name, switch_group=True)\n            return\n\n        if name in \"123\":\n            qtile.current_window.togroup(name, switch_group=False)\n            qtile.focus_screen(0)\n            qtile.groups_map[name].toscreen()\n        else:\n            qtile.current_window.togroup(name, switch_group=False)\n            qtile.focus_screen(1)\n            qtile.groups_map[name].toscreen()\n\n    return _inner\n\nfor i in groups:\n    keys.append(Key([mod, \"shift\"], i.name, lazy.function(go_to_group_and_move_window(i.name))))\n</code></pre> If you use the <code>GroupBox</code> widget you can make it reflect this behaviour:</p> <pre><code>groupbox1 = widget.GroupBox(visible_groups=['1', '2', '3'])\ngroupbox2 = widget.GroupBox(visible_groups=['q', 'w', 'e'])\n</code></pre> <p>And if you jump between having single and double screens then modifying the visible groups on the fly may be useful:</p> <pre><code>@hook.subscribe.screens_reconfigured\nasync def _():\n    if len(qtile.screens) &gt; 1:\n        groupbox1.visible_groups = ['1', '2', '3']\n    else:\n        groupbox1.visible_groups = ['1', '2', '3', 'q', 'w', 'e']\n    if hasattr(groupbox1, 'bar'):\n        groupbox1.bar.draw()\n</code></pre>"},{"location":"manual/faq/#where-can-i-find-example-configurations-and-other-scripts","title":"Where can I find example configurations and other scripts?","text":"<p>Please visit our qtile-examples repo which contains examples of users' configurations, scripts and other useful links.</p>"},{"location":"manual/faq/#where-are-the-log-files-for-qtile","title":"Where are the log files for Qtile?","text":"<p>The log files for qtile are at <code>~/.local/share/qtile/qtile.log</code>.</p>"},{"location":"manual/faq/#why-do-i-get-an-attributeerror-when-building-qtile","title":"Why do I get an <code>AttributeError</code> when building Qtile?","text":"<p>If you see this message: <code>AttributeError: cffi library 'libcairo.so.2' has no function, constant or global variable named 'cairo_xcb_surface_create'</code> when building Qtile then your Cairo version lacks XCB support.</p> <p>If it happens, it might be because the <code>cairocffi</code> and <code>xcffib</code> dependencies were installed in the wrong order.</p> <p>To fix this:</p> <ol> <li>uninstall them from your environment: with <code>pip uninstall cairocffi xcffib</code>    if using a virtualenv, or with your system package-manager if you installed    the development version of Qtile system-wide.</li> <li> <p>re-install them sequentially (again, with pip or with your package-manager):</p> <pre><code>pip install xcffib\npip install --no-cache-dir cairocffi\n</code></pre> </li> </ol> <p>See this issue comment for more information.</p> <p>If you are using your system package-manager and the issue still happens, the packaging of <code>cairocffi</code> might be broken for your distribution. Try to contact the persons responsible for <code>cairocffi</code>'s packaging on your distribution, or to install it from the sources with <code>xcffib</code> available.</p>"},{"location":"manual/faq/#how-can-i-match-the-bar-with-picom","title":"How can I match the bar with picom?","text":"<p>You can use <code>\"QTILE_INTERNAL:32c = 1\"</code> in your picom.conf to match the bar. This will match all internal Qtile windows, so if you want to avoid that or to target bars individually, you can set a custom property and match that:</p> <pre><code>mybar = Bar(...)\n\n@hook.subscribe.startup\ndef _():\n    mybar.window.window.set_property(\"QTILE_BAR\", 1, \"CARDINAL\", 32)\n</code></pre> <p>This would enable matching on <code>mybar</code>'s window using <code>\"QTILE_BAR:32c = 1\"</code>. See #2526 and #1515 for more discussion.</p>"},{"location":"manual/faq/#why-do-get-a-warning-that-fonts-cannot-be-loaded","title":"Why do get a warning that fonts cannot be loaded?","text":"<p>When installing Qtile on a new system, when running the test suite or the Xephyr script (<code>./scripts/xephyr</code>), you might see errors in the output like the following or similar:</p> <ul> <li> <p>Xephyr script:</p> <pre><code>xterm: cannot load font \"-Misc-Fixed-medium-R-*-*-13-120-75-75-C-120-ISO10646-1\"\nxterm: cannot load font \"-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso10646-1\"\n</code></pre> </li> <li> <p><code>pytest</code></p> <pre><code>---------- Captured stderr call ----------\nWarning: Cannot convert string \"8x13\" to type FontStruct\nWarning: Unable to load any usable ISO8859 font\nWarning: Unable to load any usable ISO8859 font\nError: Aborting: no font found\n\n-------- Captured stderr teardown --------\nQtile exited with exitcode: -9\n</code></pre> </li> </ul> <p>If it happens, it might be because you're missing fonts on your system.</p> <p>On ArchLinux, you can fix this by installing <code>xorg-fonts-misc</code>:</p> <pre><code>```bash\nsudo pacman -S xorg-fonts-misc\n```\n</code></pre> <p>Try to search for \"xorg fonts misc\" with your distribution name on the internet to find how to install them.</p>"},{"location":"manual/faq/#ive-upgraded-and-qtiles-broken-what-do-i-do","title":"I've upgraded and Qtile's broken. What do I do?","text":"<p>If you've recently upgraded, the first thing to do is check the changelog and see if any breaking changes were made.</p> <p>Next, check your log file (see above) to see if any error messages explain what the problem is.</p> <p>If you're still stuck, come and ask for help on Discord, IRC or GitHub.</p>"},{"location":"manual/hacking/","title":"Hacking on Qtile","text":""},{"location":"manual/hacking/#requirements","title":"Requirements","text":"<p>Here are Qtile's additional dependencies that may be required for tests:</p> Dependency Ubuntu Package Needed for pytest python3-pytest Running tests pre-commit pre-commit Running linters PyGObject python3-gi Running tests (test windows) Xephyr xserver-xephyr Testing with X11 backend (optional, see below) mypy python3-mypy Testing <code>qtile check</code> (optional) imagemagick&gt;=6.8 imagemagick <code>test/test_images*</code> (optional) gtk-layer-shell libgtk-layer-shell0 Testing notification windows in Wayland (optional) dbus-launch dbus-x11 Testing dbus-using widgets (optional) notifiy-send libnotify-bin Testing <code>Notify</code> widget (optional) xvfb xvfb Testing with X11 headless (optional)"},{"location":"manual/hacking/#backends","title":"Backends","text":"<p>The test suite can be run using the X11 or Wayland backend, or both.  By default, only the X11 backend is used for tests. To test a single backend or both backends, specify as arguments to pytest:</p> <pre><code>pytest --backend wayland  # Test just Wayland backend\npytest --backend x11 --backend wayland  # Test both\n</code></pre> <p>Testing with the X11 backend requires Xephyr (and xvfb for headless mode) in addition to the core dependencies.</p>"},{"location":"manual/hacking/#building-cffi-module","title":"Building cffi module","text":"<p>Qtile ships with a small in-tree pangocairo binding built using cffi, <code>pangocffi.py</code>, and also binds to xcursor with cffi.  The bindings are not built at run time and will have to be generated manually when the code is downloaded or when any changes are made to the cffi library.  This can be done by calling:</p> <pre><code>./scripts/ffibuild\n</code></pre>"},{"location":"manual/hacking/#setting-up-the-environment","title":"Setting up the environment","text":"<p>In the root of the project, run <code>./dev.sh</code>. It will create a virtualenv called <code>venv</code>.</p> <p>Activate this virtualenv with <code>. venv/bin/activate</code>. Deactivate it with the <code>deactivate</code> command.</p>"},{"location":"manual/hacking/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, you will also need to install graphviz.</p> <p>Go into the <code>docs/</code> directory and run <code>pip install -r requirements.txt</code>.</p> <p>Build the documentation with <code>make html</code>.</p> <p>Check the result by opening <code>_build/html/index.html</code> in your browser.</p> <p>Note</p> <p> To speed up local testing, screenshots are not generated each time the documentation is built.</p> <p>You can enable screenshots by setting the <code>QTILE_BUILD_SCREENSHOTS</code> environmental variable at build time e.g. <code>QTILE_BUILD_SCREENSHOTS=1 make html</code>. You can also export the variable so it will apply to all local builds <code>export QTILE_BUILD_SCREENSHOTS=1</code> (but remember to unset it if you want to skip building screenshots).</p>"},{"location":"manual/hacking/#development-and-testing","title":"Development and testing","text":"<p>In practice, the development cycle looks something like this:</p> <ol> <li>make minor code change</li> <li>run appropriate test: <code>pytest tests/test_module.py</code> or <code>pytest -k PATTERN</code></li> <li>GOTO 1, until hackage is complete</li> <li>run entire test suite to make sure you didn't break anything else: <code>pytest</code></li> <li>try to commit, get changes and feedback from the pre-commit hooks</li> <li>GOTO 5, until your changes actually get committed</li> </ol> <p>Tests and pre-commit hooks will be run by our CI on every pull request as well so you can see whether or not your contribution passes.</p>"},{"location":"manual/hacking/#coding-style","title":"Coding style","text":"<p>While not all of our code follows PEP8, we do try to adhere to it where possible. All new code should be PEP8 compliant.</p> <p>The <code>make lint</code> command (or <code>pre-commit run -a</code>) will run our linters and formatters with our configuration over the whole libqtile to ensure your patch complies with reasonable formatting constraints. We also request that git commit messages follow the standard format.</p>"},{"location":"manual/hacking/#logging","title":"Logging","text":"<p>Logs are important to us because they are our best way to see what Qtile is doing when something abnormal happens. However, our goal is not to have as many logs as possible, as this hinders readability. What we want are relevant logs.</p> <p>To decide which log level to use, refer to the following scenarios:</p> <ul> <li> <p>Error</p> <p>a problem affects the behavior of Qtile in a way that is noticeable to   the end user, and we can't work around it.</p> </li> <li> <p>Warning</p> <p>a problem causes Qtile to operate in a suboptimal manner.</p> </li> <li> <p>Info</p> <p>the state of Qtile has changed.</p> </li> <li> <p>Debug</p> <p>information is worth giving to help the developer better understand   which branch the process is in.</p> </li> </ul> <p>Be careful not to overuse DEBUG and clutter the logs. No information should be duplicated between two messages.</p> <p>Also, keep in mind that any other level than DEBUG is aimed at users who don't necessarily have advanced programming knowledge; adapt your message accordingly. If it can't make sense to your grandma, it's probably meant to be a DEBUG message.</p>"},{"location":"manual/hacking/#deprecation-policy","title":"Deprecation policy","text":"<p>When a widget API is changed, you should deprecate the change using <code>libqtile.widget.base.deprecated</code> to warn users, in addition to adding it to the appropriate place in the changelog. We will typically remove deprecated APIs one tag after they are deprecated.</p>"},{"location":"manual/hacking/#using-xephyr","title":"Using Xephyr","text":"<p>Qtile has a very extensive test suite, using the Xephyr nested X server. When tests are run, a nested X server with a nested instance of Qtile is fired up, and then tests interact with the Qtile instance through the client API. The fact that we can do this is a great demonstration of just how completely scriptable Qtile is. In fact, Qtile is designed expressly to be scriptable enough to allow unit testing in a nested environment.</p> <p>The Qtile repo includes a tiny helper script to let you quickly pull up a nested instance of Qtile in Xephyr, using your current configuration. Run it from the top-level of the repository, like this:</p> <pre><code>./scripts/xephyr\n</code></pre> <p>Change the screen size by setting the <code>SCREEN_SIZE</code> environment variable. Default: 800x600. Example:</p> <pre><code>SCREEN_SIZE=1920x1080 ./scripts/xephyr\n</code></pre> <p>Change the log level by setting the <code>LOG_LEVEL</code> environment variable. Default: INFO. Example:</p> <pre><code>LOG_LEVEL=DEBUG ./scripts/xephyr\n</code></pre> <p>The script will also pass any additional options to Qtile. For example, you can use a specific configuration file like this:</p> <pre><code>./scripts/xephyr -c ~/.config/qtile/other_config.py\n</code></pre> <p>Once the Xephyr window is running and focused, you can enable capturing the keyboard shortcuts by hitting Control+Shift. Hitting them again will disable the capture and let you use your personal keyboard shortcuts again.</p> <p>You can close the Xephyr window by enabling the capture of keyboard shortcuts and hit Mod4+Control+Q. Mod4 (or Mod) is usually the Super key (or Windows key). You can also close the Xephyr window by running <code>qtile cmd-obj -o cmd -f shutdown</code> in a terminal (from inside the Xephyr window of course).</p> <p>You don't need to run the Xephyr script in order to run the tests as the test runner will launch its own Xephyr instances.</p>"},{"location":"manual/hacking/#second-x-session","title":"Second X Session","text":"<p>Some users prefer to test Qtile in a second, completely separate X session: Just switch to a new tty and run <code>startx</code> normally to use the <code>~/.xinitrc</code> X startup script.</p> <p>It's likely though that you want to use a different, customized startup script for testing purposes, for example <code>~/.config/qtile/xinitrc</code>. You can do so by launching X with:</p> <pre><code>  startx ~/.config/qtile/xinitrc\n</code></pre> <p><code>startx</code> deals with multiple X sessions automatically. If you want to use <code>xinit</code> instead, you need to first copy <code>/etc/X11/xinit/xserverrc</code> to <code>~/.xserverrc</code>; when launching it, you have to specify a new session number:</p> <pre><code>xinit ~/.config/qtile/xinitrc -- :1\n</code></pre> <p>Examples of custom X startup scripts are available in qtile-examples.</p>"},{"location":"manual/hacking/#debugging-in-pycharm","title":"Debugging in PyCharm","text":"<p>Make sure to have all the requirements installed and your development environment setup.</p> <p>PyCharm should automatically detect the <code>venv</code> virtualenv when opening the project. If you are using another viirtualenv, just instruct PyCharm to use it in <code>Settings -&gt; Project: qtile -&gt; Project interpreter</code>.</p> <p>In the project tree, on the left, right-click on the <code>libqtile</code> folder, and click on <code>Mark Directory as -&gt; Sources Root</code>.</p> <p>Next, add a Configuration using a Python template with these fields:</p> <ul> <li>Script path: <code>bin/qtile</code>, or the absolute path to it</li> <li>Parameters: <code>-c libqtile/resources/default_config.py</code>,   or nothing if you want to use your own config file in <code>~/.config/qtile/config.py</code></li> <li>Environment variables: <code>PYTHONUNBUFFERED=1;DISPLAY=:1</code></li> <li>Working directory: the root of the project</li> <li>Add contents root to PYTHONPATH: yes</li> <li>Add source root to PYTHONPATH: yes</li> </ul> <p>Then, in a terminal, run:</p> <pre><code>Xephyr +extension RANDR -screen 1920x1040 :1 -ac &amp;\n</code></pre> <p>Note that we used the same display, <code>:1</code>, in both the terminal command and the PyCharm configuration environment variables. Feel free to change the screen size to fit your own screen.</p> <p>Finally, place your breakpoints in the code and click on <code>Debug</code>!</p> <p>Once you finished debugging, you can close the Xephyr window with <code>kill PID</code> (use the <code>jobs</code> builtin to get its PID).</p>"},{"location":"manual/hacking/#debugging-in-vscode","title":"Debugging in VSCode","text":"<p>Make sure to have all the requirements installed and your development environment setup.</p> <p>Open the root of the repo in VSCode.  If you have created it, VSCode should detect the <code>venv</code> virtualenv, if not, select it.</p> <p>Create a launch.json file with the following lines.</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n      {\n          \"name\": \"Python: Qtile\",\n          \"type\": \"python\",\n          \"request\": \"launch\",\n          \"program\": \"${workspaceFolder}/bin/qtile\",\n          \"cwd\": \"${workspaceFolder}\",\n          \"args\": [\"-c\", \"libqtile/resources/default_config.py\"],\n          \"console\": \"integratedTerminal\",\n          \"env\": {\"PYTHONUNBUFFERED\":\"1\", \"DISPLAY\":\":1\"}\n      }\n  ]\n}\n</code></pre> <p>Then, in a terminal, run:</p> <pre><code>Xephyr +extension RANDR -screen 1920x1040 :1 -ac &amp;\n</code></pre> <p>Note that we used the same display, <code>:1</code>, in both the terminal command and the VSCode configuration environment variables.  Then <code>debug</code> usually in VSCode. Feel free to change the screen size to fit your own screen.</p>"},{"location":"manual/hacking/#resources","title":"Resources","text":"<p>Here are a number of resources that may come in handy:</p> <ul> <li>Inter-Client Conventions Manual</li> <li>Extended Window Manager Hints</li> <li>A reasonable basic Xlib Manual</li> </ul>"},{"location":"manual/how-to-migrate/","title":"How to migrate","text":""},{"location":"manual/how-to-migrate/#how-to-write-a-migration-script","title":"How to write a migration script","text":"<p>Qtile's migration scripts should provide two functions:</p> <ul> <li>Update config files to fix any breaking changes introduced by a commit</li> <li>Provide linting summary of errors in existing configs</li> </ul> <p>To do this, we use LibCST to parse the config file and make changes as appropriate. Basic tips for using <code>LibCST</code> are included below but it is recommended that you read their documentation to familiarise yourself with the available functionalities.</p>"},{"location":"manual/how-to-migrate/#stucture-of-a-migration-file","title":"Stucture of a migration file","text":"<p>Migrations should be saved as a new file in <code>libqtile/scripts/migrations</code>.</p> <p>A basic migration will look like this:</p> <pre><code>from libqtile.scripts.migrations._base import MigrationTransformer, _QtileMigrator, add_migration\n\n\nclass MyMigration(MigrationTransformer):\n    \"\"\"The class that actually modifies the code.\"\"\"\n    ...\n\n\nclass Migrator(_QtileMigrator):\n    ID = \"MyMigrationName\"\n    SUMMARY = \"Summary of migration.\"\n    HELP = \"\"\"\n    Longer text explaining purpose of the migration and, ideally,\n    giving code examples.\n    \"\"\"\n    AFTER_VERSION = \"0.22.1\"\n    TESTS = []\n\n    visitor = MyMigration\n\n\nadd_migration(Migrator)\n</code></pre>"},{"location":"manual/how-to-migrate/#providing-details-about-the-migration","title":"Providing details about the migration","text":"<p>The purpose of <code>Migrator</code> class in the code above is to provide the information about the migration.</p> <p>It is important that the information is as helpful as possible as it is used in multiple places.</p> <ul> <li>The <code>ID</code> attribute is a short, unique name to identify the migration. This allows users to select   specific migrations to run via <code>qtile migrate --run-migrations ID</code>.</li> <li>The <code>SUMMARY</code> attribute is used to provide a brief summary of the migration and is used when   a user runs <code>qtile migrate --list-migrations</code>. It is also used in the documentation.</li> <li>Similarly, the <code>HELP</code> attribute is used for the script (<code>qtie migrate --info ID</code>) and the   documentation. This text should be longer and can include example code. As it is used in the documentation,   it should use RST syntax (e.g. <code>.. code:: python</code> for codeblocks etc.).</li> <li><code>AFTER_VERSION</code> should be set the name of the current release. This allows users to filter migrations to   those that were added after the last release.</li> <li>The <code>visitor</code> attribute is a link to the class definition (not and instance of the class) for the   transformer that you wish to use.</li> <li>The <code>add_migration</code> call at the end is required to ensure the migration is loaded into the list of   available migrations.</li> <li>See below for details on <code>TESTS</code>.</li> </ul>"},{"location":"manual/how-to-migrate/#how-migrations-are-run","title":"How migrations are run","text":"<p>You are pretty much free to transform the code as you see fit. By default, the script will run the <code>visit</code> method on the parsed code and will pass the <code>visitor</code> attribute of the <code>_QtileMigrator</code> class object. Therefore, if all your transformations can be performed in a single visitor, it is not necessary to do anything further in the <code>Migrator</code> class.</p> <p>However, if you want to run mutiple visitors, transformers, codemods, this is possible by overriding the <code>run</code> method of the <code>_QtileMigrator</code> class. For example, the <code>RemoveCmdPrefix</code> migrator has the following code:</p> <pre><code>def run(self, original):\n    # Run the base migrations\n    transformer = CmdPrefixTransformer()\n    updated = original.visit(transformer)\n    self.update_lint(transformer)\n\n    # Check if we need to add an import line\n    if transformer.needs_import:\n        # We use the built-in visitor to add the import\n        context = codemod.CodemodContext()\n        AddImportsVisitor.add_needed_import(\n            context, \"libqtile.command.base\", \"expose_command\"\n        )\n        visitor = AddImportsVisitor(context)\n\n        # Run the visitor over the updated code\n        updated = updated.visit(visitor)\n\n    return original, updated\n</code></pre> <p>In this migration, it may be required to add an import statement. <code>LibCST</code> has a built-in transformation for doing this so we can run that after our own transformation has been performed.</p> <p>Important</p> <p>The <code>run</code> method must return a tuple of the original code and the updated code.</p>"},{"location":"manual/how-to-migrate/#transforming-the-code","title":"Transforming the code","text":"<p>It is recommended that you use a transformed to update the code. For convenience, a <code>MigrationTransformer</code> class is defined in <code>libqtile.scripts.migrations._base</code>. This class definition includes some metadata information and a <code>lint</code> method for outputting details of errors.</p> <p>Let's look at an example transformer to understand how the migration works. The code below shows how to change a positional argument to a keyword argument in the <code>WidgetBox</code> widget.</p> <pre><code>class WidgetboxArgsTransformer(MigrationTransformer):\n    @m.call_if_inside(\n        m.Call(func=m.Name(\"WidgetBox\")) | m.Call(func=m.Attribute(attr=m.Name(\"WidgetBox\")))\n    )\n    @m.leave(m.Arg(keyword=None))\n    def update_widgetbox_args(self, original_node, updated_node) -&gt; cst.Arg:\n        \"\"\"Changes positional  argumentto 'widgets' kwargs.\"\"\"\n        self.lint(\n            original_node,\n            \"The positional argument should be replaced with a keyword argument named 'widgets'.\",\n        )\n        return updated_node.with_changes(keyword=cst.Name(\"widgets\"), equal=EQUALS_NO_SPACE)\n</code></pre> <p>Our class (which inherits from <code>MigrationTransformer</code>) defines a single method to perform the transformation. We take advantage of LibCST<code>and its</code>Matchers to narrow the scope of when the transformation is run.</p> <p>We are looking to modify an argument so we use the <code>@m.leave(m.Arg())</code> decorator to call the function at end of parsing an argument. We can restrict when this is called by specify <code>m.Arg(keyword=None)</code> so that it is only called for positional arguments. Furthermore, as we only want this called for <code>WidgetBox</code> instantiation lines, we add an additional decorator <code>@m.call_if_inside(m.Call())</code>. This ensures the method is only called when we're in a call. On its own, that's not helpful as args would  almost always be part of a call. However, we can say we only want to match calls to <code>WidgetBox</code>. The reason for the long syntax above is that <code>LibCST</code> parses <code>WidgetBox()</code> and <code>widget.WidgetBox()</code> differently. In the first one, <code>WidgetBox</code> is in the <code>func</code> property of the call. However, in the second, the <code>func</code> is an <code>Attribute</code> as it is a dotted name and so we need to check the <code>attr</code> property.</p> <p>The decorated method takes two arguments, <code>original_mode</code> and <code>updated_node</code> (note: The <code>original_node</code> should not be modified). The method should also confirm the return type.</p> <p>The above method provides a linting message by calling <code>self.lint</code> and passing the original node and a helpful message.</p> <p>Finally, the method updates the code by calling <code>updated_node.with_changes()</code>. In this instance, we add a keyword (<code>\"widgets\"</code>) to the argument. We also remove spaces around the equals sign as these are added by default by <code>LibCST</code>. The updated node is returned.</p>"},{"location":"manual/how-to-migrate/#helper-classes","title":"Helper classes","text":"<p>Helper classes are provided for common transformations.</p> <ul> <li> <p><code>RenamerTransformer</code> will update all instances of a name, replacing it with another. The class will   also handle the necessary linting.</p> <pre><code>class RenameHookTransformer(RenamerTransformer):\n    from_to = (\"window_name_change\", \"client_name_updated\")\n</code></pre> </li> </ul>"},{"location":"manual/how-to-migrate/#testing-the-migration","title":"Testing the migration","text":"<p>All migrations must be tested, ideally with a number of scenarios to confirm that the migration works as expected.</p> <p>Unlike other tests, the tests for the migrations are defined within the <code>TESTS</code> attribute.</p> <p>This is a list that should take a <code>Check</code>, <code>Change</code> or <code>NoChange</code> object (all are imported from <code>libqtile.scripts.migrations._base</code>).</p> <p>A <code>Change</code> object needs two parameters, the input code and the expected output. A <code>NoChange</code> object just defines the input (as the output should be the same).</p> <p>A <code>Check</code> object is identical to <code>Change</code> however, when running the test suite, the migrated code will be verified with <code>qtile check</code>. The code will therefore need to include all relevant imports etc.</p> <p>Based on the above, the following is recommended as best practice:</p> <ul> <li>Define one <code>Check</code> test which addresses every situation anticipated by the migration</li> <li>Use as many <code>Change</code> tests as required to test individual scenarios in a minimal way</li> <li>Use <code>NoChange</code> tests where there are specific cases that should not be modified</li> <li>Depending on the simplicity of the migration, a single <code>Check</code> may be all that is required</li> </ul> <p>For example, the <code>RemoveCmdPrefix</code> migration has the following <code>TESTS</code>:</p> <pre><code>TESTS = [\n    Change(\"\"\"qtile.cmd_spawn(\"alacritty\")\"\"\", \"\"\"qtile.spawn(\"alacritty\")\"\"\"),\n    Change(\"\"\"qtile.cmd_groups()\"\"\", \"\"\"qtile.get_groups()\"\"\"),\n    Change(\"\"\"qtile.cmd_screens()\"\"\", \"\"\"qtile.get_screens()\"\"\"),\n    Change(\"\"\"qtile.current_window.cmd_hints()\"\"\", \"\"\"qtile.current_window.get_hints()\"\"\"),\n    Change(\n        \"\"\"qtile.current_window.cmd_opacity(0.5)\"\"\",\n        \"\"\"qtile.current_window.set_opacity(0.5)\"\"\",\n    ),\n    Change(\n        \"\"\"\n        class MyWidget(widget.Clock):\n            def cmd_my_command(self):\n                pass\n        \"\"\",\n        \"\"\"\n        from libqtile.command.base import expose_command\n\n        class MyWidget(widget.Clock):\n            @expose_command\n            def my_command(self):\n                pass\n        \"\"\"\n    ),\n    NoChange(\n        \"\"\"\n        def cmd_some_other_func():\n            pass\n        \"\"\"\n    ),\n    Check(\n        \"\"\"\n        from libqtile import qtile, widget\n\n        class MyClock(widget.Clock):\n            def cmd_my_exposed_command(self):\n                pass\n\n        def my_func(qtile):\n            qtile.cmd_spawn(\"rickroll\")\n            hints = qtile.current_window.cmd_hints()\n            groups = qtile.cmd_groups()\n            screens = qtile.cmd_screens()\n            qtile.current_window.cmd_opacity(0.5)\n\n        def cmd_some_other_func():\n            pass\n        \"\"\",\n        \"\"\"\n        from libqtile import qtile, widget\n        from libqtile.command.base import expose_command\n\n        class MyClock(widget.Clock):\n            @expose_command\n            def my_exposed_command(self):\n                pass\n\n        def my_func(qtile):\n            qtile.spawn(\"rickroll\")\n            hints = qtile.current_window.get_hints()\n            groups = qtile.get_groups()\n            screens = qtile.get_screens()\n            qtile.current_window.set_opacity(0.5)\n\n        def cmd_some_other_func():\n            pass\n        \"\"\"\n    )\n]\n</code></pre> <p>The tests check:</p> <ul> <li><code>cmd_</code> prefix is removed on method calls, updating specific changes as required</li> <li>Exposed methods in a class should use the <code>expose_command</code> decorator (adding the import if it's not already included)</li> <li>No change is made to a function definition (as it's not part of a class definition)</li> </ul> <p>Note</p> <p>Tests will fail in the following scenarios:</p> <ul> <li>If no tests are defined</li> <li>If a <code>Change</code> test does not result in linting output</li> <li>If no <code>Check</code> test is defined</li> </ul> <p>You can check your tests by running <code>pytest -k &lt;YourMigrationID&gt;</code>. Note, <code>mpypy</code> must be installed for the <code>Check</code> tests to be run.</p>"},{"location":"manual/license/","title":"License","text":"<p>This project is distributed under the MIT license.</p> <p>Copyright (c) 2008, Aldo Cortesi All rights reserved.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"manual/stacking/","title":"Window stacking","text":"<p>A number of window commands (<code>move_up/down()</code>, <code>bring_to_front()</code> etc.) relate to the stacking order of windows.</p> <p>The aim of this page is to provide more details as to how stacking is implemented in Qtile.</p> <p>Important</p> <p> Currently, stacking is only implemented in the X11 background. Support will be added to the Wayland backend in future and this page will be updated accordingly.</p>"},{"location":"manual/stacking/#layer-priority-groups","title":"Layer priority groups","text":"<p>We have tried to adhere to the EWMH specification. Windows are therefore stacked, from the bottom, according to the following priority rules:</p> <ul> <li>windows of type _NET_WM_TYPE_DESKTOP</li> <li>windows having state _NET_WM_STATE_BELOW</li> <li>windows not belonging in any other layer</li> <li>windows of type _NET_WM_TYPE_DOCK (unless they have state   _NET_WM_TYPE_BELOW) and windows having state _NET_WM_STATE_ABOVE</li> <li>focused windows having state _NET_WM_STATE_FULLSCREEN</li> </ul> <p>Qtile had then added an additional layer so that <code>Scratchpad</code> windows are placed above everything else.</p> <p>Tiled windows will open in the default, \"windows not belonging in any other layer\", layer. If <code>floats_kept_above</code> is set to <code>True</code> in the config then new floating windows will have the <code>_NET_WM_STATE_ABOVE</code> property set which will ensure they remain above tiled windows.</p>"},{"location":"manual/stacking/#moving-windows","title":"Moving windows","text":"<p>Imagine you have four tiled windows stacked (from the top) as follows:</p> <pre><code>\"One\"\n\"Two\"\n\"Three\"\n\"Four\"\n</code></pre> <p>If you call <code>move_up()</code> on window \"Four\", the result will be:</p> <pre><code>\"One\"\n\"Two\"\n\"Four\"\n\"Three\"\n</code></pre> <p>If you now call <code>move_to_top()</code> on window \"Three\", the result will be:</p> <pre><code>\"Three\"\n\"One\"\n\"Two\"\n\"Four\"\n</code></pre> <p>Note</p> <p> <code>bring_to_front()</code> has a special behaviour in Qtile. This will bring any window to the very top of the stack, disregarding the priority rules set out above. When that window loses focus, it will be restacked in the appropriate location.</p> <p>This can cause undesirable results if the config contains <code>bring_front_click=True</code> and the user has an app like a dock which is activated by mousing over the window. In this situation, tiled windows will be displayed above the dock making it difficult to activate. To fix this, set <code>bring_front_click</code> to <code>False</code> to disable the behaviour completely, or <code>\"floating_only\"</code> to only have this behaviour apply to floating windows.</p>"},{"location":"manual/troubleshooting/","title":"Troubleshooting","text":""},{"location":"manual/troubleshooting/#so-something-has-gone-wrong-what-do-you-do","title":"So something has gone wrong... what do you do?","text":"<p>When Qtile is running, it logs error messages (and other messages) to its log file. This is found at <code>~/.local/share/qtile/qtile.log</code>. This is the first place to check to see what is going on. If you are getting unexpected errors from normal usage or your configuration (and you're not doing something wacky) and believe you have found a bug, then please report a bug.</p> <p>If you are hacking on Qtile and you want to debug your changes, this log is your best friend. You can send messages to the log from within libqtile by using the <code>logger</code>:</p> <pre><code>from libqtile.log_utils import logger\n\nlogger.warning(\"Your message here\")\nlogger.warning(variable_you_want_to_print)\n\ntry:\n    # some changes here that might error\nexcept Exception:\n    logger.exception(\"Uh oh!\")\n</code></pre> <p><code>logger.warning</code> is convenient because its messages will always be visibile in the log. <code>logger.exception</code> is helpful because it will print the full traceback of an error to the log. By sticking these amongst your changes you can look more closely at the effects of any changes you made to Qtile's internals.</p>"},{"location":"manual/troubleshooting/#x11-capturing-an-xtrace","title":"X11: Capturing an <code>xtrace</code>","text":"<p>Occasionally, a bug will be low level enough to require an <code>xtrace</code> of Qtile's conversations with the X server. To capture one of these, create an <code>xinitrc</code> or similar file with:</p> <pre><code>exec xtrace qtile &gt;&gt; ~/qtile.log\n</code></pre> <p>This will put the xtrace output in Qtile's logfile as well. You can then demonstrate the bug, and paste the contents of this file into the bug report.</p> <p>Note that xtrace may be named <code>x11trace</code> on some platforms, for example, on Fedora.</p>"},{"location":"manual/troubleshooting/#debugging-in-wayland","title":"Debugging in Wayland","text":"<p>To get incredibly verbose output of communications between clients and the server, you can set <code>WAYLAND_DEBUG=1</code> in the environment before starting the process. This applies to the server itself, so be aware that running <code>qtile</code> with this set will generate lots of output for Qtile and all clients that it launches. If you're including this output with a bug report please try to cut out just the relevant portions.</p> <p>If you're hacking on Qtile and would like this debug log output for it rather than any clients, it can be helpful to run the helper script at <code>scripts/wephyr</code> in the source from an existing session. You can then run clients from another terminal using the <code>WAYLAND_DISPLAY</code> value printed by Qtile, so that the debug logs printed by Qtile are only the server's.</p> <p>If you suspect a client may be responsible for a bug, it can be helpful to look at the issue trackers for other compositors, such as sway. Similarly if you're hacking on Qtile's internals and think you've found an unexpected quirk it may be helpful to search the issue tracker for wlroots.</p>"},{"location":"manual/wayland/","title":"Running Qtile as a Wayland Compositor","text":"<p>Some functionality may not yet be implemented in the Wayland compositor. Please see the Wayland To Do List discussion for the current state of development. Also checkout the unresolved Wayland-specific issues and troubleshooting for tips on how to debug Wayland problems.</p> <p>Note</p> <p>We currently support wlroots&gt;=0.16.0,&lt;0.17.0 and pywlroots==0.16.4.</p>"},{"location":"manual/wayland/#backend-specific-configuration","title":"Backend-Specific Configuration","text":"<p>If you want your config file to work with different backends but want some options set differently per backend, you can check the name of the current backend in your config as follows:</p> <pre><code>from libqtile import qtile\n\nif qtile.core.name == \"x11\":\n    term = \"urxvt\"\nelif qtile.core.name == \"wayland\":\n    term = \"foot\"\n</code></pre>"},{"location":"manual/wayland/#running-x11-only-programs","title":"Running X11-Only Programs","text":"<p>Qtile supports XWayland but requires that <code>wlroots</code> and <code>pywlroots</code> were built with XWayland support, and that XWayland is installed on the system from startup. XWayland will be started the first time it is needed.</p>"},{"location":"manual/wayland/#xwayland-windows-sometimes-dont-receive-mouse-events","title":"XWayland windows sometimes don't receive mouse events","text":"<p>There is currently a known bug (https://github.com/qtile/qtile/issues/3675) which causes pointer events (hover/click/scroll) to propagate to the wrong window when switching focus.</p>"},{"location":"manual/wayland/#input-device-configuration","title":"Input Device Configuration","text":"<p>.. qtile_class:: libqtile.backend.wayland.InputConfig</p> <p>If you want to change keyboard configuration during runtime, you can use the core's <code>set_keymap</code> command (see below).</p>"},{"location":"manual/wayland/#core-commands","title":"Core Commands","text":"<p>See the Wayland backend commands section in the API Commands documentation.</p>"},{"location":"manual/commands/","title":"Architecture","text":"<p>This page explains how Qtile's API works and how it can be accessed. Users who just want to find a list of commands can jump to the API commands page.</p> <p>Qtile's command API is based on a graph of objects, where each object has a set of associated commands, combined with a number of interfaces that are used to navigate the graph and execute associated commands.</p> <p>This page gives an overview of the command graph and the various interfaces accessible by users. The documentation also contains details of all the commands that are exposed by objects on the graph.</p> <p>Note</p> <p>While users are able to access the internal python objects (e.g. via a <code>qtile</code> instance), this is not part of the \"official\" API. These objects and method are not currently included in the documentation but can be viewed by looking at the source code on github. Changes to commonly-used internal objects will be kept to a minimum.</p> <p>The graph and object commands are used in a number of different places:</p> <ul> <li>Commands can be bound to keys in the Qtile   configuration file using the <code>lazy</code> interface.</li> <li>Commands can be called from a script using one of the various   available interfaces to interact with Qtile from Python or shell scripts.</li> </ul> <p>A couple of additional options are available if you are looking for more interactive access:</p> <ul> <li>Commands can be called through qtile shell, the   Qtile shell.</li> <li>The shell can also be hooked into a Jupyter kernel called iqshell   (NB this interface is currently broken).</li> </ul> <p>If the explanations in the pages below seems a bit complex, please take a moment to explore the API using the <code>qtile shell</code> command shell. The shell provides a way to navigate the graph, allowing you to see how nodes are connected. Available nodes can be displayed with the <code>ls</code> command while command lists and detailed documentation can be accessed from the built-in <code>help</code> command. Commands can also be executed from this shell.</p> <ul> <li>The Command Graph</li> <li>Navigating the command graph</li> <li>Command graph development</li> </ul>"},{"location":"manual/commands/advanced/","title":"Command graph development","text":"<p>This page provides further detail on how Qtile's command graph works. If you just want to script your Qtile window manager the earlier information, in addition to the documentation on the available commands should be enough to get started.</p> <p>To develop the Qtile manager itself, we can dig into how Qtile represents these objects, which will lead to the way the commands are dispatched.</p>"},{"location":"manual/commands/advanced/#client-server-scripting-model","title":"Client-Server Scripting Model","text":"<p>Qtile has a client-server control model - the main Qtile instance listens on a named pipe, over which marshalled command calls and response data is passed. This allows Qtile to be controlled fully from external scripts. Remote interaction occurs through an instance of the <code>libqtile.command.interface.IPCCommandInterface</code> class. This class establishes a connection to the currently running instance of Qtile.  A <code>libqtile.command.client.InteractiveCommandClient</code> can use this connection to dispatch commands to the running instance.  Commands then appear as methods with the appropriate signature on the <code>InteractiveCommandClient</code> object.  The object hierarchy is described in the Commands API section of this manual. Full command documentation is available through the Qtile Shell.</p>"},{"location":"manual/commands/advanced/#digging-deeper-command-objects","title":"Digging Deeper: Command Objects","text":"<p>All of the configured objects setup by Qtile are <code>CommandObject</code> subclasses. These objects are so named because we can issue commands against them using the command scripting API.  Looking through the code, the commands that are exposed are commands that are decorated with the <code>@expose_command()</code> decorator. When writing custom layouts, widgets, or any other object, you can add your own custom functions and, once you add the decorator, they will be callable using the standard command infrastructure. An available command can be extracted by calling <code>.command()</code> with the name of the command.</p> <p>In addition to having a set of associated commands, each command object also has a collection of items associated with it.  This is what forms the graph that is shown above.  For a given object type, the <code>items()</code> method returns all of the names of the associated objects of that type and whether or not there is a defaultable value.  For example, from the root, <code>.items(\"group\")</code> returns the name of all of the groups and that there is a default value, the currently focused group.</p> <p>To navigate from one command object to the next, the <code>.select()</code> method is used.  This method resolves a requested object from the command graph by iteratively selecting objects.  A selector like <code>[(\"group\", \"b\"), (\"screen\", None)]</code> would be to first resolve group \"b\", then the screen associated to the group.</p>"},{"location":"manual/commands/advanced/#the-command-graph","title":"The Command Graph","text":"<p>In order to help in specifying command objects, there is the abstract command graph structure.  The command graph structure allows us to address any valid command object and issue any command against it without needing to have any Qtile instance running or have anything to resolve the objects to.  This is particularly useful when constructing lazy calls, where the Qtile instance does not exist to specify the path that will be resolved when the command is executed.  The only limitation of traversing the command graph is that it must follow the allowed edges specified in the first section above.</p> <p>Every object in the command graph is represented by a <code>CommandGraphNode</code>. Any call can be resolved from a given node.  In addition, each node knows about all of the children objects that can be reached from it and have the ability to <code>.navigate()</code> to the other nodes in the command graph.  Each of the object types are represented as <code>CommandGraphObject</code> types and the root node of the graph, the <code>CommandGraphRoot</code> represents the Qtile instance.  When a call is performed on an object, it returns a <code>CommandGraphCall</code>.  Each call will know its own name as well as be able to resolve the path through the command graph to be able to find itself.</p> <p>Note that the command graph itself can standalone, there is no other functionality within Qtile that it relies on.  While we could have started here and built up, it is helpful to understand the objects that the graph is meant to represent, as the graph is just a representation of a traversal of the real objects in a running Qtile window manager.  In order to tie the running Qtile instance to the abstract command graph, we move on to the command interface.</p>"},{"location":"manual/commands/advanced/#executing-graph-commands-command-interface","title":"Executing graph commands: Command Interface","text":"<p>The <code>CommandInterface</code> is what lets us take an abstract call on the command graph and resolve it against a running command object.  Put another way, this is what takes the graph traversal <code>.group[\"b\"].screen.info()</code> and executes the <code>info()</code> command against the addressed <code>screen</code> object.  Additional functionality can be used to check that a given traversal resolves to actual objcets and that the requested command actually exists.  Note that by construction of the command graph, the traversals here must be feasible, even if they cannot be resolved for a given configuration state.  For example, it is possible to check the screen assoctiated to a group, even though the group may not be on a screen, but it is not possible to check the widget associated to a group.</p> <p>The simplest form of the command interface is the <code>QtileCommandInterface</code>, which can take an in-process <code>Qtile</code> instance as the root <code>CommandObject</code> and execute requested commands.  This is typically how we run the unit tests for Qtile.</p> <p>The other primary example of this is the <code>IPCCommandInterface</code> which is able to then route all calls through an IPC client connected to a running Qtile instance.  In this case, the command graph call can be constructed on the client side without having to dispatch to Qtile and once the call is constructed and deemed valid, the call can be executed.</p> <p>In both of these cases, executing a command on a command interface will return the result of executing the command on a running Qtile instance.  To support lazy execution, the <code>LazyCommandInterface</code> instead returns a <code>LazyCall</code> which is able to be resolved later by the running Qtile instance when it is configured to fire.</p>"},{"location":"manual/commands/advanced/#tying-it-together-command-client","title":"Tying it together: Command Client","text":"<p>So far, we have our running Command Objects and the Command Interface to dispatch commands against these objects as well as the Command Graph structure itself which encodes how to traverse the connections between the objects.  The final component which ties everything together is the Command Client, which allows us to navigate through the graph to resolve objects, find their associated commands, and execute the commands against the held command interface.</p> <p>The idea of the command client is that it is created with a reference into the command graph and a command interface.  All navigation can be done against the command graph, and traversal is done by creating a new command client starting from the new node.  When a command is executed against a node, that command is dispatched to the held command interface.  The key decision here is how to perform the traversal.  The command client exists in two different flavors: the standard <code>CommandClient</code> which is useful for handling more programatic traversal of the graph, calling methods to traverse the graph, and the <code>InteractiveCommandClient</code> which behaves more like a standard Python object, traversing by accessing properties and performing key lookups.</p> <p>Returning to our examples above, we now have the full context to see what is going on when we call:</p> <pre><code>from libqtile.command.client import CommandClient\nc = CommandClient()\nprint(c.call(\"status\")())\nfrom libqtile.command.client import InteractiveCommandClient\nc = InteractiveCommandClient()\nprint(c.status())\n</code></pre> <p>In both cases, the command clients are constructed with the default command interface, which sets up an IPC connection to the running Qtile instance, and starts the client at the graph root.  When we call <code>c.call(\"status\")</code> or <code>c.status</code>, we navigate the command client to the <code>status</code> command on the root graph object.  When these are invoked, the commands graph calls are dispatched via the IPC command interface and the results then sent back and printed on the local command line.</p> <p>The power that can be realized by separating out the traversal and resolution of objects in the command graph from actually invoking or looking up any objects within the graph can be seen in the <code>lazy</code> module.  By creating a lazy evaluated command client, we can expose the graph traversal and object resolution functionality via the same <code>InteractiveCommandClient</code> that is used to perform live command execution in the Qtile prompt.</p>"},{"location":"manual/commands/command_graph/","title":"The Command Graph","text":"<p>The objects in Qtile's command graph come in eight flavours, matching the eight basic components of the window manager: <code>layouts</code>, <code>windows</code>, <code>groups</code>, <code>bars</code>, <code>widgets</code>, <code>screens</code>, <code>core</code>, and a special <code>root</code> node. Objects are addressed by a path specification that starts at the root and follows the available paths in the graph. This is what the graph looks like:</p> <p>.. qtile_graph::     :root: all     :api_page_root: api/</p> <p>Each arrow can be read as \"holds a reference to\". So, we can see that a <code>widget</code> object holds a reference to objects of type <code>bar</code>, <code>screen</code> and <code>group</code>. Let's start with some simple examples of how the addressing works. Which particular objects we hold reference to depends on the context - for instance, widgets hold a reference to the screen that they appear on, and the bar they are attached to.</p> <p>Let's look at an example, starting at the root node. The following script runs the <code>status</code> command on the root node, which, in this case, is represented by the <code>InteractiveCommandClient</code> object:</p> <pre><code>from libqtile.command.client import InteractiveCommandClient\nc = InteractiveCommandClient()\nprint(c.status())\n</code></pre> <p>The <code>InteractiveCommandClient</code> is a class that allows us to traverse the command graph using attributes to select child nodes or commands.  In this example, we have resolved the <code>status()</code> command on the root object.  The interactive command client will automatically find and connect to a running Qtile instance, and which it will use to dispatch the call and print out the return.</p> <p>An alternative is to use the <code>CommandClient</code>, which allows for a more precise resolution of command graph objects, but is not as easy to interact with from a REPL:</p> <pre><code>from libqtile.command.client import CommandClient\nc = CommandClient()\nprint(c.call(\"status\")())\n</code></pre> <p>Like the interactive client, the command client will automatically connect to a running Qtile instance.  Here, we first resolve the <code>status()</code> command with the <code>.call(\"status\")</code>, which simply located the function, then we can invoke the call with no arguments.</p> <p>For the rest of this example, we will use the interactive command client.  From the graph, we can see that the root node holds a reference to <code>group</code> nodes. We can access the \"info\" command on the current group like so:</p> <pre><code>c.group.info()\n</code></pre> <p>To access a specific group, regardless of whether or not it is current, we use the Python mapping lookup syntax. This command sends group \"b\" to screen 1 (by the <code>libqtile.config.Group.to_screen</code> method):</p> <pre><code>c.group[\"b\"].to_screen(1)\n</code></pre> <p>In different contexts, it is possible to access a default object, where in other contexts a key is required.  From the root of the graph, the current <code>group</code>, <code>layout</code>, <code>screen</code> and <code>window</code> can be accessed by simply leaving the key specifier out. The key specifier is mandatory for <code>widget</code> and <code>bar</code> nodes.</p> <p>With this context, we can now drill down deeper in the graph, following the edges in the graphic above. To access the screen currently displaying group \"b\", we can do this:</p> <pre><code>c.group[\"b\"].screen.info()\n</code></pre> <p>Be aware, however, that group \"b\" might not currently be displayed. In that case, it has no associated screen, the path resolves to a non-existent node, and we get an exception:</p> <pre><code>libqtile.command.CommandError: No object screen in path 'group['b'].screen'\n</code></pre> <p>The graph is not a tree, since it can contain cycles. This path (redundantly) specifies the group belonging to the screen that belongs to group \"b\":</p> <pre><code>c.group[\"b\"].screen.group\n</code></pre> <p>This amount of connectivity makes it easy to reach out from a given object when callbacks and events fire on that object to related objects.</p>"},{"location":"manual/commands/interfaces/","title":"Interfaces","text":""},{"location":"manual/commands/interfaces/#introduction","title":"Introduction","text":"<p>This page provides an overview of the various interfaces available to interact with Qtile's command graph.</p> <ul> <li><code>lazy</code> calls</li> <li>when running <code>qtile shell</code></li> <li>when running <code>qtile cmd-obj</code></li> <li>when using <code>CommandClient</code> or <code>InteractiveCommandClient</code> in python </li> </ul> <p>The way that these commands are called varies depending on which option you select. However, all interfaces follow the same, basic approach: navigate to the desired object and then execute a command on that object. The following examples illustrate this principle by showing how the same command can be accessed by the various interfaces:</p> Lazy call<pre><code>lazy.widget[\"volume\"].increase_volume()\n</code></pre> qtile shell<pre><code>&gt; cd widget/volume\nwidget[volume] &gt; increase_volume()\n</code></pre> qtile shell<pre><code>qtile cmd-obj:\nqtile cmd-obj -o widget volume -f increase_volume\n</code></pre> CommandClient<pre><code>&gt;&gt;&gt; from libqtile.command.client import CommandClient\n&gt;&gt;&gt; c = CommandClient()\n&gt;&gt;&gt; c.navigate(\"widget\", \"volume\").call(\"increase_volume\")\n</code></pre> InteractiveCommandClient<pre><code>&gt;&gt;&gt; from libqtile.command.client import InteractiveCommandClient\n&gt;&gt;&gt; c = InteractiveCommandClient()\n&gt;&gt;&gt; c.widget[\"volume\"].increase_volume()\n</code></pre>"},{"location":"manual/commands/interfaces/#the-interfaces","title":"The Interfaces","text":"<p>From the examples above, you can see that there are five main interfaces which can be used to interact with Qtile's command graph. Which one you choose will depend on how you intend to use it as each interface is suited to different scenarios.</p> <ul> <li>The <code>lazy</code> interface is used in config scripts to bind commands to keys and   mouse callbacks.</li> <li>The <code>qtile shell</code> is a tool for exploring the graph my presenting it as a   file structure. It is not designed to be used for scripting.</li> <li>For users creating shell scripts, the <code>qtile cmd-obj</code> interface would be   the recommended choice.</li> <li>For users wanting to control Qtile from a python script, there are two available   interfaces <code>libqtile.command.client.CommandClient</code> and   <code>libqtile.command.client.InteractiveCommandClient</code>. Users are advised to use the   <code>InteractiveCommandClient</code> as this simplifies the syntax for navigating the graph   and calling commands.</li> </ul>"},{"location":"manual/commands/interfaces/#the-lazy-interface","title":"The Lazy interface","text":"<p>The <code>libqtile.lazy.lazy</code> object is a special helper object to specify a command for later execution. Lazy objects are typically users' first exposure to Qtile's command graph but they may not realise it. However, understanding this will help users when they try using some of the other interfaces listed on this page.</p> <p>The basic syntax for a lazy command is:</p> <pre><code>lazy.node[selector].command(arguments)\n</code></pre> <p>No node is required when accessing commands on the root node. In addition, multiple nodes can be sequenced if required to navigate to a specific object. For example, bind a key that would focus the next window on the active group on screen 2, you would create a lazy object as follows:</p> <pre><code>lazy.screen[1].group.next_window()\n</code></pre> <p>Note</p> <p>As noted above, <code>lazy</code> calls do not call the relevant command but only create a reference to it. While this makes it ideal for binding commands to key presses and <code>mouse_callbacks</code> for widgets, it also means that <code>lazy</code> calls cannot be included in user-defined functions.</p>"},{"location":"manual/commands/interfaces/#qtile-shell","title":"qtile shell","text":"<p>The qtile shell maps the command graph to a virtual filesystem that can be navigated in a similar way. While it is unlikely to be used for scripting, the <code>qtile shell</code> interface provides an excellent means for users to navigate and familiarise themselves with the command graph.</p> <p>For more information, please refer to qtile-shell.</p>"},{"location":"manual/commands/interfaces/#qtile-cmd-obj","title":"qtile cmd-obj","text":"<p><code>qtile cmd-obj</code> is a command line interface for executing commands on the command graph. It can be used as a standalone command (e.g. executed directly from the terminal) or incorporated into shell scripts.</p> <p>For more information, please refer to qtile-cmd.</p>"},{"location":"manual/commands/interfaces/#commandclient","title":"CommandClient","text":"<p>The <code>CommandClient</code> interface is a low-level python interface for accessing and navigating the command graph. The low-level nature means that navigation steps must be called explicityly, rather than being inferred from the body of the calling command.</p> <p>For example:</p> <pre><code>from libqtile.command.client import CommandClient\n\nc = CommandClient()\n\n# Call info command on clock widget\ninfo = c.navigate(\"widget\", \"clock\").call(\"info\")\n\n# Call info command on the screen displaying the clock widget\ninfo = c.navigate(\"widget\", \"clock\").navigate(\"screen\", None).call(\"info\")\n</code></pre> <p>Note from the last example that each navigation step must be called separately. The arguments passed to <code>navigate()</code> are <code>node</code> and <code>selector</code>. <code>selector</code> is <code>None</code> when you wish to access the default object on that node (e.g. the current screen).</p> <p>More technical explanation about the python command clients can be found at Command Interface.</p>"},{"location":"manual/commands/interfaces/#interactivecommandclient","title":"InteractiveCommandClient","text":"<p>The <code>InteractiveCommandClient</code> is likely to be the more popular interface for users wishing to access the command graph via external python scripts. One of the key differences between the <code>InteractiveCommandClient</code> and the above <code>CommandClient</code> is that the <code>InteractiveCommandClient</code> removes the need to call <code>navigate</code> and <code>call</code> explicitly. Instead, the syntax mimics that of the <code>lazy</code> interface.</p> <p>For example, to call the same commands in the above example:</p> <pre><code>from libqtile.command.client import InteractiveCommandClient\n\nc = InteractiveCommandClient()\n\n# Call info command on clock widget\ninfo = c.widget[\"clock\"].info()\n\n# Call info command on the screen displaying the clock widget\ninfo = c.widget[\"clock\"].screen.info()\n</code></pre>"},{"location":"manual/commands/keybindings/","title":"Keybindings in images","text":""},{"location":"manual/commands/keybindings/#default-configuration","title":"Default configuration","text":"<p>bash: line 1: cd: /home/pawamoy/data/dev/qtile/newdocs: No such file or directory find: \u2018_static/keybindings/*\u2019: No such file or directory</p>"},{"location":"manual/commands/keybindings/#generate-your-own-images","title":"Generate your own images","text":"<p>Qtile provides a tiny helper script to generate keybindings images from a config file. In the repository, the script is located under <code>scripts/gen-keybinding-img</code>.</p> <p>This script accepts a configuration file and an output directory. If no argument is given, the default configuration will be used and files will be placed in same directory where the command has been run.</p> <pre><code>$ ./scripts/gen-keybinding-img\nusage: gen-keybinding-img [-h] [-c CONFIGFILE] [-o OUTPUT_DIR]\n\nQtile keybindings image generator\n\noptional arguments:\n    -h, --help          show this help message and exit\n    -c CONFIGFILE, --config CONFIGFILE\n                        use specified configuration file. If no presented\n                        default will be used\n    -o OUTPUT_DIR, --output-dir OUTPUT_DIR\n                        set directory to export all images to\n</code></pre>"},{"location":"manual/commands/navigation/","title":"Navigating the command graph","text":"<p>As noted previously, some objects require a selector to ensure that the correct object is selected, while other nodes provide a default object without a selector.</p> <p>The table below shows what selectors are required for the diferent nodes and whether the selector is optional (i.e. if it can be omitted to select the default object).</p> Object Key Optional? Example <code>bar</code> <code>\"top\"</code>, <code>\"bottom\"</code><sup>1</sup> No <code>c.screen.bar[\"bottom\"]</code> <code>group</code> Name string Yes <code>c.group[\"one\"]</code><code>c.group</code> <code>layout</code> Integer index Yes <code>c.layout[2]</code><code>c.layout</code> <code>screen</code> Integer index Yes <code>c.screen[1]</code><code>c.screen</code> <code>widget</code> Widget name<sup>2</sup> No <code>c.widget[\"textbox\"]</code> <code>window</code> Integer window ID Yes <code>c.window[123456]</code><code>c.window</code> <code>core</code> No n/a <code>c.core</code> <ol> <li> <p>If accessing this node from the root, users on multi-monitor   setups may wish to navigate via a <code>screen</code> node to ensure that they   select the correct object.\u00a0\u21a9</p> </li> <li> <p>This is usually the name of the widget class in lower case but can   be set by passing the <code>name</code> parameter to the widget.\u00a0\u21a9</p> </li> </ol>"},{"location":"manual/commands/api/","title":"Commands API","text":"<p>The following pages list all the commands that are exposed by Qtile's command graph. As a result, all of these commands are accessible by any of the various interfaces provided by Qtile (e.g. the <code>lazy</code> interface for keybindings and mouse callbacks).</p> <ul> <li>Qtile root</li> <li>Layouts</li> <li>Windows</li> <li>Groups</li> <li>Bars</li> <li>Widgets</li> <li>Screens</li> <li>Core</li> </ul>"},{"location":"manual/commands/api/backend/","title":"Backend core objects","text":"<p>The backend core is the link between the Qtile objects (windows, layouts, groups etc.) and the specific backend (X11 or Wayland). This core should be largely invisible to users and, as a result, these objects do not expose many commands.</p> <p>Nevertheless, both backends do contain important commands, notably <code>set_keymap</code> on X11 and <code>change_vt</code> used to change to a different TTY on Wayland.</p> <p>The backend core has no access to other nodes on the command graph.</p> <p>.. qtile_graph::     :root: core</p>"},{"location":"manual/commands/api/backend/#x11-backend","title":"X11 backend","text":"<p>.. qtile_commands:: libqtile.backend.x11.core     :object-node: core     :no-title:</p>"},{"location":"manual/commands/api/backend/#wayland-backend","title":"Wayland backend","text":"<p>.. qtile_commands:: libqtile.backend.wayland.core     :object-node: core     :no-title:</p>"},{"location":"manual/commands/api/bars/","title":"Bar objects","text":"<p>The bar is primarily used to display widgets on the screen. As a result, the bar does not need many of its own commands.</p> <p>To select a bar on the command graph, you must use a selector (as there is no default bar). The selector is the position of the bar on the screen i.e. \"top\", \"bottom\", \"left\" or \"right\".</p> <p>The bar can access the screen it's on and the widgets it contains via the command graph.</p> <p>.. qtile_graph::     :root: bar</p> <p>.. qtile_commands:: libqtile.bar     :object-node: bar     :object-selector-string: position     :no-title:</p>"},{"location":"manual/commands/api/groups/","title":"Group objects","text":"<p>Groups are Qtile's workspaces. Groups are not responsible for the positioning of windows (that is handled by the layouts) so the available commands are somewhat more limited in scope.</p> <p>Groups have access to the layouts in that group, the windows in the group and the screen displaying the group.</p> <p>.. qtile_graph::     :root: group</p> <p>.. qtile_commands:: libqtile.group     :baseclass: libqtile.group._Group     :includebase:     :object-node: group     :no-title:</p>"},{"location":"manual/commands/api/layouts/","title":"Layout objects","text":"<p>Layouts position windows according to their specific rules. Layout commands typically include moving windows around the layout and changing the size of windows.</p> <p>Layouts can access the windows being displayed, the group holding the layout and the screen displaying the layout.</p> <p>.. qtile_graph::     :root: layout</p> <p>.. qtile_commands:: libqtile.layout     :baseclass: libqtile.layout.base.Layout     :object-node: layout</p>"},{"location":"manual/commands/api/root/","title":"Qtile root object","text":"<p>The root node represents the main Qtile manager instance. Many of the commands on this node are therefore related to the running of the application itself.</p> <p>The root can access every other node in the command graph. Certain objects can be accessed without a selector resulting in the current object being selected (e.g. current group, screen, layout, window).</p> <p>.. qtile_graph::     :root: root</p> <p>.. qtile_commands:: libqtile.core.manager   :baseclass: libqtile.core.manager.Qtile   :includebase:   :no-title:</p>"},{"location":"manual/commands/api/screens/","title":"Screen objects","text":"<p>Screens are the display area that holds bars and an active group. Screen commands include changing the current group and changing the wallpaper.</p> <p>Screens can access objects displayed on that screen e.g. bar, widgets, groups, layouts and windows.</p> <p>.. qtile_graph::     :root: screen</p> <p>.. qtile_commands:: libqtile.config     :baseclass: libqtile.config.Screen     :includebase:     :object-node: screen     :no-title:</p>"},{"location":"manual/commands/api/widgets/","title":"Widget objects","text":"<p>Widgets are small scripts that are used to provide content or add functionality to the bar. Some widgets will expose commands in order for functionality to be triggered indirectly (e.g. via a keypress).</p> <p>Widgets can access the parent bar and screen via the command graph.</p> <p>.. qtile_graph::     :root: widget</p> <p>.. qtile_commands:: libqtile.widget     :baseclass: libqtile.widget.base._Widget     :object-node: widget     :object-selector-name:</p>"},{"location":"manual/commands/api/windows/","title":"Window objects","text":"<p>The size and position of windows is determined by the current layout. Nevertheless, windows can still change their appearance in multiple ways (toggling floating state, fullscreen, opacity).</p> <p>Windows can access objects relevant to the display of the window (i.e. the screen, group and layout).</p> <p>.. qtile_graph::     :root: window</p> <p>.. qtile_commands:: libqtile.backend.base     :baseclass: libqtile.backend.base.Window     :object-node: window     :includebase:     :no-title:</p>"},{"location":"manual/commands/shell/","title":"Entry points","text":"<p>Qtile uses a subcommand structure; various subcommands are listed below. Additionally, two other commands available in the scripts/ section of the repository are also documented below.</p> <ul> <li>qtile start</li> <li>qtile shell</li> <li>qtile migrate</li> <li>qtile cmd-obj</li> <li>qtile run-cmd</li> <li>qtile top</li> <li>dqtile-cmd</li> <li>iqshell</li> </ul>"},{"location":"manual/commands/shell/dqtile-cmd/","title":"dqtile-cmd","text":"<p>A Rofi/dmenu interface to qtile-cmd. Accepts all arguments of qtile-cmd.</p>"},{"location":"manual/commands/shell/dqtile-cmd/#examples","title":"Examples","text":""},{"location":"manual/commands/shell/dqtile-cmd/#output-of-dqtile-cmd-o-cmd","title":"Output of <code>dqtile-cmd -o cmd</code>","text":""},{"location":"manual/commands/shell/dqtile-cmd/#output-of-dqtile-cmd-h","title":"Output of <code>dqtile-cmd -h</code>","text":"<pre><code>$ dqtile-cmd\n\nA Rofi/dmenu interface to qtile-cmd. Excepts all arguments of qtile-cmd\n(see below).\n\nusage: dqtile-cmd [-h] [--object OBJ_SPEC [OBJ_SPEC ...]]\n                  [--function FUNCTION] [--args ARGS [ARGS ...]] [--info]\n\nSimple tool to expose qtile.command functionality to shell.\n\noptional arguments:\n    -h, --help            show this help message and exit\n    --object OBJ_SPEC [OBJ_SPEC ...], -o OBJ_SPEC [OBJ_SPEC ...]\n                          Specify path to object (space separated). If no\n                          --function flag display available commands.\n    --function FUNCTION, -f FUNCTION\n                          Select function to execute.\n    --args ARGS [ARGS ...], -a ARGS [ARGS ...]\n                          Set arguments supplied to function.\n    --info, -i            With both --object and --function args prints\n                          documentation for function.\n\nExamples:\n    dqtile-cmd\n    dqtile-cmd -o cmd\n    dqtile-cmd -o cmd -f prev_layout -i\n    dqtile-cmd -o cmd -f prev_layout -a 3 # prev_layout on group 3\n    dqtile-cmd -o group 3 -f focus_back\n\nIf both rofi and dmenu are present rofi will be selected as default, to change this us --force-dmenu as the first argument.\n</code></pre>"},{"location":"manual/commands/shell/iqshell/","title":"iqshell","text":"<p>In addition to the standard <code>qtile shell</code> shell interface, we provide a kernel capable of running through Jupyter that hooks into the qshell client. The command structure and syntax is the same as qshell, so it is recommended you read that for more information about that.</p>"},{"location":"manual/commands/shell/iqshell/#dependencies","title":"Dependencies","text":"<p>In order to run iqshell, you must have ipykernel and jupyter_console. You can install the dependencies when you are installing qtile by running:</p> <pre><code>$ pip install qtile[ipython]\n</code></pre> <p>Otherwise, you can just install these two packages separately, either through PyPI or through your distribution package manager.</p>"},{"location":"manual/commands/shell/iqshell/#installing-and-running-the-kernel","title":"Installing and Running the Kernel","text":"<p>Once you have the required dependencies, you can run the kernel right away by running:</p> <pre><code>$ python3 -m libqtile.interactive.iqshell_kernel\n</code></pre> <p>However, this will merely spawn a kernel instance, you will have to run a separate frontend that connects to this kernel.</p> <p>A more convenient way to run the kernel is by registering the kernel with Jupyter.  To register the kernel itself, run:</p> <pre><code>$ python3 -m libqtile.interactive.iqshell_install\n</code></pre> <p>If you run this as a non-root user, or pass the <code>--user</code> flag, this will install to the user Jupyter kernel directory.  You can now invoke the kernel directly when starting a Jupyter frontend, for example:</p> <pre><code>$ jupyter console --kernel qshell\n</code></pre> <p>The <code>iqshell</code> script will launch a Jupyter terminal console with the qshell kernel.</p>"},{"location":"manual/commands/shell/iqshell/#iqshell-vs-qtile-shell","title":"iqshell vs qtile shell","text":"<p>One of the main drawbacks of running through a Jupyter kernel is the frontend has no way to query the current node of the kernel, and as such, there is no way to set a custom prompt.  In order to query your current node, you can call <code>pwd</code>.</p> <p>This, however, enables many of the benefits of running in a Jupyter frontend, including being able to save, run, and re-run code cells in frontends such as the Jupyter notebook.</p> <p>The Jupyter kernel also enables more advanced help, text completion, and introspection capabilities (however, these are currently not implemented at a level much beyond what is available in the standard qtile shell).</p>"},{"location":"manual/commands/shell/qtile-cmd/","title":"qtile cmd-obj","text":"<p>This is a simple tool to expose qtile.command functionality to shell. This can be used standalone or in other shell scripts.</p>"},{"location":"manual/commands/shell/qtile-cmd/#how-it-works","title":"How it works","text":"<p><code>qtile cmd-obj</code> works by selecting a command object and calling a specified function of that object.</p> <p>As per Architecture, Qtile's command graph has seven nodes: <code>layout</code>, <code>window</code>, <code>group</code>, <code>bar</code>, <code>widget</code>, <code>screen</code>, and a special <code>root</code> node. These are the objects that can be accessed via <code>qtile cmd-obj</code> (NB the root node is called <code>cmd</code> when using the <code>cmd-obj</code> script to give it an addressable name).</p> <p>Running the command against a selected object without a function (<code>-f</code>) will run the <code>help</code> command and list the commands available to the object. Commands shown with an asterisk (\"*\") require arguments to be passed via the <code>-a</code> flag.</p>"},{"location":"manual/commands/shell/qtile-cmd/#selecting-an-object","title":"Selecting an object","text":"<p>With the exception of <code>cmd</code>, all objects need an identifier so the correct object can be selected. Refer to Navigating the command graph for more information.</p> <p>Note</p> <p>You will see from the graph on Architecture that certain objects can be accessed from other objects. For example, <code>qtile cmd-obj -o group term layout</code> will list the commands for the current layout on the <code>term</code> group.</p>"},{"location":"manual/commands/shell/qtile-cmd/#information-on-functions","title":"Information on functions","text":"<p>Running a function with the <code>-i</code> flag will provide additional detail about that function (i.e. what it does and what arguments it expects).</p>"},{"location":"manual/commands/shell/qtile-cmd/#passing-arguments-to-functions","title":"Passing arguments to functions","text":"<p>Arguments can be passed to a function by using the <code>-a</code> flag. For example, to change the label for the group named \"1\" to \"A\", you would run <code>qtile cmd-obj -o group 1 -f set_label -a A</code>.</p> <p>Warning</p> <p>It is not currently possible to pass non-string arguments to functions via <code>qtile cmd-obj</code>. Doing so will result in an error.</p>"},{"location":"manual/commands/shell/qtile-cmd/#examples","title":"Examples","text":""},{"location":"manual/commands/shell/qtile-cmd/#output-of-qtile-cmd-obj-h","title":"Output of <code>qtile cmd-obj -h</code>","text":"<pre><code>$ qtile cmd-obj -h\nusage: qtile cmd-obj [-h] [--object OBJ_SPEC [OBJ_SPEC ...]]\n                    [--function FUNCTION] [--args ARGS [ARGS ...]] [--info]\n\nSimple tool to expose qtile.command functionality to shell.\n\noptional arguments:\n    -h, --help            show this help message and exit\n    --object OBJ_SPEC [OBJ_SPEC ...], -o OBJ_SPEC [OBJ_SPEC ...]\n                          Specify path to object (space separated). If no\n                          --function flag display available commands.\n    --function FUNCTION, -f FUNCTION\n                          Select function to execute.\n    --args ARGS [ARGS ...], -a ARGS [ARGS ...]\n                          Set arguments supplied to function.\n    --info, -i            With both --object and --function args prints\n                          documentation for function.\n\nExamples:\n    qtile cmd-obj\n    qtile cmd-obj -o cmd\n    qtile cmd-obj -o cmd -f prev_layout -i\n    qtile cmd-obj -o cmd -f prev_layout -a 3 # prev_layout on group 3\n    qtile cmd-obj -o group 3 -f focus_back\n    qtile cmd-obj -o widget textbox -f update -a \"New text\"\n    qtile cmd-obj -o cmd -f restart # restart qtile\n</code></pre>"},{"location":"manual/commands/shell/qtile-cmd/#output-of-qtile-cmd-obj-o-group-3","title":"Output of <code>qtile cmd-obj -o group 3</code>","text":"<pre><code>$ qtile cmd-obj -o group 3\n-o group 3 -f commands            Returns a list of possible commands for this object\n-o group 3 -f doc               * Returns the documentation for a specified command name\n-o group 3 -f eval              * Evaluates code in the same context as this function\n-o group 3 -f focus_back          Focus the window that had focus before the current one got it.\n-o group 3 -f focus_by_name     * Focus the first window with the given name. Do nothing if the name is\n-o group 3 -f function          * Call a function with current object as argument\n-o group 3 -f info                Returns a dictionary of info for this group\n-o group 3 -f info_by_name      * Get the info for the first window with the given name without giving it\n-o group 3 -f items             * Returns a list of contained items for the specified name\n-o group 3 -f next_window         Focus the next window in group.\n-o group 3 -f prev_window         Focus the previous window in group.\n-o group 3 -f set_label         * Set the display name of current group to be used in GroupBox widget.\n-o group 3 -f setlayout\n-o group 3 -f switch_groups     * Switch position of current group with name\n-o group 3 -f toscreen          * Pull a group to a specified screen.\n-o group 3 -f unminimize_all      Unminimise all windows in this group\n</code></pre>"},{"location":"manual/commands/shell/qtile-cmd/#output-of-qtile-cmd-obj-o-cmd","title":"Output of <code>qtile cmd-obj -o cmd</code>","text":"<pre><code>$ qtile cmd-obj -o cmd\n-o cmd -f add_rule              * Add a dgroup rule, returns rule_id needed to remove it\n-o cmd -f addgroup              * Add a group with the given name\n-o cmd -f commands                Returns a list of possible commands for this object\n-o cmd -f critical                Set log level to CRITICAL\n-o cmd -f debug                   Set log level to DEBUG\n-o cmd -f delgroup              * Delete a group with the given name\n-o cmd -f display_kb            * Display table of key bindings\n-o cmd -f doc                   * Returns the documentation for a specified command name\n-o cmd -f error                   Set log level to ERROR\n-o cmd -f eval                  * Evaluates code in the same context as this function\n-o cmd -f findwindow            * Launch prompt widget to find a window of the given name\n-o cmd -f focus_by_click        * Bring a window to the front\n-o cmd -f function              * Call a function with current object as argument\n-o cmd -f get_info                Prints info for all groups\n-o cmd -f get_state               Get pickled state for restarting qtile\n-o cmd -f get_test_data           Returns any content arbitrarily set in the self.test_data attribute.\n-o cmd -f groups                  Return a dictionary containing information for all groups\n-o cmd -f hide_show_bar         * Toggle visibility of a given bar\n-o cmd -f info                    Set log level to INFO\n-o cmd -f internal_windows        Return info for each internal window (bars, for example)\n-o cmd -f items                 * Returns a list of contained items for the specified name\n-o cmd -f list_widgets            List of all addressible widget names\n-o cmd -f next_layout           * Switch to the next layout.\n-o cmd -f next_screen             Move to next screen\n-o cmd -f next_urgent             Focus next window with urgent hint\n-o cmd -f pause                   Drops into pdb\n-o cmd -f prev_layout           * Switch to the previous layout.\n-o cmd -f prev_screen             Move to the previous screen\n-o cmd -f qtile_info              Returns a dictionary of info on the Qtile instance\n-o cmd -f qtilecmd              * Execute a Qtile command using the client syntax\n-o cmd -f remove_rule           * Remove a dgroup rule by rule_id\n-o cmd -f restart                 Restart qtile\n-o cmd -f run_extension         * Run extensions\n-o cmd -f run_external          * Run external Python script\n-o cmd -f screens                 Return a list of dictionaries providing information on all screens\n-o cmd -f shutdown                Quit Qtile\n-o cmd -f simulate_keypress     * Simulates a keypress on the focused window.\n-o cmd -f spawn                 * Run cmd in a shell.\n-o cmd -f spawncmd              * Spawn a command using a prompt widget, with tab-completion.\n-o cmd -f status                  Return \"OK\" if Qtile is running\n-o cmd -f switch_groups         * Switch position of groupa to groupb\n-o cmd -f switchgroup           * Launch prompt widget to switch to a given group to the current screen\n-o cmd -f sync                    Sync the X display. Should only be used for development\n-o cmd -f to_layout_index       * Switch to the layout with the given index in self.layouts.\n-o cmd -f to_screen             * Warp focus to screen n, where n is a 0-based screen number\n-o cmd -f togroup               * Launch prompt widget to move current window to a given group\n-o cmd -f tracemalloc_dump        Dump tracemalloc snapshot\n-o cmd -f tracemalloc_toggle      Toggle tracemalloc status\n-o cmd -f warning                 Set log level to WARNING\n-o cmd -f windows                 Return info for each client window\n</code></pre>"},{"location":"manual/commands/shell/qtile-migrate/","title":"qtile migrate","text":"<p><code>qtile migrate</code> is a tool to help users update their configs to reflect any breaking changes/deprecations introduced in later versions.</p> <p>The tool can automatically apply updates but it can also be used to highlight impacted lines, allowing users to update their configs manually.</p>"},{"location":"manual/commands/shell/qtile-migrate/#options","title":"Options","text":"<p>The tool can take a number of options when running:</p>"},{"location":"manual/commands/shell/qtile-migrate/#-c-config","title":"<code>-c</code>, <code>--config</code>","text":"<p>Default: <code>~/.config/qtile/config.py</code>. Sets the path to the config file.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-list-migrations","title":"<code>--list-migrations</code>","text":"<p>Default: n/a. Lists all the available migrations that can be run by the tool.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-info-id","title":"<code>--info ID</code>","text":"<p>Default: n/a. Show more detail about the migration implement by ID.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-after-version-version","title":"<code>--after-version VERSION</code>","text":"<p>Default: Not set (i.e. runs all migrations). Only runs migrations relating to changes implemented after release VERSION.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-r-id-run-migrations-id","title":"<code>-r ID</code>, <code>--run-migrations ID</code>","text":"<p>Default: Not set (i.e. runs all migrations). Run selected migrations identified by ID. Comma separated list if using multiple values.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-yes","title":"<code>--yes</code>","text":"<p>Default: Not set (i.e. users will need to confirm application of changes). Automatically apply changes without asking user for confirmation.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-show-diff","title":"<code>--show-diff</code>","text":"<p>Default: Not set. When used with <code>--yes</code> will cause diffs to still be shown for information purposes only.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-no-colour","title":"<code>--no-colour</code>","text":"<p>Default: Not set. Disables colour output for diff.</p>"},{"location":"manual/commands/shell/qtile-migrate/#-lint","title":"<code>--lint</code>","text":"<p>Default: Not set. Outputs linting lines showing location of changes. No changes are made to the config.</p>"},{"location":"manual/commands/shell/qtile-migrate/#available-migrations","title":"Available migrations","text":"<p>The following migrations are currently available.</p> <p>.. qtile_migrations::   :summary:</p>"},{"location":"manual/commands/shell/qtile-migrate/#running-migrations","title":"Running migrations","text":"<p>Assuming your config file is in the default location, running <code>qtile migrate</code> is sufficent to start the migration process.</p> <p>Let's say you had a config file with the following contents:</p> <pre><code>import libqtile.command_client\n\nkeys = [\n    KeyChord(\n        [mod],\n        \"x\",\n        [Key([], \"Up\", lazy.layout.grow()), Key([], \"Down\", lazy.layout.shrink())],\n        mode=\"Resize layout\",\n    )\n]\n\nqtile.cmd_spawn(\"alacritty\")\n</code></pre> <p>Running <code>qtile migrate</code> will run each available migration and, where the migration would result in changes, a diff will be shown and you will be asked whether you wish to apply the changes.</p> <pre><code>UpdateKeychordArgs: Updates `KeyChord` argument signature.\n\n--- original\n+++ modified\n@@ -5,7 +5,8 @@\n\n        [mod],\n        \"x\",\n        [Key([], \"Up\", lazy.layout.grow()), Key([], \"Down\", lazy.layout.shrink())],\n-        mode=\"Resize layout\",\n+        name=\"Resize layout\",\n+    mode=True,\n    )\n]\n\nApply changes? (y)es, (n)o, (s)kip file, (q)uit.\n</code></pre> <p>You will see from the output above that you are shown the name of the migration being applied and its purpose, along with the changes that will be implemented.</p> <p>If you select <code>quit</code> the migration will be stopped and any applied changes will be reversed.</p> <p>Once all migrations have been run on a file, you will then be asked whether you want to save changes to the file:</p> <pre><code>Save all changes to config.py? (y)es, (n)o.\n</code></pre> <p>At the end of the migration, backups of your original config will still be in your config folder. NB these will be overwritten if you re-run <code>qtile migrate</code>.</p>"},{"location":"manual/commands/shell/qtile-migrate/#linting","title":"Linting","text":"<p>If you don't want the script to modify your config directly, you can use the <code>--lint</code> option to show you where changes are required.</p> <p>Running <code>qtile migrate --lint</code> on the same config as shown above will result in the following output:</p> <pre><code>config.py:\n[Ln 1, Col 7]: The 'libqtile.command_*' modules have been moved to 'libqtile.command.*'. (ModuleRenames)\n[Ln 8, Col 8]: The use of mode='mode name' for KeyChord is deprecated. Use mode=True and value='mode name'. (UpdateKeychordArgs)\n[Ln 12, Col 6]: Use of 'cmd_' prefix is deprecated. 'cmd_spawn' should be replaced with 'spawn' (RemoveCmdPrefix)\n</code></pre>"},{"location":"manual/commands/shell/qtile-migrate/#explanations-of-migrations","title":"Explanations of migrations","text":"<p>The table below provides more detail of the available migrations.</p> <p>.. qtile_migrations::   :help:</p>"},{"location":"manual/commands/shell/qtile-run/","title":"qtile run-cmd","text":"<p>Run a command applying rules to the new windows, ie, you can start a window in a specific group, make it floating, intrusive, etc.</p> <p>The Windows must have NET_WM_PID.</p> <pre><code># run xterm floating on group \"test-group\"\nqtile run-cmd -g test-group -f xterm\n</code></pre>"},{"location":"manual/commands/shell/qtile-shell/","title":"qtile shell","text":"<p>The Qtile command shell is a command-line shell interface that provides access to the full complement of Qtile command functions. The shell features command name completion, and full command documentation can be accessed from the shell itself. The shell uses GNU Readline when it's available, so the interface can be configured to, for example, obey VI keybindings with an appropriate <code>.inputrc</code> file. See the GNU Readline documentation for more information.</p>"},{"location":"manual/commands/shell/qtile-shell/#navigating-the-object-graph","title":"Navigating the Object Graph","text":"<p>The shell presents a filesystem-like interface to the command graph - the builtin \"cd\" and \"ls\" commands act like their familiar shell counterparts:</p> <pre><code>&gt; ls\nlayout/  widget/  screen/  bar/     window/  group/\n\n&gt; cd screen\nlayout/  window/  bar/  widget/\n\n&gt; cd ..\n/\n\n&gt; ls\nlayout/  widget/  screen/  bar/     window/  group/\n</code></pre> <p>If you try to access an object that has no \"default\" value then you will see an error message:</p> <pre><code>&gt; ls\nlayout/  widget/  screen/  bar/     window/  group/\n\n&gt; cd bar\nItem required for bar\n\n&gt; ls bar\nbar[bottom]/\n\n&gt; cd bar/bottom\nbar['bottom']&gt; ls\nscreen/  widget/\n</code></pre> <p>Please refer to Navigating the command graph for a summary of which objects need a specified selector and the type of selector required. Using <code>ls</code> will show which selectors are available for an object. Please see below for an explanation about how Qtile displays shell paths.</p> <p>Alternatively, the <code>items()</code> command can be run on the parent object to show which selectors are available. The first value shows whether a selector is optional (<code>False</code> means that a selector is required) and the second value is a list of selectors:</p> <pre><code>&gt; ls\nlayout/  widget/  screen/  bar/     window/  group/\n\n&gt; items(bar)\n(False, ['bottom'])\n</code></pre>"},{"location":"manual/commands/shell/qtile-shell/#displaying-the-shell-path","title":"Displaying the shell path","text":"<p>Note that the shell provides a \"short-hand\" for specifying node keys (as opposed to children). The following is a valid shell path:</p> <pre><code>&gt; cd group/4/window/31457314\n</code></pre> <p>The command prompt will, however, always display the Python node path that should be used in scripts and key bindings:</p> <pre><code>group['4'].window[31457314]&gt;\n</code></pre>"},{"location":"manual/commands/shell/qtile-shell/#live-documentation","title":"Live Documentation","text":"<p>The shell <code>help</code> command provides the canonical documentation for the Qtile API:</p> <pre><code>&gt; cd layout/1\n\nlayout[1]&gt; help\nhelp command   -- Help for a specific command.\n\nBuiltins\n========\ncd    exit  help  ls    q     quit\n\nCommands for this object\n========================\nadd           commands      current       delete        doc\ndown          get_info      items         next          previous\nrotate        shuffle_down  shuffle_up    toggle_split  up\n\nlayout[1]&gt; help previous\nprevious()\nFocus previous stack.\n</code></pre>"},{"location":"manual/commands/shell/qtile-start/","title":"qtile start","text":"<p>This is the entry point for the window manager, and what you should run from your <code>.xsession</code> or similar. This will make an attempt to detect if qtile is already running and fail if it is. See <code>qtile start --help</code> for more details.</p>"},{"location":"manual/commands/shell/qtile-top/","title":"qtile top","text":"<p><code>qtile top</code> is a <code>top</code>-like tool to measure memory usage of Qtile's internals.</p> <p>Note</p> <p>To use <code>qtile shell</code> you need to have <code>tracemalloc</code> enabled. You can do this by setting the environmental variable <code>PYTHONTRACEMALLOC=1</code> before starting qtile. Alternatively, you can force start <code>tracemalloc</code> but you will lose early traces:</p> <pre><code>&gt;&gt;&gt; from libqtile.command.client import InteractiveCommandClient\n&gt;&gt;&gt; i=InteractiveCommandClient()\n&gt;&gt;&gt; i.eval(\"import tracemalloc;tracemalloc.start()\")\n</code></pre>"},{"location":"manual/config/","title":"The config file","text":"<p>Qtile is configured in Python. A script (<code>~/.config/qtile/config.py</code> by default) is evaluated, and a small set of configuration variables are pulled from its global namespace.</p>"},{"location":"manual/config/#configuration-lookup-order","title":"Configuration lookup order","text":"<p>Qtile looks in the following places for a configuration file, in order:</p> <ul> <li>The location specified by the <code>-c</code> argument.</li> <li><code>$XDG_CONFIG_HOME/qtile/config.py</code>, if it is set</li> <li><code>~/.config/qtile/config.py</code></li> <li>first <code>qtile/config.py</code> found in <code>$XDG_CONFIG_DIRS</code> (defaults to <code>/etc/xdg</code>)</li> <li>It reads the module <code>libqtile.resources.default_config</code>, included by   default with every Qtile installation.</li> </ul> <p>Qtile will try to create the configuration file as a copy of the default config, if it doesn't exist yet, this one will be placed inside of  <code>$XDG_CONFIG_HOME/qtile/config.py</code> (if set) or <code>~/.config/qtile/config.py</code>.</p>"},{"location":"manual/config/#default-configuration","title":"Default Configuration","text":"<p>The default configuration is invoked when qtile cannot find a configuration file. In addition, if qtile is restarted or the config is reloaded, qtile will load the default configuration if the config file it finds has some kind of error in it. The documentation below describes the configuration lookup process, as well as what the key bindings are in the default config.</p> <p>The default config is not intended to be suitable for all users; it's mostly just there so qtile does /something/ when fired up, and so that it doesn't crash and cause you to lose all your work if you reload a bad config.</p>"},{"location":"manual/config/#configuration-variables","title":"Configuration variables","text":"<p>A Qtile configuration consists of a file with a bunch of variables in it, which qtile imports and then runs as a Python file to derive its final configuration. The documentation below describes the most common configuration variables; more advanced configuration can be found in the qtile-examples repository, which includes a number of real-world configurations that demonstrate how you can tune Qtile to your liking. (Feel free to issue a pull request to add your own configuration to the mix!)</p> <ul> <li>Lazy objects</li> <li>Groups</li> <li>Keys</li> <li>Layouts</li> <li>Mouse</li> <li>Screens</li> <li>Hooks</li> </ul> <p>In addition to the above variables, there are several other boolean configuration variables that control specific aspects of Qtile's behavior:</p>"},{"location":"manual/config/#auto_fullscreen","title":"<code>auto_fullscreen</code>","text":"<p>Default: <code>True</code>. If a window requests to be fullscreen, it is automatically fullscreened. Set this to false if you only want windows to be fullscreen if you ask them to be.</p>"},{"location":"manual/config/#bring_front_click","title":"<code>bring_front_click</code>","text":"<p>Default: <code>False</code>. When clicked, should the window be brought to the front or not. If this is set to \"floating_only\", only floating windows will get affected (this sets the X Stack Mode to Above). This will ignore the layering rules and will therefore bring windows above other windows, even if they have been set as \"kept_above\". This may cause issues with docks and other similar apps as these may end up hidden behind other windows. Setting this to <code>False</code> or <code>\"floating_only\"</code> may therefore be required when using these apps.</p>"},{"location":"manual/config/#cursor_warp","title":"<code>cursor_warp</code>","text":"<p>Default: <code>False</code>. If true, the cursor follows the focus as directed by the keyboard, warping to the center of the focused window. When switching focus between screens, If there are no windows in the screen, the cursor will warp to the center of the screen.</p>"},{"location":"manual/config/#dgroups_key_binder","title":"<code>dgroups_key_binder</code>","text":"<p>Default: <code>None</code>. A function which generates group binding hotkeys. It takes a single argument, the DGroups object, and can use that to set up dynamic key bindings.</p> <p>A sample implementation is available in libqtile/dgroups.py called simple_key_binder(), which will bind groups to mod+shift+0-10 by default.</p>"},{"location":"manual/config/#dgroups_app_rules","title":"<code>dgroups_app_rules</code>","text":"<p>Default: <code>[]</code>. A list of Rule objects which can send windows to various groups based on matching criteria.</p>"},{"location":"manual/config/#extension_defaults","title":"<code>extension_defaults</code>","text":"<p>Default: <code>dict(font=\"sans\", fontsize=12, padding=3)</code>. Default settings for extensions.</p>"},{"location":"manual/config/#floating_layout","title":"<code>floating_layout</code>","text":"<p>Default: <code>layout.Floating(float_rules=[...])</code>. The default floating layout to use. This allows you to set custom floating rules among other things if you wish.</p> <p>See the configuration file for the default <code>float_rules</code>.</p>"},{"location":"manual/config/#floats_kept_above","title":"<code>floats_kept_above</code>","text":"<p>Default: <code>True</code>. Floating windows are kept above tiled windows (Currently x11 only. Wayland support coming soon.)</p>"},{"location":"manual/config/#focus_on_window_activation","title":"<code>focus_on_window_activation</code>","text":"<p>Default: <code>'smart'</code>. Behavior of the _NET_ACTIVATE_WINDOW message sent by applications:</p> <ul> <li>urgent: urgent flag is set for the window</li> <li>focus: automatically focus the window</li> <li>smart: automatically focus if the window is in the current group</li> <li>never: never automatically focus any window that requests it</li> </ul>"},{"location":"manual/config/#follow_mouse_focus","title":"<code>follow_mouse_focus</code>","text":"<p>Default: <code>True</code>. Controls whether or not focus follows the mouse around as it moves across windows in a layout.</p>"},{"location":"manual/config/#widget_defaults","title":"<code>widget_defaults</code>","text":"<p>Default: <code>dict(font='sans', fontsize=12, padding=3)</code>. Default settings for bar widgets.</p>"},{"location":"manual/config/#reconfigure_screens","title":"<code>reconfigure_screens</code>","text":"<p>Default: <code>True</code>. Controls whether or not to automatically reconfigure screens when there are changes in randr output configuration.</p>"},{"location":"manual/config/#wmname","title":"<code>wmname</code>","text":"<p>Default: <code>'LG3D'</code>. Gasp! We're lying here. In fact, nobody really uses or cares about this string besides java UI toolkits; you can see several discussions on the mailing lists, GitHub issues, and other WM documentation that suggest setting this string if your java app doesn't work correctly. We may as well just lie and say that we're a working one by default. We choose LG3D to maximize irony: it is a 3D non-reparenting WM written in java that happens to be on java's whitelist.</p>"},{"location":"manual/config/#auto_minimize","title":"<code>auto_minimize</code>","text":"<p>Default: <code>True</code>. If things like steam games want to auto-minimize themselves when losing focus, should we respect this or not?</p>"},{"location":"manual/config/#testing-your-configuration","title":"Testing your configuration","text":"<p>The best way to test changes to your configuration is with the provided scripts at ./scripts/xephyr (X11) or ./scripts/wephyr (Wayland). This will run Qtile with your <code>config.py</code> inside a nested window and prevent your running instance of Qtile from crashing if something goes wrong.</p> <p>See Hacking Qtile for more information on using Xephyr.</p>"},{"location":"manual/config/default/","title":"Default Config File","text":"<p>The below default config file is included with the Qtile package and will be copied to your home config folder (~/.config/qtile/config.py) if no config file exists when you start Qtile for the first time.</p> <pre><code># Copyright (c) 2010 Aldo Cortesi\n# Copyright (c) 2010, 2014 dequis\n# Copyright (c) 2012 Randall Ma\n# Copyright (c) 2012-2014 Tycho Andersen\n# Copyright (c) 2012 Craig Barnes\n# Copyright (c) 2013 horsik\n# Copyright (c) 2013 Tao Sauvage\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom libqtile import bar, layout, qtile, widget\nfrom libqtile.config import Click, Drag, Group, Key, Match, Screen\nfrom libqtile.lazy import lazy\nfrom libqtile.utils import guess_terminal\n\nmod = \"mod4\"\nterminal = guess_terminal()\n\nkeys = [\n    # A list of available commands that can be bound to keys can be found\n    # at https://docs.qtile.org/en/latest/manual/config/lazy.html\n    # Switch between windows\n    Key([mod], \"h\", lazy.layout.left(), desc=\"Move focus to left\"),\n    Key([mod], \"l\", lazy.layout.right(), desc=\"Move focus to right\"),\n    Key([mod], \"j\", lazy.layout.down(), desc=\"Move focus down\"),\n    Key([mod], \"k\", lazy.layout.up(), desc=\"Move focus up\"),\n    Key([mod], \"space\", lazy.layout.next(), desc=\"Move window focus to other window\"),\n    # Move windows between left/right columns or move up/down in current stack.\n    # Moving out of range in Columns layout will create new column.\n    Key([mod, \"shift\"], \"h\", lazy.layout.shuffle_left(), desc=\"Move window to the left\"),\n    Key([mod, \"shift\"], \"l\", lazy.layout.shuffle_right(), desc=\"Move window to the right\"),\n    Key([mod, \"shift\"], \"j\", lazy.layout.shuffle_down(), desc=\"Move window down\"),\n    Key([mod, \"shift\"], \"k\", lazy.layout.shuffle_up(), desc=\"Move window up\"),\n    # Grow windows. If current window is on the edge of screen and direction\n    # will be to screen edge - window would shrink.\n    Key([mod, \"control\"], \"h\", lazy.layout.grow_left(), desc=\"Grow window to the left\"),\n    Key([mod, \"control\"], \"l\", lazy.layout.grow_right(), desc=\"Grow window to the right\"),\n    Key([mod, \"control\"], \"j\", lazy.layout.grow_down(), desc=\"Grow window down\"),\n    Key([mod, \"control\"], \"k\", lazy.layout.grow_up(), desc=\"Grow window up\"),\n    Key([mod], \"n\", lazy.layout.normalize(), desc=\"Reset all window sizes\"),\n    # Toggle between split and unsplit sides of stack.\n    # Split = all windows displayed\n    # Unsplit = 1 window displayed, like Max layout, but still with\n    # multiple stack panes\n    Key(\n        [mod, \"shift\"],\n        \"Return\",\n        lazy.layout.toggle_split(),\n        desc=\"Toggle between split and unsplit sides of stack\",\n    ),\n    Key([mod], \"Return\", lazy.spawn(terminal), desc=\"Launch terminal\"),\n    # Toggle between different layouts as defined below\n    Key([mod], \"Tab\", lazy.next_layout(), desc=\"Toggle between layouts\"),\n    Key([mod], \"w\", lazy.window.kill(), desc=\"Kill focused window\"),\n    Key(\n        [mod],\n        \"f\",\n        lazy.window.toggle_fullscreen(),\n        desc=\"Toggle fullscreen on the focused window\",\n    ),\n    Key([mod], \"t\", lazy.window.toggle_floating(), desc=\"Toggle floating on the focused window\"),\n    Key([mod, \"control\"], \"r\", lazy.reload_config(), desc=\"Reload the config\"),\n    Key([mod, \"control\"], \"q\", lazy.shutdown(), desc=\"Shutdown Qtile\"),\n    Key([mod], \"r\", lazy.spawncmd(), desc=\"Spawn a command using a prompt widget\"),\n]\n\n# Add key bindings to switch VTs in Wayland.\n# We can't check qtile.core.name in default config as it is loaded before qtile is started\n# We therefore defer the check until the key binding is run by using .when(func=...)\nfor vt in range(1, 8):\n    keys.append(\n        Key(\n            [\"control\", \"mod1\"],\n            f\"f{vt}\",\n            lazy.core.change_vt(vt).when(func=lambda: qtile.core.name == \"wayland\"),\n            desc=f\"Switch to VT{vt}\",\n        )\n    )\n\n\ngroups = [Group(i) for i in \"123456789\"]\n\nfor i in groups:\n    keys.extend(\n        [\n            # mod + group number = switch to group\n            Key(\n                [mod],\n                i.name,\n                lazy.group[i.name].toscreen(),\n                desc=\"Switch to group {}\".format(i.name),\n            ),\n            # mod + shift + group number = switch to &amp; move focused window to group\n            Key(\n                [mod, \"shift\"],\n                i.name,\n                lazy.window.togroup(i.name, switch_group=True),\n                desc=\"Switch to &amp; move focused window to group {}\".format(i.name),\n            ),\n            # Or, use below if you prefer not to switch to that group.\n            # # mod + shift + group number = move focused window to group\n            # Key([mod, \"shift\"], i.name, lazy.window.togroup(i.name),\n            #     desc=\"move focused window to group {}\".format(i.name)),\n        ]\n    )\n\nlayouts = [\n    layout.Columns(border_focus_stack=[\"#d75f5f\", \"#8f3d3d\"], border_width=4),\n    layout.Max(),\n    # Try more layouts by unleashing below layouts.\n    # layout.Stack(num_stacks=2),\n    # layout.Bsp(),\n    # layout.Matrix(),\n    # layout.MonadTall(),\n    # layout.MonadWide(),\n    # layout.RatioTile(),\n    # layout.Tile(),\n    # layout.TreeTab(),\n    # layout.VerticalTile(),\n    # layout.Zoomy(),\n]\n\nwidget_defaults = dict(\n    font=\"sans\",\n    fontsize=12,\n    padding=3,\n)\nextension_defaults = widget_defaults.copy()\n\nscreens = [\n    Screen(\n        bottom=bar.Bar(\n            [\n                widget.CurrentLayout(),\n                widget.GroupBox(),\n                widget.Prompt(),\n                widget.WindowName(),\n                widget.Chord(\n                    chords_colors={\n                        \"launch\": (\"#ff0000\", \"#ffffff\"),\n                    },\n                    name_transform=lambda name: name.upper(),\n                ),\n                widget.TextBox(\"default config\", name=\"default\"),\n                widget.TextBox(\"Press &amp;lt;M-r&amp;gt; to spawn\", foreground=\"#d75f5f\"),\n                # NB Systray is incompatible with Wayland, consider using StatusNotifier instead\n                # widget.StatusNotifier(),\n                widget.Systray(),\n                widget.Clock(format=\"%Y-%m-%d %a %I:%M %p\"),\n                widget.QuickExit(),\n            ],\n            24,\n            # border_width=[2, 0, 2, 0],  # Draw top and bottom borders\n            # border_color=[\"ff00ff\", \"000000\", \"ff00ff\", \"000000\"]  # Borders are magenta\n        ),\n        # You can uncomment this variable if you see that on X11 floating resize/moving is laggy\n        # By default we handle these events delayed to already improve performance, however your system might still be struggling\n        # This variable is set to None (no cap) by default, but you can set it to 60 to indicate that you limit it to 60 events per second\n        # x11_drag_polling_rate = 60,\n    ),\n]\n\n# Drag floating layouts.\nmouse = [\n    Drag([mod], \"Button1\", lazy.window.set_position_floating(), start=lazy.window.get_position()),\n    Drag([mod], \"Button3\", lazy.window.set_size_floating(), start=lazy.window.get_size()),\n    Click([mod], \"Button2\", lazy.window.bring_to_front()),\n]\n\ndgroups_key_binder = None\ndgroups_app_rules = []  # type: list\nfollow_mouse_focus = True\nbring_front_click = False\nfloats_kept_above = True\ncursor_warp = False\nfloating_layout = layout.Floating(\n    float_rules=[\n        # Run the utility of `xprop` to see the wm class and name of an X client.\n        *layout.Floating.default_float_rules,\n        Match(wm_class=\"confirmreset\"),  # gitk\n        Match(wm_class=\"makebranch\"),  # gitk\n        Match(wm_class=\"maketag\"),  # gitk\n        Match(wm_class=\"ssh-askpass\"),  # ssh-askpass\n        Match(title=\"branchdialog\"),  # gitk\n        Match(title=\"pinentry\"),  # GPG key password entry\n    ]\n)\nauto_fullscreen = True\nfocus_on_window_activation = \"smart\"\nreconfigure_screens = True\n\n# If things like steam games want to auto-minimize themselves when losing\n# focus, should we respect this or not?\nauto_minimize = True\n\n# When using the Wayland backend, this can be used to configure input devices.\nwl_input_rules = None\n\n# XXX: Gasp! We're lying here. In fact, nobody really uses or cares about this\n# string besides java UI toolkits; you can see several discussions on the\n# mailing lists, GitHub issues, and other WM documentation that suggest setting\n# this string if your java app doesn't work correctly. We may as well just lie\n# and say that we're a working one by default.\n#\n# We choose LG3D to maximize irony: it is a 3D non-reparenting WM written in\n# java that happens to be on java's whitelist.\nwmname = \"LG3D\"\n</code></pre>"},{"location":"manual/config/groups/","title":"Groups","text":"<p>A group is a container for a bunch of windows, analogous to workspaces in other window managers. Each client window managed by the window manager belongs to exactly one group. The <code>groups</code> config file variable should be initialized to a list of <code>libqtile.config.Group</code> objects.</p> <p><code>libqtile.config.Group</code> objects provide several options for group configuration. Groups can be configured to show and hide themselves when they're not empty, spawn applications for them when they start, automatically acquire certain groups, and various other options.</p>"},{"location":"manual/config/groups/#group","title":"Group","text":""},{"location":"manual/config/groups/#example","title":"Example","text":"<pre><code>from libqtile.config import Group, Match\n\ngroups = [\n    Group(\"a\"),\n    Group(\"b\"),\n    Group(\"c\", matches=[Match(wm_class=[\"Firefox\"])]),\n]\n\n# allow mod3+1 through mod3+0 to bind to groups; if you bind your groups\n# by hand in your config, you don't need to do this.\nfrom libqtile.dgroups import simple_key_binder\n\ndgroups_key_binder = simple_key_binder(\"mod3\")\n</code></pre>"},{"location":"manual/config/groups/#reference","title":"Reference","text":"<p>.. qtile_class:: libqtile.config.Group</p>"},{"location":"manual/config/groups/#libqtile.dgroups.simple_key_binder","title":"simple_key_binder","text":"<pre><code>simple_key_binder(mod, keynames=None)\n</code></pre> <p>Bind keys to mod+group position or to the keys specified as second argument</p>"},{"location":"manual/config/groups/#group-matching","title":"Group Matching","text":"<p>.. qtile_class:: libqtile.config.Match    :no-commands:</p> <p>.. qtile_class:: libqtile.config.Rule    :no-commands:</p>"},{"location":"manual/config/groups/#scratchpad-and-dropdown","title":"ScratchPad and DropDown","text":"<p><code>libqtile.config.ScratchPad</code> is a special - by default invisible - group which acts as a container for <code>libqtile.config.DropDown</code> configurations. A <code>libqtile.config.DropDown</code> can be configured to spawn a defined process and bind thats process' window to it. The associated window can then be shown and hidden by the lazy command <code>dropdown_toggle</code> (see lazy objects) from the ScratchPad group.  Thus - for example - your favorite terminal emulator turns into a quake-like terminal by the control of Qtile.</p> <p>If the DropDown window turns visible it is placed as a floating window on top of the current group. If the DropDown is hidden, it is simply switched back to the ScratchPad group.</p>"},{"location":"manual/config/groups/#example_1","title":"Example","text":"<pre><code>from libqtile.config import Group, ScratchPad, DropDown, Key\nfrom libqtile.lazy import lazy\n\ngroups = [\n    ScratchPad(\"scratchpad\", [\n        # define a drop down terminal.\n        # it is placed in the upper third of screen by default.\n        DropDown(\"term\", \"urxvt\", opacity=0.8),\n\n        # define another terminal exclusively for `qtile shell` at different position\n        DropDown(\"qtile shell\", \"urxvt -hold -e 'qtile shell'\",\n                  x=0.05, y=0.4, width=0.9, height=0.6, opacity=0.9,\n                  on_focus_lost_hide=True) ]),\n    Group(\"a\"),\n]\n\nkeys = [\n    # toggle visibiliy of above defined DropDown named \"term\"\n    Key([], 'F11', lazy.group['scratchpad'].dropdown_toggle('term')),\n    Key([], 'F12', lazy.group['scratchpad'].dropdown_toggle('qtile shell')),\n]\n</code></pre> <p>Note that if the window is set to not floating, it is detached from DropDown and ScratchPad, and a new process is spawned next time the DropDown is set visible.</p> <p>Some programs run in a server-like mode where the spawned process does not directly own the window that is created, which is instead created by a background process. In this case, the window may not be correctly caught in the scratchpad group. To work around this, you can pass a <code>libqtile.config.Match</code> object to the corresponding <code>libqtile.config.DropDown</code>. See below.</p>"},{"location":"manual/config/groups/#reference_1","title":"Reference","text":"<p>.. qtile_class:: libqtile.config.ScratchPad</p> <p>.. qtile_class:: libqtile.config.DropDown</p>"},{"location":"manual/config/hooks/","title":"Hooks","text":"<p>Qtile provides a mechanism for subscribing to certain events in <code>libqtile.hook</code>. To subscribe to a hook in your configuration, simply decorate a function with the hook you wish to subscribe to.</p> <p>See built-in hooks for a listing of available hooks.</p>"},{"location":"manual/config/hooks/#examples","title":"Examples","text":""},{"location":"manual/config/hooks/#automatic-floating-dialogs","title":"Automatic floating dialogs","text":"<p>Let's say we wanted to automatically float all dialog windows (this code is not actually necessary; Qtile floats all dialogs by default). We would subscribe to the <code>client_new</code> hook to tell us when a new window has opened and, if the type is \"dialog\", as can set the window to float. In our configuration file it would look something like this:</p> <pre><code>from libqtile import hook\n\n@hook.subscribe.client_new\ndef floating_dialogs(window):\n    dialog = window.window.get_wm_type() == 'dialog'\n    transient = window.window.get_wm_transient_for()\n    if dialog or transient:\n        window.floating = True\n</code></pre> <p>A list of available hooks can be found in the built-in hooks reference.</p>"},{"location":"manual/config/hooks/#autostart","title":"Autostart","text":"<p>If you want to run commands or spawn some applications when Qtile starts, you'll want to look at the <code>startup</code> and <code>startup_once</code> hooks. <code>startup</code> is emitted every time Qtile starts (including restarts), whereas <code>startup_once</code> is only emitted on the very first startup.</p> <p>Let's create an executable file <code>~/.config/qtile/autostart.sh</code> that will start a few programs when Qtile first runs. Remember to <code>chmod +x ~/.config/qtile/autostart.sh</code> so that it can be executed.</p> <pre><code>#!/bin/sh\npidgin &amp;\ndropbox start &amp;\n</code></pre> <p>We can then subscribe to <code>startup_once</code> to run this script:</p> <pre><code>import os\nimport subprocess\n\nfrom libqtile import hook\n\n@hook.subscribe.startup_once\ndef autostart():\n    home = os.path.expanduser('~/.config/qtile/autostart.sh')\n    subprocess.Popen([home])\n</code></pre>"},{"location":"manual/config/hooks/#accessing-the-qtile-object","title":"Accessing the qtile object","text":"<p>If you want to do something with the <code>Qtile</code> manager instance inside a hook, it can be imported into your config:</p> <pre><code>from libqtile import qtile\n</code></pre>"},{"location":"manual/config/hooks/#async-hooks","title":"Async hooks","text":"<p>Hooks can also be defined as coroutine functions using <code>async def</code>, which will run them asynchronously in the event loop:</p> <pre><code>@hook.subscribe.focus_change\nasync def _():\n    ...\n</code></pre>"},{"location":"manual/config/keys/","title":"Keys","text":"<p>The <code>keys</code> variable defines Qtile's key bindings. </p>"},{"location":"manual/config/keys/#default-key-bindings","title":"Default Key Bindings","text":"<p>The mod key for the default config is <code>mod4</code>, which is typically bound to the \"Super\" keys, which are things like the windows key and the mac command key. The basic operation is:</p> <ul> <li><code>mod + k</code> or <code>mod + j</code>: switch windows on the current stack</li> <li><code>mod + &lt;space&gt;</code>: put focus on the other pane of the stack (when in stack   layout)</li> <li><code>mod + &lt;tab&gt;</code>: switch layouts</li> <li><code>mod + w</code>: close window</li> <li><code>mod + &lt;ctrl&gt; + r</code>: reload the config</li> <li><code>mod + &lt;group name&gt;</code>: switch to that group</li> <li><code>mod + &lt;shift&gt; + &lt;group name&gt;</code>: send a window to that group</li> <li><code>mod + &lt;enter&gt;</code>: start terminal guessed by <code>libqtile.utils.guess_terminal</code></li> <li><code>mod + r</code>: start a little prompt in the bar so users can run arbitrary   commands</li> </ul> <p>The default config defines one screen and 8 groups, one for each letter in <code>asdfuiop</code>. It has a basic bottom bar that includes a group box, the current window name, a little text reminder that you're using the default config, a system tray, and a clock.</p> <p>The default configuration has several more advanced key combinations, but the above should be enough for basic usage of qtile.</p> <p>See Keybindings in images for visual keybindings in keyboard layout.</p>"},{"location":"manual/config/keys/#defining-key-bindings","title":"Defining Key Bindings","text":"<p>Individual key bindings are defined with <code>libqtile.config.Key</code> as demonstrated in the following example. Note that you may specify more than one callback functions.</p> <pre><code>from libqtile.config import Key\n\nkeys = [\n    # Pressing \"Meta + Shift + a\".\n    Key([\"mod4\", \"shift\"], \"a\", callback, ...),\n\n    # Pressing \"Control + p\".\n    Key([\"control\"], \"p\", callback, ...),\n\n    # Pressing \"Meta + Tab\".\n    Key([\"mod4\", \"mod1\"], \"Tab\", callback, ...),\n]\n</code></pre> <p>The above may also be written more concisely with the help of the <code>libqtile.config.EzKey</code> helper class. The following example is functionally equivalent to the above:</p> <pre><code>from libqtile.config import EzKey as Key\n\nkeys = [\n    Key(\"M-S-a\", callback, ...),\n    Key(\"C-p\",   callback, ...),\n    Key(\"M-A-&lt;Tab&gt;\", callback, ...),\n]\n</code></pre> <p>The [<code>libqtile.config.EzKey</code> modifier keys (i.e. <code>MASC</code>][]) can be overwritten through the <code>EzKey.modifier_keys</code> dictionary. The defaults are::</p> <pre><code>modifier_keys = {\n    'M': 'mod4',\n    'A': 'mod1',\n    'S': 'shift',\n    'C': 'control',\n}\n</code></pre> <p>Callbacks can also be configured to work only under certain conditions by using the <code>libqtile.lazy.LazyCall.when</code> method. Currently, the following conditions are supported:</p> <pre><code>from libqtile.config import Key\n\nkeys = [\n    # Only trigger callback for a specific layout\n    Key(\n        [mod, 'shift'],\n        \"j\",\n        lazy.layout.grow().when(layout='verticaltile'),\n        lazy.layout.grow_down().when(layout='columns')\n    ),\n\n    # Limit action to when the current window is not floating (default True)\n    Key([mod], \"f\", lazy.window.toggle_fullscreen().when(when_floating=False))\n\n    # Also matches are supported on the current window\n    # For example to match on the wm_class for fullscreen do the following\n    Key([mod], \"f\", lazy.window.toggle_fullscreen().when(focused=Match(wm_class=\"yourclasshere\"))\n]\n</code></pre>"},{"location":"manual/config/keys/#keychords","title":"KeyChords","text":"<p>Qtile also allows sequences of keys to trigger callbacks. These sequences are known as chords and are defined with <code>libqtile.config.KeyChord</code>. Chords are added to the <code>keys</code> section of the config file.</p> <pre><code>from libqtile.config import Key, KeyChord\n\nkeys = [\n    KeyChord([mod], \"z\", [\n        Key([], \"x\", lazy.spawn(\"xterm\"))\n    ])\n]\n</code></pre> <p>The above code will launch xterm when the user presses Mod + z, followed by x.</p> <p>Warning</p> <p> Users should note that key chords are aborted by pressing . In the above example, if the user presses Mod + z, any following key presses will still be sent to the currently focussed window. If  has not been pressed, the next press of x will launch xterm."},{"location":"manual/config/keys/#modes","title":"Modes","text":"<p>Chords can optionally persist until a user presses . This can be done by setting <code>mode=True</code>. This can be useful for configuring a subset of commands for a particular situations (i.e. similar to vim modes). <pre><code>from libqtile.config import Key, KeyChord\n\nkeys = [\n    KeyChord([mod], \"z\", [\n        Key([], \"g\", lazy.layout.grow()),\n        Key([], \"s\", lazy.layout.shrink()),\n        Key([], \"n\", lazy.layout.normalize()),\n        Key([], \"m\", lazy.layout.maximize())],\n        mode=True,\n        name=\"Windows\"\n    )\n]\n</code></pre> <p>In the above example, pressing Mod + z triggers the \"Windows\" mode. Users can then resize windows by just pressing g (to grow the window), s to shrink it etc. as many times as needed. To exit the mode, press . <p>Note</p> <p> The Chord widget (<code>libqtile.widget.Chord</code>) will display the name of the active chord (as set by the <code>name</code> parameter). This is particularly useful where the chord is a persistent mode as this will indicate when the chord's mode is still active.</p>"},{"location":"manual/config/keys/#chains","title":"Chains","text":"<p>Chords can also be chained to make even longer sequences.</p> <pre><code>from libqtile.config import Key, KeyChord\n\nkeys = [\n    KeyChord([mod], \"z\", [\n        KeyChord([], \"x\", [\n            Key([], \"c\", lazy.spawn(\"xterm\"))\n        ])\n    ])\n]\n</code></pre> <p>Modes can also be added to chains if required. The following example demonstrates the behaviour when using the <code>mode</code> argument in chains:</p> <pre><code>from libqtile.config import Key, KeyChord\n\nkeys = [\n    KeyChord([mod], \"z\", [\n        KeyChord([], \"y\", [\n            KeyChord([], \"x\", [\n                Key([], \"c\", lazy.spawn(\"xterm\"))\n            ], mode=True, name=\"inner\")\n        ])\n    ], mode=True, name=\"outer\")\n]\n</code></pre> <p>After pressing Mod+z y x c, the \"inner\" mode will remain active. When pressing , the \"inner\" mode is exited. Since the mode in between does not have <code>mode</code> set, it is also left. Arriving at the \"outer\" mode (which has this argument set) stops the \"leave\" action and \"outer\" now becomes the active mode. <p>Note</p> <p> If you want to bind a custom key to leave the current mode (e.g. Control + G in addition to <code>&lt;escape&gt;</code>), you can specify <code>lazy.ungrab_chord()</code> as the key action. To leave all modes and return to the root bindings, use <code>lazy.ungrab_all_chords()</code>.</p>"},{"location":"manual/config/keys/#modifiers","title":"Modifiers","text":"<p>On most systems <code>mod1</code> is the Alt key - you can see which modifiers, which are enclosed in a list, map to which keys on your system by running the <code>xmodmap</code> command. This example binds <code>Alt-k</code> to the \"down\" command on the current layout. This command is standard on all the included layouts, and switches to the next window (where \"next\" is defined differently in different layouts). The matching \"up\" command switches to the previous window.</p> <p>Modifiers include: \"shift\", \"lock\", \"control\", \"mod1\", \"mod2\", \"mod3\", \"mod4\", and \"mod5\". They can be used in combination by appending more than one modifier to the list:</p> <pre><code>Key(\n    [\"mod1\", \"control\"], \"k\",\n    lazy.layout.shuffle_down()\n)\n</code></pre>"},{"location":"manual/config/keys/#special-keys","title":"Special keys","text":"<p>These are most commonly used special keys. For complete list please see the code. You can create bindings on them just like for the regular keys. For example <code>Key([\"mod1\"], \"F4\", lazy.window.kill())</code>.</p> <ul> <li><code>Return</code></li> <li><code>BackSpace</code></li> <li><code>Tab</code></li> <li><code>space</code></li> <li><code>Home</code>, <code>End</code></li> <li><code>Left</code>, <code>Up</code>, <code>Right</code>, <code>Down</code></li> <li><code>F1</code>, <code>F2</code>, <code>F3</code>, ...</li> <li><code>XF86AudioRaiseVolume</code></li> <li><code>XF86AudioLowerVolume</code></li> <li><code>XF86AudioMute</code></li> <li><code>XF86AudioNext</code></li> <li><code>XF86AudioPrev</code></li> <li><code>XF86MonBrightnessUp</code></li> <li><code>XF86MonBrightnessDown</code></li> </ul>"},{"location":"manual/config/keys/#reference","title":"Reference","text":"<p>.. qtile_class:: libqtile.config.Key    :no-commands:</p> <p>.. qtile_class:: libqtile.config.KeyChord    :no-commands:</p> <p>.. qtile_class:: libqtile.config.EzKey    :no-commands:</p>"},{"location":"manual/config/layouts/","title":"Layouts","text":"<p>A layout is an algorithm for laying out windows in a group on your screen. Since Qtile is a tiling window manager, this usually means that we try to use space as efficiently as possible, and give the user ample commands that can be bound to keys to interact with layouts.</p> <p>The <code>layouts</code> variable defines the list of layouts you will use with Qtile. The first layout in the list is the default. If you define more than one layout, you will probably also want to define key bindings to let you switch to the next and previous layouts.</p> <p>See built-in layouts for a listing of available layouts.</p>"},{"location":"manual/config/layouts/#example","title":"Example","text":"<pre><code>from libqtile import layout\n\nlayouts = [\n    layout.Max(),\n    layout.Stack(stacks=2)\n]\n</code></pre>"},{"location":"manual/config/lazy/","title":"Lazy objects","text":"<p>Lazy objects are a way of executing any of the commands available in Qtile's :doc:<code>commands API &lt;/manual/commands/api/index&gt;</code>. </p> <p>The name \"lazy\" refers to the fact that the commands are not executed at the time of the call. Instead, the lazy object creates a reference to the relevant command and this is only executed when the relevant event is triggered (e.g. on a keypress).</p> <p>Typically, for config files, the commands are used to manipulate windows, layouts and groups as well application commands like exiting, restarting, reloading the config file etc.</p>"},{"location":"manual/config/lazy/#example","title":"Example","text":"<pre><code>  from libqtile.config import Key\n  from libqtile.lazy import lazy\n\n  keys = [\n      Key(\n          [\"mod1\"], \"k\",\n          lazy.layout.down()\n      ),\n      Key(\n          [\"mod1\"], \"j\",\n          lazy.layout.up()\n      )\n  ]\n</code></pre> <p>Note</p> <p> As noted above, <code>lazy</code> calls do not call the relevant command but only create a reference to it. While this makes it ideal for binding commands to key presses and <code>mouse_callbacks</code> for widgets, it also means that <code>lazy</code> calls cannot be included in user-defined functions.</p>"},{"location":"manual/config/lazy/#lazy-functions","title":"Lazy functions","text":"<p>This is overview of the commonly used functions for the key bindings.  These functions can be called from commands on the REPLACE object or on another object in the command tree.</p> <p>Some examples are given below. For a complete list of available commands, please refer to :doc:<code>/manual/commands/api/index</code>.</p>"},{"location":"manual/config/lazy/#general-functions","title":"General functions","text":"function description <code>lazy.spawn(\"application\")</code> Run the <code>application</code>. <code>lazy.spawncmd()</code> Open command prompt on the bar. See prompt widget. <code>lazy.reload_config()</code> Reload the config. <code>lazy.restart()</code> Restart Qtile. In X11, it won't close your windows. <code>lazy.shutdown()</code> Close the whole Qtile."},{"location":"manual/config/lazy/#group-functions","title":"Group functions","text":"function description <code>lazy.next_layout()</code> Use next layout on the actual group <code>lazy.prev_layout()</code> Use previous layout on the actual group <code>lazy.screen.next_group()</code> Move to the group on the right <code>lazy.screen.prev_group()</code> Move to the group on the left <code>lazy.screen.toggle_group()</code> Move to the last visited group <code>lazy.group.next_window()</code> Switch window focus to next window in group <code>lazy.group.prev_window()</code> Switch window focus to previous window in group <code>lazy.group[\"group_name\"].toscreen()</code> Move to the group called <code>group_name</code><sup>1</sup>. <code>lazy.layout.increase_ratio()</code> Increase the space for master window at the expense of slave windows <code>lazy.layout.decrease_ratio()</code> Decrease the space for master window in the advantage of slave windows"},{"location":"manual/config/lazy/#window-functions","title":"Window functions","text":"function description <code>lazy.window.kill()</code> Close the focused window <code>lazy.layout.next()</code> Switch window focus to other pane(s) of stack <code>lazy.window.togroup(\"group_name\")</code> Move focused window to the group called <code>group_name</code> <code>lazy.window.toggle_floating()</code> Put the focused window to/from floating mode <code>lazy.window.toggle_fullscreen()</code> Put the focused window to/from fullscreen mode <code>lazy.window.move_up()</code> Move the window above the next window in the stack. <code>lazy.window.move_down()</code> Move the window below the previous window in the stack. <code>lazy.window.move_to_top()</code> Move the window above all other windows with similar priority (i.e. a \"normal\" window will not be moved above a <code>kept_above</code> window). <code>lazy.window.move_to_bottom()</code> Move the window below all other windows with similar priority (i.e. a \"normal\" window will not be moved below a <code>kept_below</code> window). <code>lazy.window.keep_above()</code> Keep window above other windows. <code>lazy.window.keep_below()</code> Keep window below other windows. <code>lazy.window.bring_to_front()</code> Bring window above all other windows. Ignores <code>kept_above</code> priority."},{"location":"manual/config/lazy/#screen-functions","title":"Screen functions","text":"function description <code>lazy.screen.set_wallpaper(path, mode=None)</code> Set the wallpaper to the specificied image. Possible modes: <code>None</code> no resizing, <code>'fill'</code> centre and resize to fill screen, <code>'stretch'</code> stretch to fill screen."},{"location":"manual/config/lazy/#scratchpad-dropdown-functions","title":"ScratchPad DropDown functions","text":"function description <code>lazy.group[\"group_name\"].dropdown_toggle(\"name\")</code> Toggles the visibility of the specified DropDown window. On first use, the configured process is spawned. <code>lazy.group[\"group_name\"].hide_all()</code> Hides all DropDown windows. <code>lazy.group[\"group_name\"].dropdown_reconfigure(\"name\", **configuration)</code> Update the configuration of the named DropDown."},{"location":"manual/config/lazy/#user-defined-functions","title":"User-defined functions","text":"function description <code>lazy.function(func, *args, **kwargs)</code> Calls <code>func(qtile, *args, **kwargs)</code>. NB. the <code>qtile</code> object is automatically passed as the first argument."},{"location":"manual/config/lazy/#examples","title":"Examples","text":"<p><code>lazy.function</code> can also be used as a decorator for functions.</p> <pre><code>from libqtile.config import Key\nfrom libqtile.lazy import lazy\n\n@lazy.function\ndef my_function(qtile):\n    ...\n\nkeys = [\n    Key(\n        [\"mod1\"], \"k\",\n        my_function\n    )\n]\n</code></pre> <p>Additionally, you can pass arguments to user-defined function in one of two ways:</p> <p>1) In-line definition</p> <p>Arguments can be added to the <code>lazy.function</code> call.</p> <pre><code>from libqtile.config import Key\nfrom libqtile.lazy import lazy\nfrom libqtile.log_utils import logger\n\ndef multiply(qtile, value, multiplier=10):\n    logger.warning(f\"Multiplication results: {value * multiplier}\")\n\nkeys = [\n    Key(\n        [\"mod1\"], \"k\",\n        lazy.function(multiply, 10, multiplier=2)\n    )\n]\n</code></pre> <p>2) Decorator</p> <p>Arguments can also be passed to the decorated function.</p> <pre><code>from libqtile.config import Key\nfrom libqtile.lazy import lazy\nfrom libqtile.log_utils import logger\n\n@lazy.function\ndef multiply(qtile, value, multiplier=10):\n    logger.warning(f\"Multiplication results: {value * multiplier}\")\n\nkeys = [\n    Key(\n        [\"mod1\"], \"k\",\n        multiply(10, multiplier=2)\n    )\n]\n</code></pre> <ol> <li> <p>Takes an optional <code>toggle</code> parameter (defaults to False).   If this group is already on the screen, it does nothing by default;   to toggle with the last used group instead, use <code>toggle=True</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"manual/config/match/","title":"Match","text":""},{"location":"manual/config/match/#matching-windows","title":"Matching windows","text":"<p>Qtile's config provides a number of situations where the behaviour depends on whether the relevant window matches some specified criteria.</p> <p>These situations include:</p> <ul> <li>Defining which windows should be floated by default</li> <li>Assigning windows to specific groups</li> <li>Assigning window to a master section of a layout</li> </ul> <p>In each instance, the criteria are defined via a <code>Match</code> object. The properties of the object will be compared to a <code>libqtile.base.Window</code> to determine if its properties match. It can match by title, wm_class, role, wm_type, wm_instance_class, net_wm_pid, or wid. Additionally, a function may be passed, which takes in the <code>libqtile.base.Window</code> to be compared against and returns a boolean.</p> <p>A basic rule would therefore look something like:</p> <pre><code>Match(wm_class=\"mpv\")\n</code></pre> <p>This would match against any window whose class was <code>mpv</code>.</p> <p>Where a string is provided as an argument then the value must match exactly. More flexibility can be achieved by using regular expressions. For example:</p> <pre><code>import re\n\nMatch(wm_class=re.compile(r\"mpv\"))\n</code></pre> <p>This would still match a window whose class was <code>mpv</code> but it would also match any class starting with <code>mpv</code> e.g. <code>mpvideo</code>.</p> <p>Note</p> <p> When providing a regular expression, qtile applies the <code>.match</code> method. This matches from the start of the string so, if you want to match any substring, you will need to adapt the regular expression accordingly e.g.</p> <pre><code>import re\n\nMatch(wm_class=re.compile(r\".*mpv\"))\n</code></pre> <p>This would match any string containing <code>mpv</code></p>"},{"location":"manual/config/match/#creating-advanced-rules","title":"Creating advanced rules","text":"<p>While the <code>func</code> parameter allows users to create more complex matches, this requires a knowledge of qtile's internal objects. An alternative is to combine Match objects using logical operators <code>&amp;</code> (and), <code>|</code> (or), <code>~</code> (not) and <code>^</code> (xor).</p> <p>For example, to create rule that matches all windows with a fixed aspect ratio except for mpv windows, you would provide the following:</p> <pre><code>Match(func=lambda c: c.has_fixed_ratio()) &amp; ~Match(wm_class=\"mpv\")\n</code></pre> <p>It is also possible to use wrappers for <code>Match</code> objects if you do not want to use the operators. The following wrappers are available:</p> <ul> <li><code>MatchAll(Match(...), ...)</code> equivalent to \"and\" test. All matches must match.</li> <li><code>MatchAny(Match(...), ...)</code> equivalent to \"or\" test. At least one match must match.</li> <li><code>MatchOnlyOne(Match(...), Match(...))</code> equivalent to \"xor\". Only one match must match.</li> <li><code>InvertMatch(Match(...))</code> equivalent to \"not\". Inverts the result of the match.</li> </ul> <p>So, to recreate the above rule using the wrappers, you would write the following:</p> <pre><code>from libqtile.config import InvertMatch, Match, MatchAll\n\nMatchAll(Match(func=lambda c: c.has_fixed_ratio()), InvertMatch(Match(wm_class=\"mpv\")))\n</code></pre>"},{"location":"manual/config/mouse/","title":"Mouse","text":"<p>The <code>mouse</code> config file variable defines a set of global mouse actions, and is a list of [<code>libqtile.config.Click</code>] and <code>libqtile.config.Drag</code> objects, which define what to do when a window is clicked or dragged.</p>"},{"location":"manual/config/mouse/#default-mouse-bindings","title":"Default Mouse Bindings","text":"<p>By default, holding your <code>mod</code> key and left-clicking (and holding) a window will allow you to drag it around as a floating window. Holding your <code>mod</code> key and right-clicking (and holding) a window will resize the window (and also make it float if it is not already floating).</p>"},{"location":"manual/config/mouse/#example","title":"Example","text":"<pre><code>from libqtile.config import Click, Drag\nmouse = [\n    Drag([mod], \"Button1\", lazy.window.set_position_floating(),\n        start=lazy.window.get_position()),\n    Drag([mod], \"Button3\", lazy.window.set_size_floating(),\n        start=lazy.window.get_size()),\n    Click([mod], \"Button2\", lazy.window.bring_to_front())\n]\n</code></pre> <p>The above example can also be written more concisely with the help of the <code>EzClick</code> and <code>EzDrag</code> helpers::</p> <pre><code>from libqtile.config import EzClick as Click, EzDrag as Drag\n\nmouse = [\n    Drag(\"M-1\", lazy.window.set_position_floating(),\n        start=lazy.window.get_position()),\n    Drag(\"M-3\", lazy.window.set_size_floating(),\n        start=lazy.window.get_size()),\n    Click(\"M-2\", lazy.window.bring_to_front())\n]\n</code></pre>"},{"location":"manual/config/mouse/#reference","title":"Reference","text":"<p>.. qtile_class:: libqtile.config.Click    :no-commands:</p> <p>.. qtile_class:: libqtile.config.Drag    :no-commands:</p> <p>.. qtile_class:: libqtile.config.EzClick    :no-commands:</p>"},{"location":"manual/config/screens/","title":"Screens","text":"<p>The <code>screens</code> configuration variable is where the physical screens, their associated <code>bars</code>, and the <code>widgets</code> contained within the bars are defined (see built-in widgets for a listing of available widgets). </p>"},{"location":"manual/config/screens/#example","title":"Example","text":"<p>Tying together screens, bars and widgets, we get something like this:</p> <pre><code>from libqtile.config import Screen\nfrom libqtile import bar, widget\n\nwindow_name = widget.WindowName()\n\nscreens = [\n    Screen(\n        bottom=bar.Bar([\n            widget.GroupBox(),\n            window_name,\n            ], 30\n        ),\n    ),\n    Screen(\n        bottom=bar.Bar([\n            widget.GroupBox(),\n            window_name,\n            ], 30\n        ),\n    )\n]\n</code></pre> <p>Note that a widget can be passed to multiple bars (and likewise multiple times to the same bar). Its contents is mirrored across all copies so this is useful where you want identical content (e.g. the name of the focussed window, like in this example).</p> <p>Bars support both solid background colors and gradients by supplying a list of colors that make up a linear gradient. For example, :code:<code>bar.Bar(..., background=\"#000000\")</code> will give you a black back ground (the default), while <code>bar.Bar(..., background=[\"#000000\", \"#FFFFFF\"])</code> will give you a background that fades from black to white.</p> <p>Bars (and widgets) also support transparency by adding an alpha value to the desired color. For example, <code>bar.Bar(..., background=\"#00000000\")</code> will result in a fully transparent bar. Widget contents will not be impacted i.e. this is different to the <code>opacity</code> parameter which sets the transparency of the entire window.</p> <p>Note</p> <p> In X11 backends, transparency will be disabled in a bar if the <code>background</code> color is fully opaque.</p> <p>Users can add borders to the bar by using the <code>border_width</code> and <code>border_color</code> parameters. Providing a single value sets the value for all four sides while sides can be customised individually by setting four values in a list (top, right, bottom, left) e.g. <code>border_width=[2, 0, 2, 0]</code> would draw a border 2 pixels thick on the top and bottom of the bar.</p>"},{"location":"manual/config/screens/#multiple-screens","title":"Multiple Screens","text":"<p>You will see from the example above that <code>screens</code> is a list of individual <code>Screen</code> objects. The order of the screens in this list should match the order of screens as seen by your display server.</p>"},{"location":"manual/config/screens/#x11","title":"X11","text":"<p>You can view the current order of your screens by running <code>xrandr --listmonitors</code>.</p> <p>Examples of how to set the order of your screens can be found on the Arch wiki.</p>"},{"location":"manual/config/screens/#wayland","title":"Wayland","text":"<p>The Wayland backend supports the wlr-output-management protocol for configuration of outputs by tools such as Kanshi.</p>"},{"location":"manual/config/screens/#fake-screens","title":"Fake Screens","text":"<p>instead of using the variable <code>screens</code> the variable <code>fake_screens</code> can be used to set split a physical monitor into multiple screens. They can be used like this:</p> <pre><code>from libqtile.config import Screen\nfrom libqtile import bar, widget\n\n# screens look like this\n#     600         300\n#  |-------------|-----|\n#  |          480|     |580\n#  |   A         |  B  |\n#  |----------|--|     |\n#  |       400|--|-----|\n#  |   C      |        |400\n#  |----------|   D    |\n#     500     |--------|\n#                 400\n#\n# Notice there is a hole in the middle\n# also D goes down below the others\n\nfake_screens = [\n    Screen(\n        bottom=bar.Bar(\n            [\n                widget.Prompt(),\n                widget.Sep(),\n                widget.WindowName(),\n                widget.Sep(),\n                widget.Systray(),\n                widget.Sep(),\n                widget.Clock(format='%H:%M:%S %d.%m.%Y')\n            ],\n            24,\n            background=\"#555555\"\n        ),\n        x=0,\n        y=0,\n        width=600,\n        height=480\n    ),\n    Screen(\n        top=bar.Bar(\n            [\n                widget.GroupBox(),\n                widget.WindowName(),\n                widget.Clock()\n            ],\n            30,\n        ),\n        x=600,\n        y=0,\n        width=300,\n        height=580\n    ),\n    Screen(\n        top=bar.Bar(\n            [\n                widget.GroupBox(),\n                widget.WindowName(),\n                widget.Clock()\n            ],\n            30,\n        ),\n        x=0,\n        y=480,\n        width=500,\n        height=400\n    ),\n    Screen(\n        top=bar.Bar(\n            [\n                widget.GroupBox(),\n                widget.WindowName(),\n                widget.Clock()\n            ],\n            30,\n        ),\n        x=500,\n        y=580,\n        width=400,\n        height=400\n    ),\n]\n</code></pre>"},{"location":"manual/config/screens/#third-party-bars","title":"Third-party bars","text":"<p>There might be some reasons to use third-party bars. For instance you can come from another window manager and you have already configured dzen2, xmobar, or something else. They definitely can be used with Qtile too. In fact, any additional configurations aren't needed. Just run the bar and qtile will adapt.</p>"},{"location":"manual/config/screens/#reference","title":"Reference","text":"<p>.. qtile_class:: libqtile.config.Screen</p> <p>.. qtile_class:: libqtile.bar.Bar</p> <p>.. qtile_class:: libqtile.bar.Gap</p>"},{"location":"manual/howto/git/","title":"Using <code>git</code>","text":"<p><code>git</code> is the version control system that is used to manage all of the source code. It is very powerful, but might be frightening at first. This page should give you a quick overview, but for a complete guide you will have to search the web on your own. Another great resource to get started practically without having to try out the newly-learned commands on a pre-existing repository is learn git branching. You should probably learn the basic <code>git</code> vocabulary and then come back to find out how you can use all that practically. This guide will be oriented on how to create a pull request and things might be in a different order compared to the introductory guides.</p> <p>Warning</p> <p>This guide is not complete and never will be. If something isn't clear, consult other sources until you are confident you know what you are doing.</p>"},{"location":"manual/howto/git/#i-want-to-try-out-a-feature-somebody-is-working-on","title":"I want to try out a feature somebody is working on","text":"<p>If you see a pull request on GitHub that you want to try out, have a look at the line where it says:</p> <pre><code>user wants to merge n commits into qtile:master from user:branch\n</code></pre> <p>Right now you probably have one remote from which you can fetch changes, the <code>origin</code>. If you cloned <code>qtile/qtile</code>, <code>git remote show origin</code> will spit out the upstream url. If you cloned your fork, <code>origin</code> points to it and you probably want to <code>git remote add upstream https://www.github.com/qtile/qtile</code>. To try out somebody's work, you can add their fork as a new remote::</p> <pre><code>git remote add &lt;user&gt; https://www.github.com/user/qtile\n</code></pre> <p>where you fill in the username from the line we asked you to search for before. Then you can load data from that remote with <code>git fetch</code> and then ultimately check out the branch with <code>git checkout &lt;user&gt;/&lt;branch&gt;</code>.</p> <p>Alternatively, it is also possible to fetch and checkout pull requests without needing to add other remotes. The upstream remote is sufficient::</p> <pre><code>git fetch upstream pull/&lt;id&gt;/head:pr&lt;id&gt;\ngit checkout pr&lt;id&gt;\n</code></pre> <p>The numeric pull request id can be found in the url or next to the title (preceeded by a # symbol).</p> <p>Note</p> <p>Having the feature branch checked out doesn't mean that it is installed and will be loaded when you restart qtile. You might still need to install it with <code>pip</code>.</p>"},{"location":"manual/howto/git/#i-committed-changes-and-the-tests-failed","title":"I committed changes and the tests failed","text":"<p>You can easily change your last commit: After you have done your work, <code>git add</code> everything you need and use <code>git commit --amend</code> to change your last commit. This causes the git history of your local clone to be diverged from your fork on GitHub, so you need to force-push your changes with::</p> <pre><code>git push -f &lt;origin&gt; &lt;feature-branch&gt;\n</code></pre> <p>where origin might be your user name or <code>origin</code> if you cloned your fork and feature-branch is to be replaced by the name of the branch you are working on.</p> <p>Assuming the feature branch is currently checked out, you can usually omit it and just specify the origin.</p>"},{"location":"manual/howto/git/#i-was-told-to-rebase-my-work","title":"I was told to rebase my work","text":"<p>If upstream/master is changed and you happened to change the same files as the commits that were added upstream, you should rebase your work onto the most recent upstream/master. Checkout your master, pull from upstream, checkout your branch again and then rebase it::</p> <pre><code>git checkout master\ngit pull upstream/master\ngit checkout &lt;feature-branch&gt;\ngit rebase upstream/master\n</code></pre> <p>You will be asked to solve conflicts where your diff cannot be applied with confidence to the work that was pushed upstream. If that is the case, open the files in your text editor and resolve the conflicts manually. You possibly need to <code>git rebase --continue</code> after you have resolved conflicts for one commit if you are rebasing multiple commits.</p> <p>Note that the above doesn't work if you didn't create a branch. In that case you will find guides elsewhere to fix this problem, ideally by creating a branch and resetting your master branch to where it should be.</p>"},{"location":"manual/howto/git/#i-was-told-to-squash-some-commits","title":"I was told to squash some commits","text":"<p>If you introduce changes in one commit and replace them in another, you are told to squash these changes into one single commit without the intermediate step::</p> <pre><code>git rebase -i master\n</code></pre> <p>opens a text editor with your commits and a comment block reminding you what you can do with your commits. You can reword them to change the commit message, reorder them or choose <code>fixup</code> to squash the changes of a commit into the commit on the line above.</p> <p>This also changes your git history and you will need to force-push your changes afterwards.</p> <p>Note that interactive rebasing also allows you to split, reorder and edit commits.</p>"},{"location":"manual/howto/git/#i-was-told-to-edit-a-commit-message","title":"I was told to edit a commit message","text":"<p>If you need to edit the commit message of the last commit you did, use::</p> <pre><code>git commit --amend\n</code></pre> <p>to open an editor giving you the possibility to reword the message. If you want to reword the message of an older commit or multiple commits, use <code>git rebase -i</code> as above with the <code>reword</code> command in the editor.</p>"},{"location":"manual/howto/layout/","title":"How to create a layout","text":""},{"location":"manual/howto/layout/#how-to-create-a-layout","title":"How to create a layout","text":"<p>The aim of this page is to explain the main components of qtile layouts, how they work, and how you can use them to create your own layouts or hack existing layouts to make them work the way you want them.</p> <p>Note</p> <p> It is highly recommended that users wishing to create their own layout refer to the source documentation of existing layouts to familiarise themselves with the code.</p>"},{"location":"manual/howto/layout/#what-is-a-layout","title":"What is a layout?","text":"<p>In Qtile, a layout is essentially a set of rules that determine how windows should be displayed on the screen. The layout is responsible for positioning all windows other than floating windows, \"static\" windows, internal windows (e.g. the bar) and windows that have requested not to be managed by the window manager.</p>"},{"location":"manual/howto/layout/#base-classes","title":"Base classes","text":"<p>To simplify the creation of layouts, a couple of base classes are available to users.</p>"},{"location":"manual/howto/layout/#the-layout-class","title":"The <code>Layout</code> class","text":"<p>As a bare minimum, all layouts should inherit the base <code>Layout</code> class object as this class defines a number of methods required for basic usage and will also raise errors if the required methods are not implemented. Further information on these required methods is set out below.</p>"},{"location":"manual/howto/layout/#the-_simplelayoutbase-class","title":"The <code>_SimpleLayoutBase</code> class","text":"<p>This class implements everything needed for a basic layout with the exception of the <code>configure</code> method. Therefore, unless your layout requires special logic for updating and navigating the list of clients, it is strongly recommended that your layout inherits this base class </p>"},{"location":"manual/howto/layout/#the-_clientlist-class","title":"The <code>_ClientList</code> class","text":"<p>This class defines a list of clients and the current client.</p> <p>The collection is meant as a base or utility class for special layouts, which need to maintain one or several collections of windows, for example Columns or Stack, which use this class as base for their internal helper.</p> <p>The property <code>current_index</code> get and set the index to the current client, whereas <code>current_client</code> property can be used with clients directly.</p>"},{"location":"manual/howto/layout/#required-methods","title":"Required methods","text":"<p>To create a minimal, functioning layout your layout must include the methods listed below:</p> <ul> <li><code>__init__</code></li> <li><code>configure</code></li> <li><code>add_client</code></li> <li><code>remove</code></li> <li><code>focus_first</code></li> <li><code>focus_last</code></li> <li><code>focus_next</code></li> <li><code>focus_previous</code></li> <li><code>next</code></li> <li><code>previous</code></li> </ul> <p>As noted above, if you create a layout based on the <code>_SimpleLayoutBase</code> class, you will only need to define <code>configure</code> (and <code>_init__</code>, if you have custom parameters). However, for the purposes of this document, we will show examples of all required methods.</p>"},{"location":"manual/howto/layout/#__init__","title":"<code>__init__</code>","text":"<p>Initialise your layout's variables here. The main use of this method will be to load any default parameters defined by layout. These are defined in a class attribute called <code>defaults</code>. The format of this attribute is a list of tuples.</p> <pre><code>from libqtile.layout import base\n\n\nclass TwoByTwo(base.Layout):\n    \"\"\"\n    A simple layout with a fixed two by two grid.\n\n    By default, unfocused windows are smaller than the focused window.\n    \"\"\"\n    defaults = [\n        (\"border_width\", 5, \"Window border width\"),\n        (\"border_colour\", \"00ff00\", \"Window border colour\"),\n        (\"margin_focused\", 5, \"Margin width for focused windows\"),\n        (\"margin_unfocused\", 50, \"Margin width for unfocused windows\")\n    ]\n\n    def __init__(self, **config):\n        base.Layout.__init__(self, **config)\n        self.add_defaults(TwoByTwo.defaults)\n        self.clients = []\n        self.current_client = None\n</code></pre> <p>Once the layouts is initialised, these parameters are available at <code>self.border_width</code> etc.</p>"},{"location":"manual/howto/layout/#configure","title":"<code>configure</code>","text":"<p>This is where the magic happens! This method is responsible for determining how to position a window on the screen.</p> <p>This method should therefore configure the dimensions and borders of a window using the window's <code>.place()</code> method. The layout can also call either <code>hide()</code> or <code>.unhide()</code> on the window.</p> <pre><code>def configure(self, client: Window, screen_rect: ScreenRect) -&gt; None:\n    \"\"\"Simple example breaking screen into four quarters.\"\"\"\n    try:\n        index = self.clients.index(client)\n    except ValueError:\n        # Layout not expecting this window so ignore it\n        return\n\n    # We're only showing first 4 windows\n    if index &gt; 3:\n        client.hide()\n        return\n\n    # Unhide the window in case it was hiddent before\n    client.unhide()\n\n    # List to help us calculate x and y values of \n    quarters = [\n        (0, 0),\n        (0.5, 0),\n        (0, 0.5),\n        (0.5, 0.5)\n    ]\n\n    # Calculate size and position for each window\n    xpos, ypos = quarters[index]\n\n    x = int(screen_rect.width * xpos) + screen_rect.x\n    y = int(screen_rect.height * ypos) + screen_rect.y\n    w = screen_rect.width // 2\n    h = screen_rect.height // 2\n\n    if client is self.current_client:\n        margin = self.margin_focused\n    else:\n        margin = self.margin_unfocused\n\n    client.place(\n        x,\n        y,\n        w - self.border_width * 2,\n        h - self.border_width * 2,\n        self.border_width,\n        self.border_colour,\n        margin=[margin] * 4,\n    )\n</code></pre>"},{"location":"manual/howto/layout/#add_client","title":"<code>add_client</code>","text":"<p>This method is called whenever a window is added to the group, regardless of whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring/displaying.</p> <pre><code>def add_client(self, client: Window) -&gt; None:\n    # Assumes self.clients is simple list\n    self.clients.insert(0, client)\n    self.current_client = client\n</code></pre>"},{"location":"manual/howto/layout/#remove","title":"<code>remove</code>","text":"<p>This method is called whenever a window is removed from the group, regardless  of whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>The method must also return the \"next\" window that should gain focus or <code>None</code> if there are no other windows.</p> <pre><code>def remove(self, client: Window) -&gt; Window | None:\n    # Assumes self.clients is a simple list\n    # Client already removed so ignore this\n    if client not in self.clients:\n        return None\n    # Client is only window in the list\n    elif len(self.clients) == 1:\n        self.clients.remove(client)\n        self.current_client = None\n        # There are no other windows so return None\n        return None\n    else:\n        # Find position of client in our list\n        index = self.clients.index(client)\n        # Remove client\n        self.clients.remove(client)\n        # Ensure the index value is not greater than list size\n        # i.e. if we closed the last window in the list, we need to return\n        # the first one (index 0).\n        index %= len(self.clients)\n        next_client = self.clients[index]\n        self.current_client = next_client\n        return next_client\n</code></pre>"},{"location":"manual/howto/layout/#focus_first","title":"<code>focus_first</code>","text":"<p>This method is called when the first client in the layout should be focused.</p> <p>This method should just return the first client in the layout, if any. NB the method should not focus the client itself, this is done by caller.</p> <pre><code>def focus_first(self) -&gt; Window | None:\n    if not self.clients:\n        return None\n\n    return self.client[0]\n</code></pre>"},{"location":"manual/howto/layout/#focus_last","title":"<code>focus_last</code>","text":"<p>This method is called when the last client in the layout should be focused.</p> <p>This method should just return the last client in the layout, if any. NB the method should not focus the client itself, this is done by caller.</p> <pre><code>def focus_last(self) -&gt; Window | None:\n    if not self.clients:\n        return None\n\n    return self.client[-1]\n</code></pre>"},{"location":"manual/howto/layout/#focus_next","title":"<code>focus_next</code>","text":"<p>This method is called the next client in the layout should be focused.</p> <p>This method should return the next client in the layout, if any. NB the layout should not cycle clients when reaching the end of the list as there are other method in the group for cycling windows which focus floating windows once the the end of the tiled client list is reached.</p> <p>In addition, the method should not focus the client.</p> <pre><code>def focus_next(self, win: Window) -&gt; Window | None:\n    try:\n        return self.clients[self.clients.index(win) + 1]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"manual/howto/layout/#focus_previous","title":"<code>focus_previous</code>","text":"<p>This method is called the previous client in the layout should be focused.</p> <p>This method should return the previous client in the layout, if any. NB the layout should not cycle clients when reaching the end of the list as there are other method in the group for cycling windows which focus floating windows once the the end of the tiled client list is reached.</p> <p>In addition, the method should not focus the client.</p> <pre><code>def focus_previous(self, win: Window) -&gt; Window | None:\n    if not self.clients or self.clients.index(win) == 0\n        return None\n\n    try:\n        return self.clients[self.clients.index(win) - 1]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"manual/howto/layout/#next","title":"<code>next</code>","text":"<p>This method focuses the next tiled window and can cycle back to the beginning of the list.</p> <pre><code>def next(self) -&gt; None:\n    if self.current_client is None:\n        return\n    # Get the next client or, if at the end of the list, get the first\n    client = self.focus_next(self.current_client) or self.focus_first()\n    self.group.focus(client, True)\n</code></pre>"},{"location":"manual/howto/layout/#previous","title":"<code>previous</code>","text":"<p>This method focuses the previous tiled window and can cycle back to the end of the list.</p> <pre><code>def previous(self) -&gt; None:\n    if self.current_client is None:\n        return\n    # Get the previous client or, if at the end of the list, get the last\n    client = self.focus_previous(self.current_client) or self.focus_last()\n    self.group.focus(client, True)\n</code></pre>"},{"location":"manual/howto/layout/#additional-methods","title":"Additional methods","text":"<p>While not essential to implement, the following methods can also be defined:</p> <ul> <li><code>clone</code></li> <li><code>show</code></li> <li><code>hide</code></li> <li><code>swap</code></li> <li><code>focus</code></li> <li><code>blur</code></li> </ul>"},{"location":"manual/howto/layout/#clone","title":"<code>clone</code>","text":"<p>Each group gets a copy of the layout. The <code>clone</code> method is used to create this copy. The default implementation in <code>Layout</code> is as follows:</p> <pre><code>def clone(self, group: _Group) -&gt; Self:\n    c = copy.copy(self)\n    c._group = group\n    return c\n</code></pre>"},{"location":"manual/howto/layout/#show","title":"<code>show</code>","text":"<p>This method can be used to run code when the layout is being displayed. The method receives one argument, the <code>ScreenRect</code> for the screen showing the layout.</p> <p>The default implementation is a no-op:</p> <pre><code>def show(self, screen_rect: ScreenRect) -&gt; None:\n    pass\n</code></pre>"},{"location":"manual/howto/layout/#hide","title":"<code>hide</code>","text":"<p>This method can be used to run code when the layout is being hidden.</p> <p>The default implementation is a no-op:</p> <pre><code>def hide(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"manual/howto/layout/#swap","title":"<code>swap</code>","text":"<p>This method is used to change the position of two windows in the layout.</p> <pre><code>def swap(self, c1: Window, c2: Window) -&gt; None:\n    if c1 not in self.clients and c2 not in self.clients:\n        return\n\n    index1 = self.clients.index(c1)\n    index2 = self.clients.index(c2)\n\n    self.clients[index1], self.clients[index2] = self.clients[index2], self.clients[index1]\n</code></pre>"},{"location":"manual/howto/layout/#focus","title":"<code>focus</code>","text":"<p>This method is called when a given window is being focused.</p> <pre><code>def focus(self, client: Window) -&gt; None:\n    if client not in self.clients:\n        self.current_client = None\n        return\n\n    index = self.clients.index(client)\n\n    # Check if window is not visible\n    if index &gt; 3:\n        c = self.clients.pop(index)\n        self.clients.insert(0, c)\n\n    self.current_client = client\n</code></pre>"},{"location":"manual/howto/layout/#blur","title":"<code>blur</code>","text":"<p>This method is called when the layout loses focus.</p> <pre><code>def blur(self) -&gt; None:\n    self.current_client = None\n</code></pre>"},{"location":"manual/howto/layout/#adding-commands","title":"Adding commands","text":"<p>Adding commands allows users to modify the behaviour of the layout. To make commands available via the command interface (e.g. via <code>lazy.layout</code> calls), the layout must include the following import:</p> <pre><code>from libqtile.command.base import expose_command\n</code></pre> <p>Commands are then decorated with <code>@expose_command</code>. For example:</p> <pre><code>@expose_command\ndef rotate(self, clockwise: bool = True) -&gt; None:\n    if not self.clients:\n        return\n\n    if clockwise:\n        client = self.clients.pop(-1)\n        self.clients.insert(0, client)\n    else:\n        client = self.clients.pop(0)\n        self.clients.append(client)\n\n    # Check if current client has been rotated off the screen\n    if self.current_client and self.clients.index(self.current_client) &gt; 3:\n        if clockwise:\n            self.current_client = self.clients[3]\n        else:\n            self.current_client = self.clients[0]\n\n    # Redraw the layout\n    self.group.layout_all()\n</code></pre>"},{"location":"manual/howto/layout/#the-info-command","title":"The <code>info</code> command","text":"<p>Layouts should also implement an <code>info</code> method to provide information about the layout.</p> <p>As a minimum, the test suite (see below) will expect a layout to return the following information:</p> <ul> <li>Its name</li> <li>Its group</li> <li>The clients managed by the layout</li> </ul> <p>NB the last item is not included in <code>Layout</code>'s implementation of the method so it should be added when defining a class that inherits that base.</p> <pre><code>@expose_command\ndef info(self) -&gt; dict[str, Any]:\n    inf = base.Layout.info(self)\n    inf[\"clients\"] = self.clients\n    return inf\n</code></pre>"},{"location":"manual/howto/layout/#adding-layout-to-main-repo","title":"Adding layout to main repo","text":"<p>If you think your layout is amazing and you want to share with other users by including it in the main repo then there are a couple of extra steps that you need to take.</p>"},{"location":"manual/howto/layout/#add-to-list-of-layouts","title":"Add to list of layouts","text":"<p>You must save the layout in <code>libqtile/layout</code> and then add a line importing the layout definition to <code>libqtile/layout/__init__.py</code> e.g.</p> <pre><code>from libqtile.layout.twobytwo import TwoByTwo\n</code></pre>"},{"location":"manual/howto/layout/#add-tests","title":"Add tests","text":"<p>Basic functionality for all layouts is handled automatically by the core test suite. However, you should create tests for any custom functionality of your layout (e.g. testing the <code>rotate</code> command defined above).</p>"},{"location":"manual/howto/layout/#full-example","title":"Full example","text":"<p>The full code for the example layout is as follows:</p> <pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom libqtile.command.base import expose_command\nfrom libqtile.layout import base\n\nif TYPE_CHECKING:\n    from libqtile.backend.base import Window\n    from libqtile.config import ScreenRect\n    from libqtile.group import _Group\n\n\nclass TwoByTwo(base.Layout):\n    \"\"\"\n    A simple layout with a fixed two by two grid.\n\n    By default, unfocused windows are smaller than the focused window.\n    \"\"\"\n    defaults = [\n        (\"border_width\", 5, \"Window border width\"),\n        (\"border_colour\", \"00ff00\", \"Window border colour\"),\n        (\"margin_focused\", 5, \"Margin width for focused windows\"),\n        (\"margin_unfocused\", 50, \"Margin width for unfocused windows\")\n    ]\n\n    def __init__(self, **config):\n        base.Layout.__init__(self, **config)\n        self.add_defaults(TwoByTwo.defaults)\n        self.clients = []\n        self.current_client = None\n\n    def configure(self, client: Window, screen_rect: ScreenRect) -&gt; None:\n        \"\"\"Simple example breaking screen into four quarters.\"\"\"\n        try:\n            index = self.clients.index(client)\n        except ValueError:\n            # Layout not expecting this window so ignore it\n            return\n\n        # We're only showing first 4 windows\n        if index &gt; 3:\n            client.hide()\n            return\n\n        # Unhide the window in case it was hiddent before\n        client.unhide()\n\n        # List to help us calculate x and y values of \n        quarters = [\n            (0, 0),\n            (0.5, 0),\n            (0, 0.5),\n            (0.5, 0.5)\n        ]\n\n        # Calculate size and position for each window\n        xpos, ypos = quarters[index]\n\n        x = int(screen_rect.width * xpos) + screen_rect.x\n        y = int(screen_rect.height * ypos) + screen_rect.y\n        w = screen_rect.width // 2\n        h = screen_rect.height // 2\n\n        if client is self.current_client:\n            margin = self.margin_focused\n        else:\n            margin = self.margin_unfocused\n\n        client.place(\n            x,\n            y,\n            w - self.border_width * 2,\n            h - self.border_width * 2,\n            self.border_width,\n            self.border_colour,\n            margin=[margin] * 4,\n        )\n\n    def add_client(self, client: Window) -&gt; None:\n        # Assumes self.clients is simple list\n        self.clients.insert(0, client)\n        self.current_client = client\n\n    def remove(self, client: Window) -&gt; Window | None:\n        # Assumes self.clients is a simple list\n        # Client already removed so ignore this\n        if client not in self.clients:\n            return None\n        # Client is only window in the list\n        elif len(self.clients) == 1:\n            self.clients.remove(client)\n            self.current_client = None\n            # There are no other windows so return None\n            return None\n        else:\n            # Find position of client in our list\n            index = self.clients.index(client)\n            # Remove client\n            self.clients.remove(client)\n            # Ensure the index value is not greater than list size\n            # i.e. if we closed the last window in the list, we need to return\n            # the first one (index 0).\n            index %= len(self.clients)\n            next_client = self.clients[index]\n            self.current_client = next_client\n            return next_client\n\n    def focus_first(self) -&gt; Window | None:\n        if not self.clients:\n            return None\n\n        return self.client[0]\n\n    def focus_last(self) -&gt; Window | None:\n        if not self.clients:\n            return None\n\n        return self.client[-1]\n\n    def focus_next(self, win: Window) -&gt; Window | None:\n        try:\n            return self.clients[self.clients.index(win) + 1]\n        except IndexError:\n            return None\n\n    def focus_previous(self, win: Window) -&gt; Window | None:\n        if not self.clients or self.clients.index(win) == 0:\n            return None\n\n        try:\n            return self.clients[self.clients.index(win) - 1]\n        except IndexError:\n            return None\n\n    def next(self) -&gt; None:\n        if self.current_client is None:\n            return\n        # Get the next client or, if at the end of the list, get the first\n        client = self.focus_next(self.current_client) or self.focus_first()\n        self.group.focus(client, True)\n\n    def previous(self) -&gt; None:\n        if self.current_client is None:\n            return\n        # Get the previous client or, if at the end of the list, get the last\n        client = self.focus_previous(self.current_client) or self.focus_last()\n        self.group.focus(client, True)\n\n    def swap(self, c1: Window, c2: Window) -&gt; None:\n        if c1 not in self.clients and c2 not in self.clients:\n            return\n\n        index1 = self.clients.index(c1)\n        index2 = self.clients.index(c2)\n\n        self.clients[index1], self.clients[index2] = self.clients[index2], self.clients[index1]\n\n    def focus(self, client: Window) -&gt; None:\n        if client not in self.clients:\n            self.current_client = None\n            return\n\n        index = self.clients.index(client)\n\n        # Check if window is not visible\n        if index &gt; 3:\n            c = self.clients.pop(index)\n            self.clients.insert(0, c)\n\n        self.current_client = client\n\n    def blur(self) -&gt; None:\n        self.current_client = None\n\n    @expose_command\n    def rotate(self, clockwise: bool = True) -&gt; None:\n        if not self.clients:\n            return\n\n        if clockwise:\n            client = self.clients.pop(-1)\n            self.clients.insert(0, client)\n        else:\n            client = self.clients.pop(0)\n            self.clients.append(client)\n\n        # Check if current client has been rotated off the screen\n        if self.current_client and self.clients.index(self.current_client) &gt; 3:\n            if clockwise:\n                self.current_client = self.clients[3]\n            else:\n                self.current_client = self.clients[0]\n\n        # Redraw the layout\n        self.group.layout_all()\n\n    @expose_command\n    def info(self) -&gt; dict[str, Any]:\n        inf = base.Layout.info(self)\n        inf[\"clients\"] = self.clients\n        return inf\n</code></pre> <p>This should result in a layout looking like this:</p> <p></p>"},{"location":"manual/howto/layout/#getting-help","title":"Getting help","text":"<p>If you still need help with developing your widget then please submit a question in the qtile-dev group or submit an issue on the GitHub page if you believe there's an error in the codebase.</p>"},{"location":"manual/howto/widget/","title":"How to create a widget","text":"<p>The aim of this page is to explain the main components of qtile widgets, how they work, and how you can use them to create your own widgets.</p> <p>Note</p> <p> This page is not meant to be an exhaustive summary of everything needed to make a widget.</p> <p>It is highly recommended that users wishing to create their own widget refer to the source documentation of existing widgets to familiarise themselves with the code.</p> <p>However, the detail below may prove helpful when read in conjunction with the source code.</p>"},{"location":"manual/howto/widget/#what-is-a-widget","title":"What is a widget?","text":"<p>In Qtile, a widget is a small drawing that is displayed on the user's bar. The widget can display text, images and drawings. In addition, the widget can be configured to update based on timers, hooks, dbus_events etc. and can also respond to mouse events (clicks, scrolls and hover).</p>"},{"location":"manual/howto/widget/#widget-base-classes","title":"Widget base classes","text":"<p>Qtile provides a number of base classes for widgets than can be used to implement commonly required features (e.g. display text).</p> <p>Your widget should inherit one of these classes. Whichever base class you inherit for your widget, if you override either the <code>__init__</code> and/or <code>_configure</code> methods, you should make sure that your widget calls the equivalent method from the superclass.</p> <pre><code>class MyCustomWidget(base._TextBox):\n\n    def __init__(self, **config):\n        super().__init__(\"\", **config)\n        # My widget's initialisation code here\n</code></pre> <p>The functions of the various base classes are explained further below.</p>"},{"location":"manual/howto/widget/#_widget","title":"_Widget","text":"<p>This is the base widget class that defines the core components required for a widget. All other base classes are based off this class.</p> <p>This is like a blank canvas so you're free to do what you want but you don't have any of the extra functionality provided by the other base classes.</p> <p>The <code>base._Widget</code> class is therefore typically used for widgets that want to draw graphics on the widget as opposed to displaying text.</p>"},{"location":"manual/howto/widget/#_textbox","title":"_TextBox","text":"<p>The <code>base._TextBox</code> class builds on the bare widget and adds a <code>drawer.TextLayout</code> which is accessible via the <code>self.layout</code> property. The widget will adjust its size to fit the amount of text to be displayed.</p> <p>Text can be updated via the <code>self.text</code> property but note that this does not trigger a redrawing of the widget.</p> <p>Parameters including <code>font</code>, <code>fontsize</code>, <code>fontshadow</code>, <code>padding</code> and <code>foreground</code> (font colour) can be configured. It is recommended not to hard-code these parameters as users may wish to have consistency across units.</p>"},{"location":"manual/howto/widget/#inlooppolltext","title":"InLoopPollText","text":"<p>The <code>base.InLoopPollText</code> class builds on the <code>base._TextBox</code> by adding a timer to periodically refresh the displayed text.</p> <p>Widgets using this class should override the <code>poll</code> method to include a function that returns the required text.</p> <p>Note</p> <p> This loop runs in the event loop so it is important that the poll method does not call some blocking function. If this is required, widgets should inherit the <code>base.ThreadPoolText</code> class (see below).</p>"},{"location":"manual/howto/widget/#threadpooltext","title":"ThreadPoolText","text":"<p>The <code>base.ThreadPoolText</code> class is very similar to the <code>base.InLoopPollText</code> class. The key difference is that the <code>poll</code> method is run asynchronously and triggers a callback once the function completes. This allows widgets to get text from long-running functions without blocking Qtile.</p>"},{"location":"manual/howto/widget/#mixins","title":"Mixins","text":"<p>As well as inheriting from one of the base classes above, widgets can also inherit one or more mixins to provide some additional functionality to the widget.</p>"},{"location":"manual/howto/widget/#paddingmixin","title":"PaddingMixin","text":"<p>This provides the <code>padding(_x|_y|)</code> attributes which can be used to change the appearance of the widget.</p> <p>If you use this mixin in your widget, you need to add the following line to your <code>__init__</code> method:</p> <pre><code>self.add_defaults(base.PaddingMixin.defaults)\n</code></pre>"},{"location":"manual/howto/widget/#marginmixin","title":"MarginMixin","text":"<p>The <code>MarginMixin</code> is essentially effectively exactly the same as the <code>PaddingMixin</code> but, instead, it provides the <code>margin(_x|_y|)</code> attributes.</p> <p>As above, if you use this mixin in your widget, you need to add the following line to your <code>__init__</code> method:</p> <pre><code>self.add_defaults(base.MarginMixin.defaults)\n</code></pre>"},{"location":"manual/howto/widget/#configuration","title":"Configuration","text":"<p>Now you know which class to base your widget on, you need to know how the widget gets configured.</p>"},{"location":"manual/howto/widget/#defining-parameters","title":"Defining Parameters","text":"<p>Each widget will likely have a number of parameters that users can change to customise the look and feel and/or behaviour of the widget for their own needs.</p> <p>The widget should therefore provide the default values of these parameters as a class attribute called <code>defaults</code>. The format of this attribute is a list of tuples.</p> <pre><code>defaults = [\n    (\"parameter_name\",\n        default_parameter_value,\n        \"Short text explaining what parameter does\")\n]\n</code></pre> <p>Users can override the default value when creating their <code>config.py</code> file.</p> <pre><code>MyCustomWidget(parameter_name=updated_value)\n</code></pre> <p>Once the widget is initialised, these parameters are available at <code>self.parameter_name</code>.</p>"},{"location":"manual/howto/widget/#the-__init__-method","title":"The <code>__init__</code> method","text":"<p>Parameters that should not be changed by users can be defined in the <code>__init__</code> method.</p> <p>This method is run when the widgets are initially created. This happens before the <code>qtile</code> object is available.</p>"},{"location":"manual/howto/widget/#the-_configure-method","title":"The _configure method","text":"<p>The <code>_configure</code> method is called by the <code>bar</code> object and sets the <code>self.bar</code> and <code>self.qtile</code> attributes of the widget. It also creates the <code>self.drawer</code> attribute which is necessary for displaying any content.</p> <p>Once this method has been run, your widget should be ready to display content as the bar will draw once it has finished its configuration.</p> <p>Calls to methods required to prepare the content for your widget should therefore be made from this method rather than <code>__init__</code>.</p>"},{"location":"manual/howto/widget/#displaying-output","title":"Displaying output","text":"<p>A Qtile widget is just a drawing that is displayed at a certain location the user's bar. The widget's job is therefore to create a small drawing surface that can be placed in the appropriate location on the bar.</p>"},{"location":"manual/howto/widget/#the-draw-method","title":"The \"draw\" method","text":"<p>The <code>draw</code> method is called when the widget needs to update its appearance. This can be triggered by the widget itself (e.g. if the content has changed) or by the bar (e.g. if the bar needs to redraw its entire contents).</p> <p>This method therefore needs to contain all the relevant code to draw the various components that make up the widget. Examples of displaying text, icons and drawings are set out below.</p> <p>It is important to note that the bar controls the placing of the widget by assigning the <code>offsetx</code> value (for horizontal positioning) and <code>offsety</code> value (for vertical positioning). Widgets should use this at the end of the <code>draw</code> method. Both <code>offsetx</code> and <code>offsety</code> are required as both values will be set if the bar is drawing a border.</p> <pre><code>self.drawer.draw(offsetx=self.offsetx, offsety=self.offsety, width=self.width)\n</code></pre> <p>Note</p> <p> If you need to trigger a redrawing of your widget, you should call <code>self.draw()</code> if the width of your widget is unchanged. Otherwise you need to call <code>self.bar.draw()</code> as this method means the bar recalculates the position of all widgets.</p>"},{"location":"manual/howto/widget/#displaying-text","title":"Displaying text","text":"<p>Text is displayed by using a <code>drawer.TextLayout</code> object. If all you are doing is displaying text then it's highly recommended that you use the <code>`base._TextBox</code> superclass as this simplifies adding and updating text.</p> <p>If you wish to implement this manually then you can create a your own <code>drawer.TextLayout</code> by using the <code>self.drawer.textlayout</code> method of the widget (only available after the <code>_configure</code> method has been run). object to include in your widget.</p> <p>Some additional formatting of Text can be displayed using pango markup and ensuring the <code>markup</code> parameter is set to <code>True</code>.</p> <pre><code>self.textlayout = self.drawer.textlayout(\n    \"Text\",\n    \"fffff\",       # Font colour\n    \"sans\",        # Font family\n    12,            # Font size\n    None,          # Font shadow\n    markup=False,  # Pango markup (False by default)\n    wrap=True      # Wrap long lines (True by default)\n)\n</code></pre>"},{"location":"manual/howto/widget/#displaying-icons-and-images","title":"Displaying icons and images","text":"<p>Qtile provides a helper library to convert images to a <code>surface</code> that can be drawn by the widget. If the images are static then you should only load them once when the widget is configured. Given the small size of the bar, this is most commonly used to draw icons but the same method applies to other images.</p> <pre><code>from libqtile import images\n\ndef setup_images(self):\n    self.surfaces = {}\n\n    # File names to load (will become keys to the `surfaces` dictionary)\n    names = (\n        \"audio-volume-muted\",\n        \"audio-volume-low\",\n        \"audio-volume-medium\",\n        \"audio-volume-high\"\n    )\n\n    d_images = images.Loader(self.imagefolder)(*names)  # images.Loader can take more than one folder as an argument\n\n    for name, img in d_images.items():\n        new_height = self.bar.height - 1\n        img.resize(height=new_height)   # Resize images to fit widget\n        self.surfaces[name] = img.pattern  # Images added to the `surfaces` dictionary\n</code></pre> <p>Drawing the image is then just a matter of painting it to the relevant surface:</p> <pre><code>def draw(self):\n    self.drawer.ctx.set_source(self.surfaces[img_name])  # Use correct key here for your image\n    self.drawer.ctx.paint()\n    self.drawer.draw(offsetx=self.offset, width=self.length)\n</code></pre>"},{"location":"manual/howto/widget/#drawing-shapes","title":"Drawing shapes","text":"<p>It is possible to draw shapes directly to the widget. The <code>Drawer</code> class (available in your widget after configuration as <code>self.drawer</code>) provides some basic functions <code>rounded_rectangle</code>, <code>rounded_fillrect</code>, <code>rectangle</code> and <code>fillrect</code>.</p> <p>In addition, you can access the Cairo context drawing functions via <code>self.drawer.ctx</code>.</p> <p>For example, the following code can draw a wifi icon showing signal strength:</p> <pre><code>import math\n\n...\n\ndef to_rads(self, degrees):\n    return degrees * math.pi / 180.0\n\ndef draw_wifi(self, percentage):\n\n    WIFI_HEIGHT = 12\n    WIFI_ARC_DEGREES = 90\n\n    y_margin = (self.bar.height - WIFI_HEIGHT) / 2\n    half_arc = WIFI_ARC_DEGREES / 2\n\n    # Draw grey background\n    self.drawer.ctx.new_sub_path()\n    self.drawer.ctx.move_to(WIFI_HEIGHT, y_margin + WIFI_HEIGHT)\n    self.drawer.ctx.arc(WIFI_HEIGHT,\n                        y_margin + WIFI_HEIGHT,\n                        WIFI_HEIGHT,\n                        self.to_rads(270 - half_arc),\n                        self.to_rads(270 + half_arc))\n    self.drawer.set_source_rgb(\"666666\")\n    self.drawer.ctx.fill()\n\n    # Draw white section to represent signal strength\n    self.drawer.ctx.new_sub_path()\n    self.drawer.ctx.move_to(WIFI_HEIGHT, y_margin + WIFI_HEIGHT)\n    self.drawer.ctx.arc(WIFI_HEIGHT\n                        y_margin + WIFI_HEIGHT,\n                        WIFI_HEIGHT * percentage,\n                        self.to_rads(270 - half_arc),\n                        self.to_rads(270 + half_arc))\n    self.drawer.set_source_rgb(\"ffffff\")\n    self.drawer.ctx.fill()\n</code></pre> <p>This creates something looking like this: .</p>"},{"location":"manual/howto/widget/#background","title":"Background","text":"<p>At the start of the <code>draw</code> method, the widget should clear the drawer by drawing the background. Usually this is done by including the following line at the start of the method:</p> <pre><code>self.drawer.clear(self.background or self.bar.background)\n</code></pre> <p>The background can be a single colour or a list of colours which will result in a linear gradient from top to bottom.</p>"},{"location":"manual/howto/widget/#updating-the-widget","title":"Updating the widget","text":"<p>Widgets will usually need to update their content periodically. There are numerous ways that this can be done. Some of the most common ones are summarised below.</p>"},{"location":"manual/howto/widget/#timers","title":"Timers","text":"<p>A non-blocking timer can be called by using the <code>self.timeout_add</code> method.</p> <pre><code>self.timeout_add(delay_in_seconds, method_to_call, (method_args))\n</code></pre> <p>Note</p> <p> Consider using the <code>ThreadPoolText</code> superclass where you are calling a function repeatedly and displaying its output as text.</p>"},{"location":"manual/howto/widget/#hooks","title":"Hooks","text":"<p>Qtile has a number of hooks built in which are triggered on certain events.</p> <p>The <code>WindowCount</code> widget is a good example of using hooks to trigger updates. It includes the following method which is run when the widget is configured:</p> <pre><code>from libqtile import hook\n\n...\n\ndef _setup_hooks(self):\n    hook.subscribe.client_killed(self._win_killed)\n    hook.subscribe.client_managed(self._wincount)\n    hook.subscribe.current_screen_change(self._wincount)\n    hook.subscribe.setgroup(self._wincount)\n</code></pre> <p>Read the built-in hooks page for details of which hooks are available and which arguments are passed to the callback function.</p>"},{"location":"manual/howto/widget/#using-dbus","title":"Using dbus","text":"<p>Qtile uses <code>dbus-next</code> for interacting with dbus.</p> <p>If you just want to listen for signals then Qtile provides a helper method called <code>add_signal_receiver</code> which can subscribe to a signal and trigger a callback whenever that signal is broadcast.</p> <p>Note</p> <p> Qtile uses the <code>asyncio</code> based functions of <code>dbus-next</code> so your widget must make sure, where necessary, calls to dbus are made via coroutines.</p> <p>There is a <code>_config_async</code> coroutine in the base widget class which can be overridden to provide an entry point for asyncio calls in your widget.</p> <p>For example, the Mpris2 widget uses the following code:</p> <pre><code>from libqtile.utils import add_signal_receiver\n\n...\n\nasync def _config_async(self):\n    subscribe = await add_signal_receiver(\n        self.message,  # Callback function\n        session_bus=True,\n        signal_name=\"PropertiesChanged\",\n        bus_name=self.objname,\n        path=\"/org/mpris/MediaPlayer2\",\n        dbus_interface=\"org.freedesktop.DBus.Properties\",\n    )\n</code></pre> <p><code>dbus-next</code> can also be used to query properties, call methods etc. on dbus interfaces. Refer to the dbus-next documentation for more information on how to use the module.</p>"},{"location":"manual/howto/widget/#mouse-events","title":"Mouse events","text":"<p>By default, widgets handle button presses and will call any function that is bound to the button in the <code>mouse_callbacks</code> dictionary. The dictionary keys are as follows:</p> <ul> <li><code>Button1</code>: Left click</li> <li><code>Button2</code>: Middle click</li> <li><code>Button3</code>: Right click</li> <li><code>Button4</code>: Scroll up</li> <li><code>Button5</code>: Scroll down</li> <li><code>Button6</code>: Scroll left</li> <li><code>Button7</code>: Scroll right</li> </ul> <p>You can then define your button bindings in your widget (e.g. in <code>__init__</code>):</p> <pre><code>class MyWidget(widget.TextBox)\n    def __init__(self, *args, **config):\n        widget.TextBox.__init__(self, *args, **kwargs)\n        self.add_callbacks(\n            {\n                \"Button1\": self.left_click_method,\n                \"Button3\": self.right_click_method\n            }\n        )\n</code></pre> <p>Note</p> <p> As well as functions, you can also bind <code>LazyCall</code> objects to button presses. For example:</p> <pre><code>self.add_callbacks(\n    {\n        \"Button1\": lazy.spawn(\"xterm\"),\n    }\n)\n</code></pre> <p>In addition to button presses, you can also respond to mouse enter and leave events. For example, to make a clock show a longer date when you put your mouse over it, you can do the following:</p> <pre><code>class MouseOverClock(widget.Clock):\n    defaults = [\n        (\n            \"long_format\",\n            \"%A %d %B %Y | %H:%M\",\n            \"Format to show when mouse is over widget.\"\n        )\n    ]\n\n    def __init__(self, **config):\n        widget.Clock.__init__(self, **config)\n        self.add_defaults(MouseOverClock.defaults)\n        self.short_format = self.format\n\n    def mouse_enter(self, *args, **kwargs):\n        self.format = self.long_format\n        self.bar.draw()\n\n    def mouse_leave(self, *args, **kwargs):\n        self.format = self.short_format\n        self.bar.draw()\n</code></pre>"},{"location":"manual/howto/widget/#exposing-commands-to-the-ipc-interface","title":"Exposing commands to the IPC interface","text":"<p>If you want to control your widget via <code>lazy</code> or scripting commands (such as <code>qtile cmd-obj</code>), you will need to expose the relevant methods in your widget. Exposing commands is done by adding the <code>@expose_command()</code> decorator to your method. For example:</p> <pre><code>from libqtile.command.base import expose_command\nfrom libqtile.widget import TextBox\n\n\nclass ExposedWidget(TextBox):\n    @expose_command()\n    def uppercase(self):\n        self.update(self.text.upper())\n</code></pre> <p>Text in the <code>ExposedWidget</code> can now be made into upper case by calling <code>lazy.widget[\"exposedwidget\"].uppercase()</code> or <code>qtile cmd-onj -o widget exposedwidget -f uppercase</code>.</p> <p>If you want to expose a method under multiple names, you can pass these additional names to the decorator. For example, decorating a method with:</p> <pre><code>@expose_command([\"extra\", \"additional\"])\ndef mymethod(self):\n    ...\n</code></pre> <p>will make make the method visible under <code>mymethod</code>, <code>extra</code> and <code>additional</code>.</p>"},{"location":"manual/howto/widget/#debugging","title":"Debugging","text":"<p>You can use the <code>logger</code> object to record messages in the Qtile log file to help debug your development.</p> <pre><code>from libqtile.log_utils import logger\n\n...\n\nlogger.debug(\"Callback function triggered\")\n</code></pre> <p>Note</p> <p> The default log level for the Qtile log is <code>INFO</code> so you may either want to change this when debugging or use <code>logger.info</code> instead.</p> <p>Debugging messages should be removed from your code before submitting pull requests.</p>"},{"location":"manual/howto/widget/#submitting-the-widget-to-the-official-repo","title":"Submitting the widget to the official repo","text":"<p>The following sections are only relevant for users who wish for their widgets to be submitted as a PR for inclusion in the main Qtile repo.</p>"},{"location":"manual/howto/widget/#including-the-widget-in-libqtilewidget","title":"Including the widget in libqtile.widget","text":"<p>You should include your widget in the <code>widgets</code> dict in <code>libqtile.widget.__init__.py</code>. The relevant format is <code>{\"ClassName\": \"modulename\"}</code>.</p> <p>This has a number of benefits:</p> <ul> <li>Lazy imports</li> <li>Graceful handling of import errors (useful where widget relies on third party modules)</li> <li>Inclusion in basic unit testing (see below)</li> </ul>"},{"location":"manual/howto/widget/#testing","title":"Testing","text":"<p>Any new widgets should include an accompanying unit test.</p> <p>Basic initialisation and configurations (using defaults) will automatically be tested by <code>test/widgets/test_widget_init_configure.py</code> if the widget has been included in <code>libqtile.widget.__init__.py</code> (see above).</p> <p>However, where possible, it is strongly encouraged that widgets include additional unit tests that test specific functionality of the widget (e.g. reaction to hooks).</p> <p>See Unit testing for more.</p>"},{"location":"manual/howto/widget/#documentation","title":"Documentation","text":"<p>It is really important that we maintain good documentation for Qtile. Any new widgets must therefore include sufficient documentation in order for users to understand how to use/configure the widget.</p> <p>The majority of the documentation is generated automatically from your module. The widget's docstring will be used as the description of the widget. Any parameters defined in the widget's <code>defaults</code> attribute will also be displayed. It is essential that there is a clear explanation of each new parameter defined by the widget.</p>"},{"location":"manual/howto/widget/#screenshots","title":"Screenshots","text":"<p>While not essential, it is strongly recommended that the documentation includes one or more screenshots.</p> <p>Screenshots can be generated automatically with a minimal amount of coding by using the fixtures created by Qtile's test suite.</p> <p>A screenshot file must satisfy the following criteria:</p> <ul> <li>Be named <code>ss_[widgetname].py</code></li> <li>Any function that takes a screenshot must be prefixed with <code>ss_</code></li> <li>Define a pytest fixture named <code>widget</code></li> </ul> <p>An example screenshot file is below:</p> <pre><code>import pytest\n\nfrom libqtile.widget import wttr\n\nRESPONSE = \"London: +17\u00b0C\"\n\n\n@pytest.fixture\ndef widget(monkeypatch):\n    def result(self):\n        return RESPONSE\n\n    monkeypatch.setattr(\"libqtile.widget.wttr.Wttr.fetch\", result)\n    yield wttr.Wttr\n\n\n@pytest.mark.parametrize(\n    \"screenshot_manager\",\n    [\n        {\"location\": {\"London\": \"Home\"}}\n    ],\n    indirect=True\n)\ndef ss_wttr(screenshot_manager):\n    screenshot_manager.take_screenshot()\n</code></pre> <p>The <code>widget</code> fixture returns the widget class (not an instance of the widget). Any monkeypatching of the widget should be included in this fixture.</p> <p>The screenshot function (here, called <code>ss_wttr</code>) must take an argument called <code>screenshot_manager</code>.  The function can also be parameterized, in which case, each dict object will be used to configure the widget for the screenshot (and the configuration will be displayed in the docs). If you want to include parameterizations but also want to show the default configuration, you should include an empty dict (<code>{}</code>) as the first object in the list.</p> <p>Taking a screenshot is then as simple as calling <code>screenshot_manager.take_screenshot()</code>. The method can be called multiple times in the same function.</p> <p><code>screenshot_manager.take_screenshot()</code> only takes a picture of the widget. If you need to take a screenshot of the bar then you need a few extra steps:</p> <pre><code>def ss_bar_screenshot(screenshot_manager):\n    # Generate a filename for the screenshot\n    target = screenshot_manager.target()\n\n    # Get the bar object\n    bar = screenshot_manager.c.bar[\"top\"]\n\n    # Take a screenshot. Will take screenshot of whole bar unless\n    # a `width` parameter is set.\n    bar.take_screenshot(target, width=width)\n</code></pre>"},{"location":"manual/howto/widget/#getting-help","title":"Getting help","text":"<p>If you still need help with developing your widget then please submit a question in the qtile-dev group or submit an issue on the github page if you believe there's an error in the codebase.</p>"},{"location":"manual/install/","title":"Installation","text":""},{"location":"manual/install/#distro-guides","title":"Distro Guides","text":"<p>Below are the preferred installation methods for specific distros. If you are running something else, please see Installing From Source.</p>"},{"location":"manual/install/#installing-from-source","title":"Installing From Source","text":""},{"location":"manual/install/#python-interpreters","title":"Python interpreters","text":"<p>We aim to always support the last three versions of CPython, the reference Python interpreter. We usually support the latest stable version of PyPy as well. You can check the versions and interpreters we currently run our test suite against in our tox configuration file.</p> <p>There are not many differences between versions aside from Python features you may or may not be able to use in your config. PyPy should be faster at runtime than any corresponding CPython version under most circumstances, especially for bits of Python code that are run many times. CPython should start up faster than PyPy and has better compatibility for external libraries.</p>"},{"location":"manual/install/#core-dependencies","title":"Core Dependencies","text":"<p>Here are Qtile's core runtime dependencies and the package names that provide them  in Ubuntu. Note that Qtile can run with one of two backends -- X11 and Wayland -- so  only the dependencies of one of these is required.</p> <p>Dependency</p> <p>Ubuntu Package</p> <p>Needed for</p> <p>Core Dependencies</p> <p>CFFI</p> <p>python3-cffi</p> <p>Bars and popups</p> <p>cairocffi</p> <p>python3-cairocffi</p> <p>Drawing on bars and popups (if using X11 install xcffib BEFORE installing cairocffi, see below)</p> <p>libpangocairo</p> <p>libpangocairo-1.0-0</p> <p>Writing on bars and popups</p> <p>dbus-next </p> <p>-- </p> <p>Sending notifications with dbus (optional).</p> <p>X11</p> <p>X server</p> <p>xserver-xorg</p> <p>X11 backends</p> <p>xcffib</p> <p>python3-xcffib</p> <p>required for X11 backend</p> <p>Wayland</p> <p>wlroots</p> <p>libwlroots-dev</p> <p>Wayland backend (see below)</p> <p>pywlroots</p> <p>--</p> <p>python bindings for the wlroots library</p> <p>pywayland</p> <p>--</p> <p>python bindings for the wayland library</p> <p>python-xkbcommon</p> <p>--</p> <p>required for wayland backeds</p>"},{"location":"manual/install/#cairocffi","title":"cairocffi","text":"<p>Qtile uses cairocffi for drawing on status bars and popup windows. Under X11, cairocffi requires XCB support via xcffib, which you should be sure to have installed before installing cairocffi; otherwise, the needed cairo-xcb bindings will not be built. Once you've got the dependencies installed, you can use the latest version on PyPI:</p> <pre><code>pip install --no-cache-dir cairocffi\n</code></pre>"},{"location":"manual/install/#qtile","title":"Qtile","text":"<p>With the dependencies in place, you can now install the stable version of qtile from PyPI:</p> <pre><code>pip install qtile\n</code></pre> <p>Or with sets of dependencies:</p> <pre><code>pip install qtile[wayland]  # for Wayland dependencies\npip install qtile[widgets]  # for all widget dependencies\npip install qtile[all]      # for all dependencies\n</code></pre> <p>Or install qtile-git with:</p> <pre><code>git clone https://github.com/qtile/qtile.git\ncd qtile\npip install .\n</code></pre> <p>As long as the necessary libraries are in place, this can be done at any point, however, it is recommended that you first install xcffib to ensure the cairo-xcb bindings are built (X11 only) (see above).</p>"},{"location":"manual/install/#starting-qtile","title":"Starting Qtile","text":"<p>There are several ways to start Qtile. The most common way is via an entry in your X session manager's menu. The default Qtile behavior can be invoked by creating a qtile.desktop file in <code>/usr/share/xsessions</code>.</p> <p>A second way to start Qtile is a custom X session. This way allows you to invoke Qtile with custom arguments, and also allows you to do any setup you want (e.g. special keyboard bindings like mapping caps lock to control, setting your desktop background, etc.) before Qtile starts. If you're using an X session manager, you still may need to create a <code>custom.desktop</code> file similar to the <code>qtile.desktop</code> file above, but with <code>Exec=/etc/X11/xsession</code>. Then, create your own <code>~/.xsession</code>. There are several examples of user defined <code>xsession</code> s in the qtile-examples repository.</p> <p>If there is no display manager such as SDDM, LightDM or other and there is need to start Qtile directly from <code>~/.xinitrc</code> do that by adding  <code>exec qtile start</code> at the end.</p> <p>In very special cases, ex. Qtile crashing during session, then suggestion would be to start through a loop to save running applications:</p> <pre><code>while true; do\n    qtile\ndone\n</code></pre> <p>Finally, if you're a gnome user, you can start integrate Qtile into Gnome's session manager and use gnome as usual.</p> <ul> <li>Running from systemd</li> <li>Running inside Gnome</li> </ul>"},{"location":"manual/install/#wayland","title":"Wayland","text":"<p>Qtile can be run as a Wayland compositor rather than an X11 window manager. For this, Qtile uses wlroots, a compositor library which is undergoing fast development. Be aware that some distributions package outdated versions of wlroots. More up-to-date distributions such as Arch Linux may package pywayland, pywlroots and python-xkbcommon. Also note that we may not have yet caught up with the latest wlroots release ourselves.</p> <p>Note</p> <p>We currently support wlroots==0.16.0,&lt;0.17.0 and pywlroots==0.16.4.</p> <p>With the Wayland dependencies in place, Qtile can be run either from a TTY, or within an existing X11 or Wayland session where it will run inside a nested window:</p> <pre><code>qtile start -b wayland\n</code></pre> <p>See the Wayland page for more information on running Qtile as a Wayland compositor.</p> <p>Similar to the xsession example above, a wayland session file can be used to start qtile from a login manager. To use this, you should create a qtile-wayland.desktop file in <code>/usr/share/wayland-sessions</code>.</p>"},{"location":"manual/install/arch/","title":"Installing on Arch Linux","text":"<p>Stable versions of Qtile are currently packaged for Arch Linux. To install this package, run:</p> <pre><code>pacman -S qtile\n</code></pre> <p>Please see the ArchWiki for more information on Qtile.</p>"},{"location":"manual/install/fedora/","title":"Installing on Fedora","text":"<p>Stable versions of Qtile are not currently packaged for the current version of Fedora. Users are advised to follow the instructions of Installing From Source.</p>"},{"location":"manual/install/freebsd/","title":"Installing on FreeBSD","text":"<p>Qtile is available via FreeBSD Ports. It can be installed with</p> <pre><code>pkg install qtile\n</code></pre>"},{"location":"manual/install/funtoo/","title":"Installing on Funtoo","text":"<p>Latest versions of Qtile are available on Funtoo. To install it, run:</p> <pre><code>emerge -av x11-wm/qtile\n</code></pre> <p>You can also install the development version from GitHub:</p> <pre><code>echo \"x11-wm/qtile-9999 **\" &gt;&gt; /etc/portage/package.accept_keywords\nemerge -av qtile\n</code></pre>"},{"location":"manual/install/funtoo/#customize","title":"Customize","text":"<p>You can customize your installation with the following useflags:</p> <ul> <li>dbus</li> <li>widget-khal-calendar</li> <li>widget-imap</li> <li>widget-keyboardkbdd</li> <li>widget-launchbar</li> <li>widget-mpd</li> <li>widget-mpris</li> <li>widget-wlan</li> </ul> <p>The dbus useflag is enabled by default. Disable it only if you know what it is and know you don't use/need it.</p> <p>All widget-* useflags are disabled by default because these widgets require additional dependencies while not everyone will use them. Enable only widgets you need to avoid extra dependencies thanks to these useflags.</p> <p>Visit Funtoo Qtile documentation for more details on Qtile installation on Funtoo.</p>"},{"location":"manual/install/nixos/","title":"Installing on NixOS","text":"<p>Qtile is available in the NixOS repos. To set qtile as your window manager, include this in your configuration.nix file:</p> <pre><code>services.xserver.windowManager.qtile.enable = true;\n</code></pre>"},{"location":"manual/install/slackware/","title":"Installing on Slackware","text":"<p>Qtile is available on the SlackBuilds.org as:</p> Package Name Description qtile stable branch (release)"},{"location":"manual/install/slackware/#using-slpkg-third-party-package-manager","title":"Using slpkg (third party package manager)","text":"<p>The easy way to install Qtile is with slpkg. For example:</p> <pre><code>slpkg -s sbo qtile\n</code></pre>"},{"location":"manual/install/slackware/#manual-installation","title":"Manual installation","text":"<p>Download dependencies first and install them. The order in which you need to install is:</p> <ul> <li>pycparser</li> <li>cffi</li> <li>futures</li> <li>python-xcffib</li> <li>trollius</li> <li>cairocffi</li> <li>qtile</li> </ul> <p>Please see the HOWTO for more information on SlackBuild Usage HOWTO.</p>"},{"location":"manual/install/ubuntu/","title":"Installing on Debian or Ubuntu","text":"<p>To install the latest stable version of Qtile on Ubuntu (newer than 20.04) and Debian 9:</p> <pre><code>pip install xcffib\npip install qtile\n</code></pre> <p>To install the git version see Installing From Source.</p> <p>Note</p> <p>As of Ubuntu 20.04 (Focal Fossa), the package has been outdated and removed from the Ubuntu's official package list.</p>"},{"location":"manual/install/ubuntu/#debian-11-bullseye","title":"Debian 11 (bullseye)","text":"<p>Debian 11 comes with the necessary packages for installing Qtile. Starting  from a minimal Debian installation, the following packages are required:</p> <pre><code>sudo apt install xserver-xorg xinit\nsudo apt install libpangocairo-1.0-0\nsudo apt install python3-pip python3-xcffib python3-cairocffi\n</code></pre> <p>Either Qtile can then be downloaded from the package index or the Github  repository can be used, see Installing From Source:</p> <pre><code>pip install qtile\n</code></pre>"},{"location":"manual/install/without-dm/","title":"Running from systemd","text":"<p>This case will cover automatic login to Qtile after booting the system without using display manager. It logins in virtual console and init X by running through session.</p>"},{"location":"manual/install/without-dm/#automatic-login-to-virtual-console","title":"Automatic login to virtual console","text":"<p>To get login into virtual console as an example edit <code>getty</code> service by running <code>systemctl edit getty@tty1</code> and add instructions to <code>/etc/systemd/system/getty@tty1.service.d/override.conf</code>:</p> <pre><code>[Service]\nExecStart=\nExecStart=-/usr/bin/agetty --autologin username --noclear %I $TERM\n</code></pre> <p><code>username</code> should be changed to current user name.</p> <p>Check more for other examples.</p>"},{"location":"manual/install/without-dm/#autostart-x-session","title":"Autostart X session","text":"<p>After login X session should be started. That can be done by <code>.bash_profile</code> if bash is used or <code>.zprofile</code> in case of zsh. Other shells can be adjusted by given examples.</p> <pre><code>if systemctl -q is-active graphical.target &amp;&amp; [[ ! $DISPLAY &amp;&amp; $XDG_VTNR -eq 1 ]]; then\n    exec startx\nfi\n</code></pre> <p>And to start Qtile itself <code>.xinitrc</code> should be fixed:</p> <pre><code># some apps that should be started before Qtile, ex.\n#\n#   [[ -f ~/.Xresources ]] &amp;&amp; xrdb -merge ~/.Xresources\n#   ~/.fehbg &amp;\n#   nm-applet &amp;\n#   blueman-applet &amp;\n#   dunst &amp;\n#\n# or\n#\n#   source ~/.xsession\n\nexec qtile start\n</code></pre>"},{"location":"manual/ref/extensions/","title":"Built-in Extensions","text":"<p>.. qtile_module:: libqtile.extension     :baseclass: libqtile.extension.base._Extension     :no-commands:</p>"},{"location":"manual/ref/hooks/","title":"Built-in Hooks","text":"<p>.. qtile_hooks:: libqtile.hook.subscribe</p>"},{"location":"manual/ref/layouts/","title":"Built-in Layouts","text":"<p>Classes:</p> <ul> <li> <code>Bsp</code>         \u2013          <p>This layout is inspired by bspwm, but it does not try to copy its</p> </li> <li> <code>Columns</code>         \u2013          <p>Extension of the Stack layout.</p> </li> <li> <code>Floating</code>         \u2013          <p>Floating layout, which does nothing with windows but handles focus order</p> </li> <li> <code>Matrix</code>         \u2013          <p>This layout divides the screen into a matrix of equally sized cells and</p> </li> <li> <code>Max</code>         \u2013          <p>Maximized layout</p> </li> <li> <code>MonadTall</code>         \u2013          <p>Emulate the behavior of XMonad's default tiling scheme.</p> </li> <li> <code>MonadThreeCol</code>         \u2013          <p>Emulate the behavior of XMonad's ThreeColumns layout.</p> </li> <li> <code>MonadWide</code>         \u2013          <p>Emulate the behavior of XMonad's horizontal tiling scheme.</p> </li> <li> <code>RatioTile</code>         \u2013          <p>Tries to tile all windows in the width/height ratio passed in</p> </li> <li> <code>ScreenSplit</code>         \u2013          <p>A layout that allows you to split the screen into separate areas, each of which</p> </li> <li> <code>Slice</code>         \u2013          <p>Slice layout</p> </li> <li> <code>Spiral</code>         \u2013          <p>A mathematical layout.</p> </li> <li> <code>Stack</code>         \u2013          <p>A layout composed of stacks of windows</p> </li> <li> <code>Tile</code>         \u2013          <p>A layout with two stacks of windows dividing the screen</p> </li> <li> <code>TreeTab</code>         \u2013          <p>Tree Tab Layout</p> </li> <li> <code>VerticalTile</code>         \u2013          <p>Tiling layout that works nice on vertically mounted monitors</p> </li> <li> <code>Zoomy</code>         \u2013          <p>A layout with single active windows, and few other previews at the right</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp","title":"Bsp","text":"<pre><code>Bsp(**config)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>This layout is inspired by bspwm, but it does not try to copy its features.</p> <p>The first client occupies the entire screen space.  When a new client is created, the selected space is partitioned in 2 and the new client occupies one of those subspaces, leaving the old client with the other.</p> <p>The partition can be either horizontal or vertical according to the dimensions of the current space: if its width/height ratio is above a pre-configured value, the subspaces are created side-by-side, otherwise, they are created on top of each other.  The partition direction can be freely toggled.  All subspaces can be resized and clients can be shuffled around.</p> <p>All clients are organized at the leaves of a full binary tree.</p> <p>An example key configuration is::</p> <pre><code>Key([mod], \"j\", lazy.layout.down()),\nKey([mod], \"k\", lazy.layout.up()),\nKey([mod], \"h\", lazy.layout.left()),\nKey([mod], \"l\", lazy.layout.right()),\nKey([mod, \"shift\"], \"j\", lazy.layout.shuffle_down()),\nKey([mod, \"shift\"], \"k\", lazy.layout.shuffle_up()),\nKey([mod, \"shift\"], \"h\", lazy.layout.shuffle_left()),\nKey([mod, \"shift\"], \"l\", lazy.layout.shuffle_right()),\nKey([mod, \"mod1\"], \"j\", lazy.layout.flip_down()),\nKey([mod, \"mod1\"], \"k\", lazy.layout.flip_up()),\nKey([mod, \"mod1\"], \"h\", lazy.layout.flip_left()),\nKey([mod, \"mod1\"], \"l\", lazy.layout.flip_right()),\nKey([mod, \"control\"], \"j\", lazy.layout.grow_down()),\nKey([mod, \"control\"], \"k\", lazy.layout.grow_up()),\nKey([mod, \"control\"], \"h\", lazy.layout.grow_left()),\nKey([mod, \"control\"], \"l\", lazy.layout.grow_right()),\nKey([mod, \"shift\"], \"n\", lazy.layout.normalize()),\nKey([mod], \"Return\", lazy.layout.toggle_split()),\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus_next","title":"focus_next","text":"<pre><code>focus_next(\n    client: Window, wrap: bool = False\n) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(\n    client: Window, wrap: bool = False\n) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.remove","title":"remove","text":"<pre><code>remove(client)\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Bsp.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns","title":"Columns","text":"<pre><code>Columns(**config)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>Extension of the Stack layout.</p> <p>The screen is split into columns, which can be dynamically added or removed.  Each column can present its windows in 2 modes: split or stacked.  In split mode, all windows are presented simultaneously, spliting the column space.  In stacked mode, only a single window is presented from the stack of windows.  Columns and windows can be resized and windows can be shuffled around.</p> <p>This layout can also emulate wmii's default layout via:</p> <pre><code>layout.Columns(num_columns=1, insert_position=1)\n</code></pre> <p>Or the \"Vertical\", and \"Max\", depending on the default parameters.</p> <p>An example key configuration is::</p> <pre><code>Key([mod], \"j\", lazy.layout.down()),\nKey([mod], \"k\", lazy.layout.up()),\nKey([mod], \"h\", lazy.layout.left()),\nKey([mod], \"l\", lazy.layout.right()),\nKey([mod, \"shift\"], \"j\", lazy.layout.shuffle_down()),\nKey([mod, \"shift\"], \"k\", lazy.layout.shuffle_up()),\nKey([mod, \"shift\"], \"h\", lazy.layout.shuffle_left()),\nKey([mod, \"shift\"], \"l\", lazy.layout.shuffle_right()),\nKey([mod, \"control\"], \"j\", lazy.layout.grow_down()),\nKey([mod, \"control\"], \"k\", lazy.layout.grow_up()),\nKey([mod, \"control\"], \"h\", lazy.layout.grow_left()),\nKey([mod, \"control\"], \"l\", lazy.layout.grow_right()),\nKey([mod, \"shift\", \"control\"], \"h\", lazy.layout.swap_column_left()),\nKey([mod, \"shift\", \"control\"], \"l\", lazy.layout.swap_column_right()),\nKey([mod], \"Return\", lazy.layout.toggle_split()),\nKey([mod], \"n\", lazy.layout.normalize()),\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Returns first client in first column of layout</p> </li> <li> <code>focus_last</code>           \u2013            <p>Returns last client in last column of layout</p> </li> <li> <code>focus_next</code>           \u2013            <p>Returns the next client after 'win' in layout,</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Returns the client previous to 'win' in layout.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>normalize</code>           \u2013            <p>Give columns equal widths.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>reset</code>           \u2013            <p>Resets column widths, respecting 'initial_ratio' value.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Returns first client in first column of layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Returns last client in last column of layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.focus_next","title":"focus_next","text":"<pre><code>focus_next(win: Window) -&gt; None\n</code></pre> <p>Returns the next client after 'win' in layout, or None if there is no such client</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(win: Window) -&gt; Window | None\n</code></pre> <p>Returns the client previous to 'win' in layout. or None if there is no such client</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.normalize","title":"normalize","text":"<pre><code>normalize()\n</code></pre> <p>Give columns equal widths.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.remove","title":"remove","text":"<pre><code>remove(client)\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets column widths, respecting 'initial_ratio' value.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Columns.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating","title":"Floating","text":"<pre><code>Floating(\n    float_rules: list[_Match] | None = None,\n    no_reposition_rules=None,\n    **config\n)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>Floating layout, which does nothing with windows but handles focus order</p> <p>Match objects::</p> <pre><code>from libqtile.config import Match\nMatch(title=WM_NAME, wm_class=WM_CLASS, role=WM_WINDOW_ROLE)\n</code></pre> <p>When a new window is opened its <code>match</code> method is called with each of these rules.  If one matches, the window will float.  The following will float GIMP and Skype::</p> <pre><code>from libqtile.config import Match\nfloat_rules=[Match(wm_class=\"skype\"), Match(wm_class=\"gimp\")]\n</code></pre> <p>The following <code>Match</code> will float all windows that are transient windows for a parent window:</p> <pre><code>Match(func=lambda c: bool(c.is_transient_for()))\n</code></pre> <p>Specify these in the <code>floating_layout</code> in your config.</p> <p>Floating layout will try to center most of floating windows by default, but if you don't want this to happen for certain windows that are centered by mistake, you can use <code>no_reposition_rules</code> option to specify them and layout will rely on windows to position themselves in correct location on the screen.</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>compute_client_position</code>           \u2013            <p>recompute client.x and client.y, returning whether or not to place</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>find_clients</code>           \u2013            <p>Find all clients belonging to a given group</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>match</code>           \u2013            <p>Used to default float some windows</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> <li> <code>to_screen</code>           \u2013            <p>Adjust offsets of clients within current screen</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.compute_client_position","title":"compute_client_position","text":"<pre><code>compute_client_position(client, screen_rect)\n</code></pre> <p>recompute client.x and client.y, returning whether or not to place this client above other windows or not</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.find_clients","title":"find_clients","text":"<pre><code>find_clients(group)\n</code></pre> <p>Find all clients belonging to a given group</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus_first","title":"focus_first","text":"<pre><code>focus_first(group=None)\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus_last","title":"focus_last","text":"<pre><code>focus_last(group=None)\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus_next","title":"focus_next","text":"<pre><code>focus_next(win: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(win)\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.match","title":"match","text":"<pre><code>match(win)\n</code></pre> <p>Used to default float some windows</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Floating.to_screen","title":"to_screen","text":"<pre><code>to_screen(group, new_screen)\n</code></pre> <p>Adjust offsets of clients within current screen</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix","title":"Matrix","text":"<pre><code>Matrix(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>This layout divides the screen into a matrix of equally sized cells and places one window in each cell. The number of columns is configurable and can also be changed interactively.</p> <p>Methods:</p> <ul> <li> <code>add</code>           \u2013            <p>Increase number of columns</p> </li> <li> <code>add_client</code>           \u2013            <p>Add client to Layout.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>delete</code>           \u2013            <p>Decrease number of columns</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>down</code>           \u2013            <p>Switch to the next window in current column</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get_column</code>           \u2013            <p>Get all clients in given column</p> </li> <li> <code>get_row</code>           \u2013            <p>Get all clients in given row</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>horizontal_traversal</code>           \u2013            <p>Internal method for determining left or right client.</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>left</code>           \u2013            <p>Switch to the next window on current row</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>right</code>           \u2013            <p>Switch to the next window on current row</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> <li> <code>up</code>           \u2013            <p>Switch to the previous window in current column</p> </li> <li> <code>vertical_traversal</code>           \u2013            <p>internal method for determining above or below client.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>column</code>         \u2013          <p>Calc column index of current client</p> </li> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> <li> <code>row</code>         \u2013          <p>Calc row index of current client</p> </li> <li> <code>rows</code>         \u2013          <p>Calc current number of rows, basd on number of clients and columns</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.column","title":"column  <code>property</code>","text":"<pre><code>column\n</code></pre> <p>Calc column index of current client</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.row","title":"row  <code>property</code>","text":"<pre><code>row\n</code></pre> <p>Calc row index of current client</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>Calc current number of rows, basd on number of clients and columns</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.add","title":"add","text":"<pre><code>add()\n</code></pre> <p>Increase number of columns</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Add client to Layout. Note that for Matrix the clients are appended at end of list. If needed a new row in matrix is created</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Decrease number of columns</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.down","title":"down","text":"<pre><code>down()\n</code></pre> <p>Switch to the next window in current column</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.get_column","title":"get_column","text":"<pre><code>get_column(column)\n</code></pre> <p>Get all clients in given column</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.get_row","title":"get_row","text":"<pre><code>get_row(row)\n</code></pre> <p>Get all clients in given row</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.horizontal_traversal","title":"horizontal_traversal","text":"<pre><code>horizontal_traversal(direction)\n</code></pre> <p>Internal method for determining left or right client. Negative direction is to left</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.left","title":"left","text":"<pre><code>left()\n</code></pre> <p>Switch to the next window on current row</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.right","title":"right","text":"<pre><code>right()\n</code></pre> <p>Switch to the next window on current row</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.up","title":"up","text":"<pre><code>up()\n</code></pre> <p>Switch to the previous window in current column</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Matrix.vertical_traversal","title":"vertical_traversal","text":"<pre><code>vertical_traversal(direction)\n</code></pre> <p>internal method for determining above or below client. Negative direction is to top</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max","title":"Max","text":"<pre><code>Max(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>Maximized layout</p> <p>A simple layout that only displays one window at a time, filling the screen_rect. This is suitable for use on laptops and other devices with small screens. Conceptually, the windows are managed as a stack, with commands to switch to next and previous windows in the stack.</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Max.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall","title":"MonadTall","text":"<pre><code>MonadTall(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>Emulate the behavior of XMonad's default tiling scheme.</p> <p>Main-Pane:</p> <p>A main pane that contains a single window takes up a vertical portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the <code>grow_main</code> and <code>shrink_main</code> or, while the main pane is in focus, <code>grow</code> and <code>shrink</code>. You may also set the ratio directly with <code>set_ratio</code>.</p> <p>::</p> <pre><code>---------------------\n|            |      |\n|            |      |\n|            |      |\n|            |      |\n|            |      |\n|            |      |\n---------------------\n</code></pre> <p>Using the <code>flip</code> method will switch which horizontal side the main pane will occupy. The main pane is considered the \"top\" of the stack.</p> <p>::</p> <pre><code>---------------------\n|      |            |\n|      |            |\n|      |            |\n|      |            |\n|      |            |\n|      |            |\n---------------------\n</code></pre> <p>Secondary-panes:</p> <p>Occupying the rest of the screen_rect are one or more secondary panes.  The secondary panes will share the vertical space of the screen_rect however they can be resized at will with the <code>grow</code> and <code>shrink</code> methods.  The other secondary panes will adjust their sizes to smoothly fill all of the space.</p> <p>::</p> <pre><code>---------------------          ---------------------\n|            |      |          |            |______|\n|            |______|          |            |      |\n|            |      |          |            |      |\n|            |______|          |            |      |\n|            |      |          |            |______|\n|            |      |          |            |      |\n---------------------          ---------------------\n</code></pre> <p>Panes can be moved with the <code>shuffle_up</code> and <code>shuffle_down</code> methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise.</p> <p>The opposite is true if the layout is \"flipped\".</p> <p>::</p> <pre><code>---------------------          ---------------------\n|            |  2   |          |   2   |           |\n|            |______|          |_______|           |\n|            |  3   |          |   3   |           |\n|     1      |______|          |_______|     1     |\n|            |  4   |          |   4   |           |\n|            |      |          |       |           |\n---------------------          ---------------------\n</code></pre> <p>Normalizing/Resetting:</p> <p>To restore all secondary client windows to their default size ratios use the <code>normalize</code> method.</p> <p>To reset all client windows to their default sizes, including the primary window, use the <code>reset</code> method.</p> <p>Maximizing:</p> <p>To toggle a client window between its minimum and maximum sizes simply use the <code>maximize</code> on a focused client.</p> <p>Suggested Bindings::</p> <pre><code>Key([modkey], \"h\", lazy.layout.left()),\nKey([modkey], \"l\", lazy.layout.right()),\nKey([modkey], \"j\", lazy.layout.down()),\nKey([modkey], \"k\", lazy.layout.up()),\nKey([modkey, \"shift\"], \"h\", lazy.layout.swap_left()),\nKey([modkey, \"shift\"], \"l\", lazy.layout.swap_right()),\nKey([modkey, \"shift\"], \"j\", lazy.layout.shuffle_down()),\nKey([modkey, \"shift\"], \"k\", lazy.layout.shuffle_up()),\nKey([modkey], \"i\", lazy.layout.grow()),\nKey([modkey], \"m\", lazy.layout.shrink()),\nKey([modkey], \"n\", lazy.layout.reset()),\nKey([modkey, \"shift\"], \"n\", lazy.layout.normalize()),\nKey([modkey], \"o\", lazy.layout.maximize()),\nKey([modkey, \"shift\"], \"space\", lazy.layout.flip()),\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Add client to layout</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Clone layout for other groups</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Position client based on order and sizes</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>flip</code>           \u2013            <p>Flip the layout horizontally</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get_shrink_margin</code>           \u2013            <p>Return how many remaining pixels a client can shrink</p> </li> <li> <code>grow</code>           \u2013            <p>Grow current window</p> </li> <li> <code>grow_down_shared</code>           \u2013            <p>Grow lower secondary clients</p> </li> <li> <code>grow_main</code>           \u2013            <p>Grow main pane</p> </li> <li> <code>grow_up_shared</code>           \u2013            <p>Grow higher secondary clients</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>left</code>           \u2013            <p>Focus on the closest window to the left of the current window</p> </li> <li> <code>maximize</code>           \u2013            <p>Grow the currently focused client to the max size</p> </li> <li> <code>normalize</code>           \u2013            <p>Evenly distribute screen-space among secondary clients</p> </li> <li> <code>remove</code>           \u2013            <p>Remove client from layout</p> </li> <li> <code>reset</code>           \u2013            <p>Reset Layout.</p> </li> <li> <code>right</code>           \u2013            <p>Focus on the closest window to the right of the current window</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_ratio</code>           \u2013            <p>Directly set the main pane ratio</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>shrink</code>           \u2013            <p>Shrink current window</p> </li> <li> <code>shrink_down</code>           \u2013            <p>Shrink current window down</p> </li> <li> <code>shrink_down_shared</code>           \u2013            <p>Shrink secondary clients</p> </li> <li> <code>shrink_main</code>           \u2013            <p>Shrink main pane</p> </li> <li> <code>shrink_up</code>           \u2013            <p>Shrink the window up</p> </li> <li> <code>shrink_up_shared</code>           \u2013            <p>Shrink the shared space</p> </li> <li> <code>shuffle_down</code>           \u2013            <p>Shuffle the client down the stack</p> </li> <li> <code>shuffle_up</code>           \u2013            <p>Shuffle the client up the stack</p> </li> <li> <code>swap</code>           \u2013            <p>Swap two windows</p> </li> <li> <code>swap_left</code>           \u2013            <p>Swap current window with closest window to the left</p> </li> <li> <code>swap_main</code>           \u2013            <p>Swap current window to main pane</p> </li> <li> <code>swap_right</code>           \u2013            <p>Swap current window with closest window to the right</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Add client to layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Clone layout for other groups</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Position client based on order and sizes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.flip","title":"flip","text":"<pre><code>flip()\n</code></pre> <p>Flip the layout horizontally</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.get_shrink_margin","title":"get_shrink_margin","text":"<pre><code>get_shrink_margin(cidx)\n</code></pre> <p>Return how many remaining pixels a client can shrink</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.grow","title":"grow","text":"<pre><code>grow()\n</code></pre> <p>Grow current window</p> <p>Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.grow_down_shared","title":"grow_down_shared","text":"<pre><code>grow_down_shared(cidx, amt)\n</code></pre> <p>Grow lower secondary clients</p> <p>Will grow all secondary clients below the specified index by an equal share of the provided amount.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.grow_main","title":"grow_main","text":"<pre><code>grow_main()\n</code></pre> <p>Grow main pane</p> <p>Will grow the main pane, reducing the size of clients in the secondary pane.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.grow_up_shared","title":"grow_up_shared","text":"<pre><code>grow_up_shared(cidx, amt)\n</code></pre> <p>Grow higher secondary clients</p> <p>Will grow all secondary clients above the specified index by an equal share of the provided amount.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.left","title":"left","text":"<pre><code>left()\n</code></pre> <p>Focus on the closest window to the left of the current window</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.maximize","title":"maximize","text":"<pre><code>maximize()\n</code></pre> <p>Grow the currently focused client to the max size</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.normalize","title":"normalize","text":"<pre><code>normalize(redraw=True)\n</code></pre> <p>Evenly distribute screen-space among secondary clients</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Remove client from layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.reset","title":"reset","text":"<pre><code>reset(ratio=None, redraw=True)\n</code></pre> <p>Reset Layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.right","title":"right","text":"<pre><code>right()\n</code></pre> <p>Focus on the closest window to the right of the current window</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.set_ratio","title":"set_ratio","text":"<pre><code>set_ratio(ratio)\n</code></pre> <p>Directly set the main pane ratio</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shrink","title":"shrink","text":"<pre><code>shrink()\n</code></pre> <p>Shrink current window</p> <p>Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shrink_down","title":"shrink_down","text":"<pre><code>shrink_down(cidx, amt)\n</code></pre> <p>Shrink current window down</p> <p>Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shrink_down_shared","title":"shrink_down_shared","text":"<pre><code>shrink_down_shared(cidx, amt)\n</code></pre> <p>Shrink secondary clients</p> <p>Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with <code>shrink_down</code>.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shrink_main","title":"shrink_main","text":"<pre><code>shrink_main()\n</code></pre> <p>Shrink main pane</p> <p>Will shrink the main pane, increasing the size of clients in the secondary pane.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shrink_up","title":"shrink_up","text":"<pre><code>shrink_up(cidx, amt)\n</code></pre> <p>Shrink the window up</p> <p>Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shrink_up_shared","title":"shrink_up_shared","text":"<pre><code>shrink_up_shared(cidx, amt)\n</code></pre> <p>Shrink the shared space</p> <p>Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with <code>shrink_up</code>.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shuffle_down","title":"shuffle_down","text":"<pre><code>shuffle_down()\n</code></pre> <p>Shuffle the client down the stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.shuffle_up","title":"shuffle_up","text":"<pre><code>shuffle_up()\n</code></pre> <p>Shuffle the client up the stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap two windows</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.swap_left","title":"swap_left","text":"<pre><code>swap_left()\n</code></pre> <p>Swap current window with closest window to the left</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.swap_main","title":"swap_main","text":"<pre><code>swap_main()\n</code></pre> <p>Swap current window to main pane</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadTall.swap_right","title":"swap_right","text":"<pre><code>swap_right()\n</code></pre> <p>Swap current window with closest window to the right</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol","title":"MonadThreeCol","text":"<pre><code>MonadThreeCol(**config)\n</code></pre> <p>             Bases: <code>MonadTall</code></p> <p>Emulate the behavior of XMonad's ThreeColumns layout.</p> <p>A layout similar to tall but with three columns. With an ultra wide display this layout can be used for a huge main window - ideally at the center of the screen - and up to six reasonable sized secondary windows.</p> <p>Main-Pane:</p> <p>A main pane that contains a single window takes up a vertical portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the <code>grow_main</code> and <code>shrink_main</code> or, while the main pane is in focus, <code>grow</code> and <code>shrink</code>. The main pane can also be centered.</p> <p>::</p> <pre><code>---------------------------    ---------------------------\n|           |      |      |    |      |           |      |\n|           |      |      |    |      |           |      |\n|           |      |      |    |      |           |      |\n|           |      |      |    |      |           |      |\n|           |      |      |    |      |           |      |\n|           |      |      |    |      |           |      |\n---------------------------    ---------------------------\n</code></pre> <p>Secondary-panes:</p> <p>Occupying the rest of the screen_rect are one or more secondary panes.  The secondary panes will be divided into two columns and share the vertical space of each column. However they can be resized at will with the <code>grow</code> and <code>shrink</code> methods. The other secondary panes will adjust their sizes to smoothly fill all of the space.</p> <p>::</p> <pre><code>---------------------------    ---------------------------\n|           |      |      |    |           |______|      |\n|           |______|      |    |           |      |      |\n|           |      |______|    |           |      |______|\n|           |______|      |    |           |      |      |\n|           |      |      |    |           |______|      |\n|           |      |      |    |           |      |      |\n---------------------------    ---------------------------\n</code></pre> <p>Panes can be moved with the <code>shuffle_up</code> and <code>shuffle_down</code> methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise. A secondary pane can also be promoted to the main pane with the <code>swap_main</code> method.</p> <p>Normalizing/Resetting:</p> <p>To restore all secondary client windows to their default size ratios use the <code>normalize</code> method.</p> <p>To reset all client windows to their default sizes, including the primary window, use the <code>reset</code> method.</p> <p>Maximizing:</p> <p>To maximized a client window simply use the <code>maximize</code> on a focused client.</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Add client to layout</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Clone layout for other groups</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Position client based on order and sizes</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>flip</code>           \u2013            <p>Flip the layout horizontally</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get_shrink_margin</code>           \u2013            <p>Return how many remaining pixels a client can shrink</p> </li> <li> <code>grow</code>           \u2013            <p>Grow current window</p> </li> <li> <code>grow_down_shared</code>           \u2013            <p>Grow lower secondary clients</p> </li> <li> <code>grow_main</code>           \u2013            <p>Grow main pane</p> </li> <li> <code>grow_up_shared</code>           \u2013            <p>Grow higher secondary clients</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>left</code>           \u2013            <p>Focus on the closest window to the left of the current window</p> </li> <li> <code>maximize</code>           \u2013            <p>Grow the currently focused client to the max size</p> </li> <li> <code>normalize</code>           \u2013            <p>Evenly distribute screen-space among secondary clients</p> </li> <li> <code>remove</code>           \u2013            <p>Remove client from layout</p> </li> <li> <code>reset</code>           \u2013            <p>Reset Layout.</p> </li> <li> <code>right</code>           \u2013            <p>Focus on the closest window to the right of the current window</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_ratio</code>           \u2013            <p>Directly set the main pane ratio</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>shrink</code>           \u2013            <p>Shrink current window</p> </li> <li> <code>shrink_down</code>           \u2013            <p>Shrink current window down</p> </li> <li> <code>shrink_down_shared</code>           \u2013            <p>Shrink secondary clients</p> </li> <li> <code>shrink_main</code>           \u2013            <p>Shrink main pane</p> </li> <li> <code>shrink_up</code>           \u2013            <p>Shrink the window up</p> </li> <li> <code>shrink_up_shared</code>           \u2013            <p>Shrink the shared space</p> </li> <li> <code>shuffle_down</code>           \u2013            <p>Shuffle the client down the stack</p> </li> <li> <code>shuffle_up</code>           \u2013            <p>Shuffle the client up the stack</p> </li> <li> <code>swap</code>           \u2013            <p>Swap two windows</p> </li> <li> <code>swap_left</code>           \u2013            <p>Swap current window with closest window to the left</p> </li> <li> <code>swap_main</code>           \u2013            <p>Swap current window to main pane</p> </li> <li> <code>swap_right</code>           \u2013            <p>Swap current window with closest window to the right</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Add client to layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Clone layout for other groups</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Position client based on order and sizes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.flip","title":"flip","text":"<pre><code>flip()\n</code></pre> <p>Flip the layout horizontally</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.get_shrink_margin","title":"get_shrink_margin","text":"<pre><code>get_shrink_margin(cidx)\n</code></pre> <p>Return how many remaining pixels a client can shrink</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.grow","title":"grow","text":"<pre><code>grow()\n</code></pre> <p>Grow current window</p> <p>Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.grow_down_shared","title":"grow_down_shared","text":"<pre><code>grow_down_shared(cidx, amt)\n</code></pre> <p>Grow lower secondary clients</p> <p>Will grow all secondary clients below the specified index by an equal share of the provided amount.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.grow_main","title":"grow_main","text":"<pre><code>grow_main()\n</code></pre> <p>Grow main pane</p> <p>Will grow the main pane, reducing the size of clients in the secondary pane.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.grow_up_shared","title":"grow_up_shared","text":"<pre><code>grow_up_shared(cidx, amt)\n</code></pre> <p>Grow higher secondary clients</p> <p>Will grow all secondary clients above the specified index by an equal share of the provided amount.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.left","title":"left","text":"<pre><code>left()\n</code></pre> <p>Focus on the closest window to the left of the current window</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.maximize","title":"maximize","text":"<pre><code>maximize()\n</code></pre> <p>Grow the currently focused client to the max size</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.normalize","title":"normalize","text":"<pre><code>normalize(redraw=True)\n</code></pre> <p>Evenly distribute screen-space among secondary clients</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Remove client from layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.reset","title":"reset","text":"<pre><code>reset(ratio=None, redraw=True)\n</code></pre> <p>Reset Layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.right","title":"right","text":"<pre><code>right()\n</code></pre> <p>Focus on the closest window to the right of the current window</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.set_ratio","title":"set_ratio","text":"<pre><code>set_ratio(ratio)\n</code></pre> <p>Directly set the main pane ratio</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shrink","title":"shrink","text":"<pre><code>shrink()\n</code></pre> <p>Shrink current window</p> <p>Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shrink_down","title":"shrink_down","text":"<pre><code>shrink_down(cidx, amt)\n</code></pre> <p>Shrink current window down</p> <p>Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shrink_down_shared","title":"shrink_down_shared","text":"<pre><code>shrink_down_shared(cidx, amt)\n</code></pre> <p>Shrink secondary clients</p> <p>Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with <code>shrink_down</code>.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shrink_main","title":"shrink_main","text":"<pre><code>shrink_main()\n</code></pre> <p>Shrink main pane</p> <p>Will shrink the main pane, increasing the size of clients in the secondary pane.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shrink_up","title":"shrink_up","text":"<pre><code>shrink_up(cidx, amt)\n</code></pre> <p>Shrink the window up</p> <p>Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shrink_up_shared","title":"shrink_up_shared","text":"<pre><code>shrink_up_shared(cidx, amt)\n</code></pre> <p>Shrink the shared space</p> <p>Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with <code>shrink_up</code>.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shuffle_down","title":"shuffle_down","text":"<pre><code>shuffle_down()\n</code></pre> <p>Shuffle the client down the stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.shuffle_up","title":"shuffle_up","text":"<pre><code>shuffle_up()\n</code></pre> <p>Shuffle the client up the stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap two windows</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.swap_left","title":"swap_left","text":"<pre><code>swap_left()\n</code></pre> <p>Swap current window with closest window to the left</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.swap_main","title":"swap_main","text":"<pre><code>swap_main()\n</code></pre> <p>Swap current window to main pane</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadThreeCol.swap_right","title":"swap_right","text":"<pre><code>swap_right()\n</code></pre> <p>Swap current window with closest window to the right</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide","title":"MonadWide","text":"<pre><code>MonadWide(**config)\n</code></pre> <p>             Bases: <code>MonadTall</code></p> <p>Emulate the behavior of XMonad's horizontal tiling scheme.</p> <p>This layout attempts to emulate the behavior of XMonad wide tiling scheme.</p> <p>Main-Pane:</p> <p>A main pane that contains a single window takes up a horizontal portion of the screen_rect based on the ratio setting. This ratio can be adjusted with the <code>grow_main</code> and <code>shrink_main</code> or, while the main pane is in focus, <code>grow</code> and <code>shrink</code>.</p> <p>::</p> <pre><code>---------------------\n|                   |\n|                   |\n|                   |\n|___________________|\n|                   |\n|                   |\n---------------------\n</code></pre> <p>Using the <code>flip</code> method will switch which vertical side the main pane will occupy. The main pane is considered the \"top\" of the stack.</p> <p>::</p> <pre><code>---------------------\n|                   |\n|___________________|\n|                   |\n|                   |\n|                   |\n|                   |\n---------------------\n</code></pre> <p>Secondary-panes:</p> <p>Occupying the rest of the screen_rect are one or more secondary panes. The secondary panes will share the horizontal space of the screen_rect however they can be resized at will with the <code>grow</code> and <code>shrink</code> methods. The other secondary panes will adjust their sizes to smoothly fill all of the space.</p> <p>::</p> <pre><code>---------------------          ---------------------\n|                   |          |                   |\n|                   |          |                   |\n|                   |          |                   |\n|___________________|          |___________________|\n|     |       |     |          |   |           |   |\n|     |       |     |          |   |           |   |\n---------------------          ---------------------\n</code></pre> <p>Panes can be moved with the <code>shuffle_up</code> and <code>shuffle_down</code> methods. As mentioned the main pane is considered the top of the stack; moving up is counter-clockwise and moving down is clockwise.</p> <p>The opposite is true if the layout is \"flipped\".</p> <p>::</p> <pre><code>---------------------          ---------------------\n|                   |          |  2  |   3   |  4  |\n|         1         |          |_____|_______|_____|\n|                   |          |                   |\n|___________________|          |                   |\n|     |       |     |          |        1          |\n|  2  |   3   |  4  |          |                   |\n---------------------          ---------------------\n</code></pre> <p>Normalizing/Resetting:</p> <p>To restore all secondary client windows to their default size ratios use the <code>normalize</code> method.</p> <p>To reset all client windows to their default sizes, including the primary window, use the <code>reset</code> method.</p> <p>Maximizing:</p> <p>To toggle a client window between its minimum and maximum sizes simply use the <code>maximize</code> on a focused client.</p> <p>Suggested Bindings::</p> <pre><code>Key([modkey], \"h\", lazy.layout.left()),\nKey([modkey], \"l\", lazy.layout.right()),\nKey([modkey], \"j\", lazy.layout.down()),\nKey([modkey], \"k\", lazy.layout.up()),\nKey([modkey, \"shift\"], \"h\", lazy.layout.swap_left()),\nKey([modkey, \"shift\"], \"l\", lazy.layout.swap_right()),\nKey([modkey, \"shift\"], \"j\", lazy.layout.shuffle_down()),\nKey([modkey, \"shift\"], \"k\", lazy.layout.shuffle_up()),\nKey([modkey], \"i\", lazy.layout.grow()),\nKey([modkey], \"m\", lazy.layout.shrink()),\nKey([modkey], \"n\", lazy.layout.reset()),\nKey([modkey, \"shift\"], \"n\", lazy.layout.normalize()),\nKey([modkey], \"o\", lazy.layout.maximize()),\nKey([modkey, \"shift\"], \"space\", lazy.layout.flip()),\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Add client to layout</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Clone layout for other groups</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Position client based on order and sizes</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>flip</code>           \u2013            <p>Flip the layout horizontally</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get_shrink_margin</code>           \u2013            <p>Return how many remaining pixels a client can shrink</p> </li> <li> <code>grow</code>           \u2013            <p>Grow current window</p> </li> <li> <code>grow_down_shared</code>           \u2013            <p>Grow lower secondary clients</p> </li> <li> <code>grow_main</code>           \u2013            <p>Grow main pane</p> </li> <li> <code>grow_up_shared</code>           \u2013            <p>Grow higher secondary clients</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>left</code>           \u2013            <p>Focus on the closest window to the left of the current window</p> </li> <li> <code>maximize</code>           \u2013            <p>Grow the currently focused client to the max size</p> </li> <li> <code>normalize</code>           \u2013            <p>Evenly distribute screen-space among secondary clients</p> </li> <li> <code>remove</code>           \u2013            <p>Remove client from layout</p> </li> <li> <code>reset</code>           \u2013            <p>Reset Layout.</p> </li> <li> <code>right</code>           \u2013            <p>Focus on the closest window to the right of the current window</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_ratio</code>           \u2013            <p>Directly set the main pane ratio</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>shrink</code>           \u2013            <p>Shrink current window</p> </li> <li> <code>shrink_down</code>           \u2013            <p>Shrink current window down</p> </li> <li> <code>shrink_down_shared</code>           \u2013            <p>Shrink secondary clients</p> </li> <li> <code>shrink_main</code>           \u2013            <p>Shrink main pane</p> </li> <li> <code>shrink_up</code>           \u2013            <p>Shrink the window up</p> </li> <li> <code>shrink_up_shared</code>           \u2013            <p>Shrink the shared space</p> </li> <li> <code>shuffle_down</code>           \u2013            <p>Shuffle the client down the stack</p> </li> <li> <code>shuffle_up</code>           \u2013            <p>Shuffle the client up the stack</p> </li> <li> <code>swap</code>           \u2013            <p>Swap two windows</p> </li> <li> <code>swap_left</code>           \u2013            <p>Swap current window with closest window to the down</p> </li> <li> <code>swap_main</code>           \u2013            <p>Swap current window to main pane</p> </li> <li> <code>swap_right</code>           \u2013            <p>Swap current window with closest window to the up</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Add client to layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Clone layout for other groups</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Position client based on order and sizes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.flip","title":"flip","text":"<pre><code>flip()\n</code></pre> <p>Flip the layout horizontally</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.get_shrink_margin","title":"get_shrink_margin","text":"<pre><code>get_shrink_margin(cidx)\n</code></pre> <p>Return how many remaining pixels a client can shrink</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.grow","title":"grow","text":"<pre><code>grow()\n</code></pre> <p>Grow current window</p> <p>Will grow the currently focused client reducing the size of those around it. Growing will stop when no other secondary clients can reduce their size any further.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.grow_down_shared","title":"grow_down_shared","text":"<pre><code>grow_down_shared(cidx, amt)\n</code></pre> <p>Grow lower secondary clients</p> <p>Will grow all secondary clients below the specified index by an equal share of the provided amount.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.grow_main","title":"grow_main","text":"<pre><code>grow_main()\n</code></pre> <p>Grow main pane</p> <p>Will grow the main pane, reducing the size of clients in the secondary pane.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.grow_up_shared","title":"grow_up_shared","text":"<pre><code>grow_up_shared(cidx, amt)\n</code></pre> <p>Grow higher secondary clients</p> <p>Will grow all secondary clients above the specified index by an equal share of the provided amount.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.left","title":"left","text":"<pre><code>left()\n</code></pre> <p>Focus on the closest window to the left of the current window</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.maximize","title":"maximize","text":"<pre><code>maximize()\n</code></pre> <p>Grow the currently focused client to the max size</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.normalize","title":"normalize","text":"<pre><code>normalize(redraw=True)\n</code></pre> <p>Evenly distribute screen-space among secondary clients</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Remove client from layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.reset","title":"reset","text":"<pre><code>reset(ratio=None, redraw=True)\n</code></pre> <p>Reset Layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.right","title":"right","text":"<pre><code>right()\n</code></pre> <p>Focus on the closest window to the right of the current window</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.set_ratio","title":"set_ratio","text":"<pre><code>set_ratio(ratio)\n</code></pre> <p>Directly set the main pane ratio</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shrink","title":"shrink","text":"<pre><code>shrink()\n</code></pre> <p>Shrink current window</p> <p>Will shrink the currently focused client reducing the size of those around it. Shrinking will stop when the client has reached the minimum size.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shrink_down","title":"shrink_down","text":"<pre><code>shrink_down(cidx, amt)\n</code></pre> <p>Shrink current window down</p> <p>Will shrink all secondary clients below the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shrink_down_shared","title":"shrink_down_shared","text":"<pre><code>shrink_down_shared(cidx, amt)\n</code></pre> <p>Shrink secondary clients</p> <p>Will shrink all secondary clients below the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with <code>shrink_down</code>.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shrink_main","title":"shrink_main","text":"<pre><code>shrink_main()\n</code></pre> <p>Shrink main pane</p> <p>Will shrink the main pane, increasing the size of clients in the secondary pane.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shrink_up","title":"shrink_up","text":"<pre><code>shrink_up(cidx, amt)\n</code></pre> <p>Shrink the window up</p> <p>Will shrink all secondary clients above the specified index in order. Each client will attempt to shrink as much as it is able before the next client is resized.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shrink_up_shared","title":"shrink_up_shared","text":"<pre><code>shrink_up_shared(cidx, amt)\n</code></pre> <p>Shrink the shared space</p> <p>Will shrink all secondary clients above the specified index by an equal share of the provided amount. After applying the shared amount to all affected clients, any amount left over will be applied in a non-equal manner with <code>shrink_up</code>.</p> <p>Any amount that was unable to be applied to the clients is returned.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shuffle_down","title":"shuffle_down","text":"<pre><code>shuffle_down()\n</code></pre> <p>Shuffle the client down the stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.shuffle_up","title":"shuffle_up","text":"<pre><code>shuffle_up()\n</code></pre> <p>Shuffle the client up the stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap two windows</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.swap_left","title":"swap_left","text":"<pre><code>swap_left()\n</code></pre> <p>Swap current window with closest window to the down</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.swap_main","title":"swap_main","text":"<pre><code>swap_main()\n</code></pre> <p>Swap current window to main pane</p>"},{"location":"manual/ref/layouts/#libqtile.layout.MonadWide.swap_right","title":"swap_right","text":"<pre><code>swap_right()\n</code></pre> <p>Swap current window with closest window to the up</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile","title":"RatioTile","text":"<pre><code>RatioTile(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>Tries to tile all windows in the width/height ratio passed in</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.add_client","title":"add_client","text":"<pre><code>add_client(w: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.configure","title":"configure","text":"<pre><code>configure(win, screen)\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.remove","title":"remove","text":"<pre><code>remove(w: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.RatioTile.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit","title":"ScreenSplit","text":"<pre><code>ScreenSplit(**config)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>A layout that allows you to split the screen into separate areas, each of which can be assigned its own layout.</p> <p>This layout is intended to be used on large monitors where separate layouts may be desirable. However, unlike creating virtual screens, this layout retains the full screen configuration meaning that full screen windows will continue to fill the entire screen.</p> Each split is defined as a dictionary with the following keys <ul> <li><code>name</code>: this is used with the <code>ScreenSplit</code> widget (see below)</li> <li><code>rect</code>: a tuple of (x, y, width, height) with each value being between 0 and 1.   These are relative values based on the screen's dimensions e.g. a value of   <code>(0.5, 0, 0.5, 1)</code> would define an area starting at the top middle of the screen   and extending to the bottom left corner.</li> <li><code>layout</code>: the layout to occupy the defined split.</li> <li><code>matches</code>: (optional) list of <code>Match</code> objects which define which windows will   open in the defined split.</li> </ul> <p>Different splits can be selected by using the following <code>lazy.layout.next_split()</code> and <code>lazy.layout.previous_split()</code> commands.</p> <p>To identify which split is active, users can use the <code>ScreenSplit</code> widget will show the name of the split and the relevant layout. Scrolling up and down on the widget will change the active split.</p> <p>Note</p> <p> While keybindings will be passed to the active split's layout, bindings using the <code>.when(layout=...)``` syntax will not be applied as the primary layout is</code>ScreenSplit``.</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>move_window_to_next_split</code>           \u2013            <p>Move current window to next split.</p> </li> <li> <code>move_window_to_previous_split</code>           \u2013            <p>Move current window to previous split.</p> </li> <li> <code>next</code>           \u2013            <p>Move to next client.</p> </li> <li> <code>next_split</code>           \u2013            <p>Move to next split.</p> </li> <li> <code>previous</code>           \u2013            <p>Move to previous client.</p> </li> <li> <code>previous_split</code>           \u2013            <p>Move to previous client.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.add_client","title":"add_client","text":"<pre><code>add_client(win: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; ScreenSplit\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.commands","title":"commands","text":"<pre><code>commands()\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus_next","title":"focus_next","text":"<pre><code>focus_next(win: Window) -&gt; Window\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(win: Window) -&gt; Window\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.move_window_to_next_split","title":"move_window_to_next_split","text":"<pre><code>move_window_to_next_split() -&gt; None\n</code></pre> <p>Move current window to next split.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.move_window_to_previous_split","title":"move_window_to_previous_split","text":"<pre><code>move_window_to_previous_split() -&gt; None\n</code></pre> <p>Move current window to previous split.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.next","title":"next","text":"<pre><code>next() -&gt; None\n</code></pre> <p>Move to next client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.next_split","title":"next_split","text":"<pre><code>next_split() -&gt; None\n</code></pre> <p>Move to next split.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.previous","title":"previous","text":"<pre><code>previous() -&gt; None\n</code></pre> <p>Move to previous client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.previous_split","title":"previous_split","text":"<pre><code>previous_split() -&gt; None\n</code></pre> <p>Move to previous client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.remove","title":"remove","text":"<pre><code>remove(win: Window) -&gt; None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.show","title":"show","text":"<pre><code>show(_rect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.ScreenSplit.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice","title":"Slice","text":"<pre><code>Slice(**config)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>Slice layout</p> <p>This layout cuts piece of screen_rect and places a single window on that piece, and delegates other window placement to other layout</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>delegate_layout</code>           \u2013            <p>Delegates layouting actual windows</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>move_to_slice</code>           \u2013            <p>Moves the current window to the slice.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.add_client","title":"add_client","text":"<pre><code>add_client(win)\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.command","title":"command","text":"<pre><code>command(name: str)\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.commands","title":"commands","text":"<pre><code>commands()\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.configure","title":"configure","text":"<pre><code>configure(win, screen_rect)\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.delegate_layout","title":"delegate_layout","text":"<pre><code>delegate_layout(windows, mapping)\n</code></pre> <p>Delegates layouting actual windows</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.delegate_layout--parameters","title":"Parameters","text":"<p>windows:     windows to layout mapping:     mapping from layout to ScreenRect for each layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus","title":"focus","text":"<pre><code>focus(win)\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus_next","title":"focus_next","text":"<pre><code>focus_next(win: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(win: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.move_to_slice","title":"move_to_slice","text":"<pre><code>move_to_slice()\n</code></pre> <p>Moves the current window to the slice.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.remove","title":"remove","text":"<pre><code>remove(win: Window) -&gt; Window\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Slice.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral","title":"Spiral","text":"<pre><code>Spiral(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>A mathematical layout.</p> <p>Renders windows in a spiral form by splitting the screen based on a selected ratio. The direction of the split is changed every time in a defined order resulting in a spiral formation.</p> <p>The main window can be sized with <code>lazy.layout.grow_main()</code> and <code>lazy.layout.shrink_main()</code>. All other windows are sized by <code>lazy.layout.increase_ratio()</code> and <code>lazy.layout.decrease_ratio()</code>.</p> <p>NB if <code>main_pane_ratio</code> is not set then it will also be adjusted according to <code>ratio</code>. However, as soon <code>shrink_main()</code> or <code>grow_main()</code> have been called once then the master pane will only change size following further calls to those methods.</p> <p>Users are able to choose the location of the main (i.e. largest) pane and the direction of the rotation.</p> <p>Some examples:</p> <p><code>main_pane=\"left\", clockwise=True</code></p> <p>::</p> <pre><code>----------------------\n|1        |2         |\n|         |          |\n|         |          |\n|         |----------|\n|         |5 |6 |3   |\n|         |-----|    |\n|         |4    |    |\n----------------------\n</code></pre> <p><code>main_pane=\"top\", clockwise=False</code></p> <p>::</p> <pre><code>----------------------\n|1                   |\n|                    |\n|                    |\n|--------------------|\n|2        |5    |4   |\n|         |----------|\n|         |3         |\n----------------------\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>decrease_ratio</code>           \u2013            <p>Decrease spiral ratio.</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get_spiral</code>           \u2013            <p>Calculates positions of windows in the spiral.</p> </li> <li> <code>grow_main</code>           \u2013            <p>Grow the main window.</p> </li> <li> <code>has_invalid_size</code>           \u2013            <p>Checks if window would have an invalid size.</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>increase_ratio</code>           \u2013            <p>Increase spiral ratio.</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>reset</code>           \u2013            <p>Reset ratios to values set in config.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_master_ratio</code>           \u2013            <p>Set the ratio for the main window.</p> </li> <li> <code>set_ratio</code>           \u2013            <p>Set the ratio for all windows.</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>shrink_main</code>           \u2013            <p>Shrink the main window.</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.configure","title":"configure","text":"<pre><code>configure(win, screen)\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.decrease_ratio","title":"decrease_ratio","text":"<pre><code>decrease_ratio()\n</code></pre> <p>Decrease spiral ratio.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.get_spiral","title":"get_spiral","text":"<pre><code>get_spiral(x, y, width, height) -&gt; list[Rect]\n</code></pre> <p>Calculates positions of windows in the spiral.</p> <p>Returns a list of tuples (x, y, w, h) for positioning windows.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.grow_main","title":"grow_main","text":"<pre><code>grow_main()\n</code></pre> <p>Grow the main window.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.has_invalid_size","title":"has_invalid_size","text":"<pre><code>has_invalid_size(win: Rect) -&gt; bool\n</code></pre> <p>Checks if window would have an invalid size.</p> <p>A window that would have negative height or width (after adjusting for margins and borders) will return True.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.increase_ratio","title":"increase_ratio","text":"<pre><code>increase_ratio()\n</code></pre> <p>Increase spiral ratio.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.remove","title":"remove","text":"<pre><code>remove(w: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset ratios to values set in config.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.set_master_ratio","title":"set_master_ratio","text":"<pre><code>set_master_ratio(ratio: float)\n</code></pre> <p>Set the ratio for the main window.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.set_ratio","title":"set_ratio","text":"<pre><code>set_ratio(ratio: float)\n</code></pre> <p>Set the ratio for all windows.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.shrink_main","title":"shrink_main","text":"<pre><code>shrink_main()\n</code></pre> <p>Shrink the main window.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Spiral.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack","title":"Stack","text":"<pre><code>Stack(**config)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>A layout composed of stacks of windows</p> <p>The stack layout divides the screen_rect horizontally into a set of stacks. Commands allow you to switch between stacks, to next and previous windows within a stack, and to split a stack to show all windows in the stack, or unsplit it to show only the current window.</p> <p>Unlike the columns layout the number of stacks is fixed.</p> <p>Methods:</p> <ul> <li> <code>add</code>           \u2013            <p>Add another stack to the layout</p> </li> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>client_to_next</code>           \u2013            <p>Send the current client to the next stack</p> </li> <li> <code>client_to_previous</code>           \u2013            <p>Send the current client to the previous stack</p> </li> <li> <code>client_to_stack</code>           \u2013            <p>Send the current client to stack n, where n is an integer offset.  If</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>delete</code>           \u2013            <p>Delete the current stack from the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>down</code>           \u2013            <p>Switch to the next window in this stack</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>next</code>           \u2013            <p>Focus next stack</p> </li> <li> <code>previous</code>           \u2013            <p>Focus previous stack</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>rotate</code>           \u2013            <p>Rotate order of the stacks</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>shuffle_down</code>           \u2013            <p>Shuffle the order of this stack down</p> </li> <li> <code>shuffle_up</code>           \u2013            <p>Shuffle the order of this stack up</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> <li> <code>toggle_split</code>           \u2013            <p>Toggle vertical split on the current stack</p> </li> <li> <code>up</code>           \u2013            <p>Switch to the previous window in this stack</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.add","title":"add","text":"<pre><code>add()\n</code></pre> <p>Add another stack to the layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.client_to_next","title":"client_to_next","text":"<pre><code>client_to_next()\n</code></pre> <p>Send the current client to the next stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.client_to_previous","title":"client_to_previous","text":"<pre><code>client_to_previous()\n</code></pre> <p>Send the current client to the previous stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.client_to_stack","title":"client_to_stack","text":"<pre><code>client_to_stack(n)\n</code></pre> <p>Send the current client to stack n, where n is an integer offset.  If is too large or less than 0, it is wrapped modulo the number of stacks.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the current stack from the layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.down","title":"down","text":"<pre><code>down()\n</code></pre> <p>Switch to the next window in this stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus_next","title":"focus_next","text":"<pre><code>focus_next(client: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(client: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.next","title":"next","text":"<pre><code>next() -&gt; None\n</code></pre> <p>Focus next stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.previous","title":"previous","text":"<pre><code>previous() -&gt; None\n</code></pre> <p>Focus previous stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.rotate","title":"rotate","text":"<pre><code>rotate()\n</code></pre> <p>Rotate order of the stacks</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.shuffle_down","title":"shuffle_down","text":"<pre><code>shuffle_down()\n</code></pre> <p>Shuffle the order of this stack down</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.shuffle_up","title":"shuffle_up","text":"<pre><code>shuffle_up()\n</code></pre> <p>Shuffle the order of this stack up</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.toggle_split","title":"toggle_split","text":"<pre><code>toggle_split()\n</code></pre> <p>Toggle vertical split on the current stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Stack.up","title":"up","text":"<pre><code>up()\n</code></pre> <p>Switch to the previous window in this stack</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile","title":"Tile","text":"<pre><code>Tile(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>A layout with two stacks of windows dividing the screen</p> <p>The Tile layout divides the screen_rect horizontally into two stacks. The maximum amount of \"master\" windows can be configured; surplus windows will be displayed in the slave stack on the right. Within their stacks, the windows will be tiled vertically. The windows can be rotated in their entirety by calling up() or down() or, if shift_windows is set to True, individually.</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.add_client","title":"add_client","text":"<pre><code>add_client(client, offset_to_current=1)\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Tile.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab","title":"TreeTab","text":"<pre><code>TreeTab(**config)\n</code></pre> <p>             Bases: <code>Layout</code></p> <p>Tree Tab Layout</p> <p>This layout works just like Max but displays tree of the windows at the left border of the screen_rect, which allows you to overview all opened windows. It's designed to work with <code>uzbl-browser</code> but works with other windows too.</p> <p>The panel at the left border contains sections, each of which contains windows. Initially the panel looks like flat lists inside its section, and looks like trees if some of the windows are \"moved\" left or right.</p> <p>For example, it looks like below with two sections initially:</p> <p>::</p> <pre><code>+------------+\n|Section Foo |\n+------------+\n| Window A   |\n+------------+\n| Window B   |\n+------------+\n| Window C   |\n+------------+\n|Section Bar |\n+------------+\n</code></pre> <p>And then it will look like below if \"Window B\" is moved right and \"Window C\" is moved right too:</p> <p>::</p> <pre><code>+------------+\n|Section Foo |\n+------------+\n| Window A   |\n+------------+\n|  Window B  |\n+------------+\n|   Window C |\n+------------+\n|Section Bar |\n+------------+\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>add_section</code>           \u2013            <p>Add named section to tree</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>del_section</code>           \u2013            <p>Remove named section from tree</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>next</code>           \u2013            <p>Switch down in the window list</p> </li> <li> <code>previous</code>           \u2013            <p>Switch up in the window list</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>sort_windows</code>           \u2013            <p>Sorts window to sections using sorter function</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.add_client","title":"add_client","text":"<pre><code>add_client(win)\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.add_section","title":"add_section","text":"<pre><code>add_section(name)\n</code></pre> <p>Add named section to tree</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.del_section","title":"del_section","text":"<pre><code>del_section(name)\n</code></pre> <p>Remove named section from tree</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus","title":"focus","text":"<pre><code>focus(win)\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus_next","title":"focus_next","text":"<pre><code>focus_next(client: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(client: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.next","title":"next","text":"<pre><code>next() -&gt; None\n</code></pre> <p>Switch down in the window list</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.previous","title":"previous","text":"<pre><code>previous() -&gt; None\n</code></pre> <p>Switch up in the window list</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.remove","title":"remove","text":"<pre><code>remove(win: Window) -&gt; None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.sort_windows","title":"sort_windows","text":"<pre><code>sort_windows(sorter, create_sections=True)\n</code></pre> <p>Sorts window to sections using sorter function</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.sort_windows--parameters","title":"Parameters","text":"<p>sorter: function with single arg returning string     returns name of the section where window should be create_sections:     if this parameter is True (default), if sorter returns unknown     section name it will be created dynamically</p>"},{"location":"manual/ref/layouts/#libqtile.layout.TreeTab.swap","title":"swap","text":"<pre><code>swap(c1: Window, c2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile","title":"VerticalTile","text":"<pre><code>VerticalTile(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>Tiling layout that works nice on vertically mounted monitors</p> <p>The available height gets divided by the number of panes, if no pane is maximized. If one pane has been maximized, the available height gets split in master- and secondary area. The maximized pane (master pane) gets the full height of the master area and the other panes (secondary panes) share the remaining space.  The master area (at default 75%) can grow and shrink via keybindings.</p> <p>::</p> <pre><code>-----------------                -----------------  ---\n|               |                |               |   |\n|       1       |  &lt;-- Panes     |               |   |\n|               |        |       |               |   |\n|---------------|        |       |               |   |\n|               |        |       |               |   |\n|       2       |  &lt;-----+       |       1       |   |  Master Area\n|               |        |       |               |   |\n|---------------|        |       |               |   |\n|               |        |       |               |   |\n|       3       |  &lt;-----+       |               |   |\n|               |        |       |               |   |\n|---------------|        |       |---------------|  ---\n|               |        |       |       2       |   |\n|       4       |  &lt;-----+       |---------------|   |  Secondary Area\n|               |                |       3       |   |\n-----------------                -----------------  ---\n</code></pre> <p>Normal behavior. No              One maximized pane in the master area maximized pane. No               and two secondary panes in the specific areas.                  secondary area.</p> <p>::</p> <pre><code>-----------------------------------  In some cases VerticalTile can be\n|                                 |  useful on horizontal mounted\n|                1                |  monitors two.\n|                                 |  For example if you want to have a\n|---------------------------------|  webbrowser and a shell below it.\n|                                 |\n|                2                |\n|                                 |\n-----------------------------------\n</code></pre> <p>Suggested keybindings:</p> <p>::</p> <pre><code>Key([modkey], 'j', lazy.layout.down()),\nKey([modkey], 'k', lazy.layout.up()),\nKey([modkey], 'Tab', lazy.layout.next()),\nKey([modkey, 'shift'], 'Tab', lazy.layout.next()),\nKey([modkey, 'shift'], 'j', lazy.layout.shuffle_down()),\nKey([modkey, 'shift'], 'k', lazy.layout.shuffle_up()),\nKey([modkey], 'm', lazy.layout.maximize()),\nKey([modkey], 'n', lazy.layout.normalize()),\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.add_client","title":"add_client","text":"<pre><code>add_client(window)\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.configure","title":"configure","text":"<pre><code>configure(window, screen_rect)\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus","title":"focus","text":"<pre><code>focus(client: Window) -&gt; None\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.remove","title":"remove","text":"<pre><code>remove(window: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.VerticalTile.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy","title":"Zoomy","text":"<pre><code>Zoomy(**config)\n</code></pre> <p>             Bases: <code>_SimpleLayoutBase</code></p> <p>A layout with single active windows, and few other previews at the right</p> <p>Methods:</p> <ul> <li> <code>add_client</code>           \u2013            <p>Called whenever a window is added to the group</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>blur</code>           \u2013            <p>Called whenever focus is gone from this layout</p> </li> <li> <code>clone</code>           \u2013            <p>Duplicate a layout</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>configure</code>           \u2013            <p>Configure the layout</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Called whenever the focus changes</p> </li> <li> <code>focus_first</code>           \u2013            <p>Called when the first client in Layout shall be focused.</p> </li> <li> <code>focus_last</code>           \u2013            <p>Called when the last client in Layout shall be focused.</p> </li> <li> <code>focus_next</code>           \u2013            <p>Called when the next client in Layout shall be focused.</p> </li> <li> <code>focus_previous</code>           \u2013            <p>Called when the previous client in Layout shall be focused.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>hide</code>           \u2013            <p>Called when layout is being hidden</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of layout information</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>remove</code>           \u2013            <p>Called whenever a window is removed from the group</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>show</code>           \u2013            <p>Called when layout is being shown</p> </li> <li> <code>swap</code>           \u2013            <p>Swap the two given clients c1 and c2</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>group</code>             (<code>_Group</code>)         \u2013          <p>Returns the group this layout is attached to.</p> </li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.group","title":"group  <code>property</code>","text":"<pre><code>group: _Group\n</code></pre> <p>Returns the group this layout is attached to.</p> <p>Layouts start out unattached, and are attached when the group is configured and each layout is cloned for every group.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.add_client","title":"add_client","text":"<pre><code>add_client(client: Window) -&gt; None\n</code></pre> <p>Called whenever a window is added to the group</p> <p>Called whether the layout is current or not. The layout should just add the window to its internal datastructures, without mapping or configuring.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>Called whenever focus is gone from this layout</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.clone","title":"clone","text":"<pre><code>clone(group: _Group) -&gt; Self\n</code></pre> <p>Duplicate a layout</p> <p>Make a copy of this layout. This is done to provide each group with a unique instance of every layout.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.clone--parameters","title":"Parameters","text":"<p>group:     Group to attach new layout instance to.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.configure","title":"configure","text":"<pre><code>configure(client: Window, screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Configure the layout</p> <p>This method should:</p> <pre><code>- Configure the dimensions and borders of a window using the\n  `.place()` method.\n- Call either `.hide()` or `.unhide()` on the window.\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus","title":"focus","text":"<pre><code>focus(win)\n</code></pre> <p>Called whenever the focus changes</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus_first","title":"focus_first","text":"<pre><code>focus_first() -&gt; Window | None\n</code></pre> <p>Called when the first client in Layout shall be focused.</p> This method should <ul> <li>Return the first client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus_last","title":"focus_last","text":"<pre><code>focus_last() -&gt; Window | None\n</code></pre> <p>Called when the last client in Layout shall be focused.</p> This method should <ul> <li>Return the last client in Layout, if any.</li> <li>Not focus the client itself, this is done by caller.</li> </ul>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus_next","title":"focus_next","text":"<pre><code>focus_next(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the next client in Layout shall be focused.</p> This method should <ul> <li>Return the next client in Layout, if any.</li> <li>Return None if the next client would be the first client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus_next--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus_previous","title":"focus_previous","text":"<pre><code>focus_previous(window: Window) -&gt; Window | None\n</code></pre> <p>Called when the previous client in Layout shall be focused.</p> This method should <ul> <li>Return the previous client in Layout, if any.</li> <li>Return None if the previous client would be the last client.</li> <li>Not focus the client itself, this is done by caller.</li> </ul> <p>Do not implement a full cycle here, because the Groups cycling relies on returning None here if the end of Layout is hit, such that Floating clients are included in cycle.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.focus_previous--parameters","title":"Parameters","text":"<p>win:     The currently focused client.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Called when layout is being hidden</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.info","title":"info","text":"<pre><code>info() -&gt; dict[str, Any]\n</code></pre> <p>Returns a dictionary of layout information</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.remove","title":"remove","text":"<pre><code>remove(client: Window) -&gt; Window | None\n</code></pre> <p>Called whenever a window is removed from the group</p> <p>Called whether the layout is current or not. The layout should just de-register the window from its data structures, without unmapping the window.</p> <p>Returns the \"next\" window that should gain focus or None.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.show","title":"show","text":"<pre><code>show(screen_rect: ScreenRect) -&gt; None\n</code></pre> <p>Called when layout is being shown</p>"},{"location":"manual/ref/layouts/#libqtile.layout.Zoomy.swap","title":"swap","text":"<pre><code>swap(window1: Window, window2: Window) -&gt; None\n</code></pre> <p>Swap the two given clients c1 and c2</p>"},{"location":"manual/ref/widgets/","title":"Built-in Widgets","text":"<p>Classes:</p> <ul> <li> <code>AGroupBox</code>         \u2013          <p>A widget that graphically displays the current group</p> </li> <li> <code>Backlight</code>         \u2013          <p>A simple widget to show the current brightness of a monitor.</p> </li> <li> <code>Battery</code>         \u2013          <p>A text-based battery monitoring widget supporting both Linux and FreeBSD.</p> </li> <li> <code>BatteryIcon</code>         \u2013          <p>Battery life indicator widget.</p> </li> <li> <code>Bluetooth</code>         \u2013          <p>Bluetooth widget that provides following functionality:</p> </li> <li> <code>CPU</code>         \u2013          <p>A simple widget to display CPU load and frequency.</p> </li> <li> <code>CPUGraph</code>         \u2013          <p>Display CPU usage graph.</p> </li> <li> <code>Canto</code>         \u2013          <p>Display RSS feeds updates using the canto console reader</p> </li> <li> <code>CapsNumLockIndicator</code>         \u2013          <p>Really simple widget to show the current Caps/Num Lock state.</p> </li> <li> <code>CheckUpdates</code>         \u2013          </li> <li> <code>Chord</code>         \u2013          <p>Display current key chord</p> </li> <li> <code>Clipboard</code>         \u2013          <p>Display current clipboard contents</p> </li> <li> <code>Clock</code>         \u2013          <p>A simple but flexible text-based clock</p> </li> <li> <code>Cmus</code>         \u2013          <p>A simple Cmus widget.</p> </li> <li> <code>Countdown</code>         \u2013          <p>A simple countdown timer text widget</p> </li> <li> <code>CryptoTicker</code>         \u2013          <p>A cryptocurrency ticker widget, data provided by the coinbase.com or the binance.com</p> </li> <li> <code>CurrentLayout</code>         \u2013          <p>Display the name of the current layout of the current group of the screen,</p> </li> <li> <code>CurrentLayoutIcon</code>         \u2013          <p>Display the icon representing the current layout of the</p> </li> <li> <code>CurrentScreen</code>         \u2013          <p>Indicates whether the screen this widget is on is currently active or not</p> </li> <li> <code>DF</code>         \u2013          <p>Disk Free Widget</p> </li> <li> <code>DoNotDisturb</code>         \u2013          <p>Displays Do Not Disturb status for notification server Dunst by default.</p> </li> <li> <code>GenPollCommand</code>         \u2013          <p>A generic text widget to display output from scripts or shell commands</p> </li> <li> <code>GenPollText</code>         \u2013          <p>A generic text widget that polls using poll function to get the text</p> </li> <li> <code>GenPollUrl</code>         \u2013          <p>A generic text widget that polls an url and parses it using parse function</p> </li> <li> <code>GmailChecker</code>         \u2013          <p>A simple gmail checker. If 'status_only_unseen' is True - set 'fmt' for one</p> </li> <li> <code>GroupBox</code>         \u2013          <p>A widget that graphically displays the current group.</p> </li> <li> <code>HDD</code>         \u2013          <p>Displays HDD usage in percent based on the number of milliseconds the device has been performing I/O operations.</p> </li> <li> <code>HDDBusyGraph</code>         \u2013          <p>Display HDD busy time graph</p> </li> <li> <code>HDDGraph</code>         \u2013          <p>Display HDD free or used space graph</p> </li> <li> <code>IdleRPG</code>         \u2013          <p>A widget for monitoring and displaying IdleRPG stats.</p> </li> <li> <code>Image</code>         \u2013          <p>Display a PNG image on the bar</p> </li> <li> <code>ImapWidget</code>         \u2013          <p>Email IMAP widget</p> </li> <li> <code>KeyboardKbdd</code>         \u2013          <p>Widget for changing keyboard layouts per window, using kbdd</p> </li> <li> <code>KeyboardLayout</code>         \u2013          <p>Widget for changing and displaying the current keyboard layout</p> </li> <li> <code>KhalCalendar</code>         \u2013          <p>Khal calendar widget</p> </li> <li> <code>LaunchBar</code>         \u2013          <p>This module defines a widget that displays icons to launch softwares or commands</p> </li> <li> <code>Load</code>         \u2013          <p>A small widget to show the load averages of the system.</p> </li> <li> <code>Maildir</code>         \u2013          <p>A simple widget showing the number of new mails in maildir mailboxes</p> </li> <li> <code>Memory</code>         \u2013          <p>Display memory/swap usage.</p> </li> <li> <code>MemoryGraph</code>         \u2013          <p>Displays a memory usage graph.</p> </li> <li> <code>Mirror</code>         \u2013          <p>A widget for showing the same widget content in more than one place, for</p> </li> <li> <code>Moc</code>         \u2013          <p>A simple MOC widget.</p> </li> <li> <code>Mpd2</code>         \u2013          <p>Mpd2 Object.</p> </li> <li> <code>Mpris2</code>         \u2013          <p>An MPRIS 2 widget</p> </li> <li> <code>Net</code>         \u2013          <p>Displays interface down and up speed</p> </li> <li> <code>NetGraph</code>         \u2013          <p>Display a network usage graph.</p> </li> <li> <code>Notify</code>         \u2013          <p>A notify widget</p> </li> <li> <code>NvidiaSensors</code>         \u2013          <p>Displays temperature, fan speed and performance level Nvidia GPU.</p> </li> <li> <code>OpenWeather</code>         \u2013          <p>A weather widget, data provided by the OpenWeather API.</p> </li> <li> <code>Pomodoro</code>         \u2013          <p>Pomodoro technique widget</p> </li> <li> <code>Prompt</code>         \u2013          <p>A widget that prompts for user input</p> </li> <li> <code>PulseVolume</code>         \u2013          <p>Volume widget for systems using PulseAudio.</p> </li> <li> <code>QuickExit</code>         \u2013          <p>A button to shut down Qtile. When clicked, a countdown starts. Clicking</p> </li> <li> <code>ScreenSplit</code>         \u2013          <p>A simple widget to show the name of the current split and layout for the</p> </li> <li> <code>Sep</code>         \u2013          <p>A visible widget separator</p> </li> <li> <code>She</code>         \u2013          <p>Widget to display the Super Hybrid Engine status</p> </li> <li> <code>Spacer</code>         \u2013          <p>Just an empty space on the bar</p> </li> <li> <code>StatusNotifier</code>         \u2013          <p>A 'system tray' widget using the freedesktop StatusNotifierItem</p> </li> <li> <code>StockTicker</code>         \u2013          <p>A stock ticker widget, based on the alphavantage API. Users must acquire an</p> </li> <li> <code>SwapGraph</code>         \u2013          <p>Display a swap info graph.</p> </li> <li> <code>Systray</code>         \u2013          <p>A widget that manages system tray.</p> </li> <li> <code>TaskList</code>         \u2013          <p>Displays the icon and name of each window in the current group</p> </li> <li> <code>TextBox</code>         \u2013          <p>A flexible textbox that can be updated from bound keys, scripts, and qshell.</p> </li> <li> <code>ThermalSensor</code>         \u2013          <p>Widget to display temperature sensor information</p> </li> <li> <code>ThermalZone</code>         \u2013          <p>Thermal zone widget.</p> </li> <li> <code>Volume</code>         \u2013          <p>Widget that display and change volume</p> </li> <li> <code>Wallpaper</code>         \u2013          </li> <li> <code>WidgetBox</code>         \u2013          <p>A widget to declutter your bar.</p> </li> <li> <code>WindowCount</code>         \u2013          <p>A simple widget to display the number of windows in the</p> </li> <li> <code>WindowName</code>         \u2013          <p>Displays the name of the window that currently has focus</p> </li> <li> <code>WindowTabs</code>         \u2013          <p>Displays the name of each window in the current group.</p> </li> <li> <code>Wlan</code>         \u2013          <p>Displays Wifi SSID and quality.</p> </li> <li> <code>Wttr</code>         \u2013          <p>Display weather widget provided by wttr.in.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox","title":"AGroupBox","text":"<pre><code>AGroupBox(**config)\n</code></pre> <p>             Bases: <code>_GroupBase</code></p> <p>A widget that graphically displays the current group</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.AGroupBox.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight","title":"Backlight","text":"<pre><code>Backlight(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>A simple widget to show the current brightness of a monitor.</p> <p>If the change_command parameter is set to None, the widget will attempt to use the interface at /sys/class to change brightness. This depends on having the correct udev rules, so be sure Qtile's udev rules are installed correctly.</p> <p>You can also bind keyboard shortcuts to the backlight widget with:</p> <pre><code>from libqtile.widget import backlight\nKey(\n    [],\n    \"XF86MonBrightnessUp\",\n    lazy.widget['backlight'].change_backlight(backlight.ChangeDirection.UP)\n)\nKey(\n    [],\n    \"XF86MonBrightnessDown\",\n    lazy.widget['backlight'].change_backlight(backlight.ChangeDirection.DOWN)\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Backlight.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery","title":"Battery","text":"<pre><code>Battery(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A text-based battery monitoring widget supporting both Linux and FreeBSD.</p> <p>The Linux version of this widget has functionality to charge \"smartly\" (i.e. not to 100%) under user defined conditions, and provides some implementations for doing so. For example, to only charge the battery to 90%, use:</p> <p>.. code-block:: python</p> <pre><code>Battery(..., charge_controller: lambda (0, 90))\n</code></pre> <p>The battery widget also supplies some charging algorithms. To only charge the battery between 40-50% while connected to a thunderbolt docking station, but 90% all other times, use:</p> <p>.. code-block:: python</p> <pre><code>from libqtile.widget.battery import thunderbolt_smart_charge\nBattery(..., charge_controller: thunderbolt_smart_charge)\n</code></pre> <p>To temporarily disable/re-enable this (e.g. if you know you're going mobile and need to charge) use either:</p> <p>.. code-block:: bash</p> <pre><code>qtile cmd-obj -o bar top widget battery -f charge_to_full\nqtile cmd-obj -o bar top widget battery -f charge_dynamically\n</code></pre> <p>or bind a key to:</p> <p>.. code-block:: python</p> <pre><code>Key([mod, \"shift\"], \"c\", lazy.widget['battery'].charge_to_full())\nKey([mod, \"shift\"], \"x\", lazy.widget['battery'].charge_dynamically())\n</code></pre> <p>note that this functionality requires qtile to be able to write to certain files in sysfs, so make sure that qtile's udev rules are installed correctly.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>build_string</code>           \u2013            <p>Determine the string to return for the given battery state</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>poll</code>           \u2013            <p>Determine the text to display</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.build_string","title":"build_string","text":"<pre><code>build_string(status: BatteryStatus) -&gt; str\n</code></pre> <p>Determine the string to return for the given battery state</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.build_string--parameters","title":"Parameters","text":"<p>status:     The current status of the battery</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.build_string--returns","title":"Returns","text":"<p>str     The string to display for the current status.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.poll","title":"poll","text":"<pre><code>poll() -&gt; str\n</code></pre> <p>Determine the text to display</p> <p>Function returning a string with battery information to display on the status bar. Should only use the public interface in _Battery to get necessary information for constructing the string.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Battery.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon","title":"BatteryIcon","text":"<pre><code>BatteryIcon(**config)\n</code></pre> <p>             Bases: <code>_Widget</code></p> <p>Battery life indicator widget.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.draw","title":"draw","text":"<pre><code>draw() -&gt; None\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.BatteryIcon.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup() -&gt; None\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth","title":"Bluetooth","text":"<pre><code>Bluetooth(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code>, <code>MarginMixin</code></p> <p>Bluetooth widget that provides following functionality: - View multiple adapters/devices (adapters can be filtered) - Set power and discovery status for adapters - Connect/disconnect/pair devices</p> <p>The widget works by providing a menu in the bar. Different items are accessed by scrolling up and down on the widget.</p> <p>Clicking on an adapter will open a submenu allowing you to set power and discovery status.</p> <p>Clicking on a device will perform an action based on the status of that device: - Connected devices will be disconnected - Disconnected devices will be connected - Unpaired devices (which appear if discovery is on) will be paired and connected</p> <p>Symbols are used to show the status of adapters and devices.</p> <p>Battery level for bluetooth devices can also be shown if available. This functionality is not available by default on all distros. If it doesn't work, you can try adding <code>Experimental = true</code> to <code>/etc/bluetooth/main.conf</code>.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>click</code>           \u2013            <p>Perform default action on visible item.</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>format_object</code>           \u2013            <p>Takes the given object and returns a formatted string representing the object.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_proxy</code>           \u2013            <p>Provides proxy object after introspecting the given path.</p> </li> <li> <code>hide</code>           \u2013            <p>Revert widget contents to default.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>scroll_down</code>           \u2013            <p>Scroll down to next item.</p> </li> <li> <code>scroll_up</code>           \u2013            <p>Scroll up to next item.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>show_line</code>           \u2013            <p>Formats the text of the current menu item.</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.click","title":"click","text":"<pre><code>click()\n</code></pre> <p>Perform default action on visible item.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.format_object","title":"format_object","text":"<pre><code>format_object(obj)\n</code></pre> <p>Takes the given object and returns a formatted string representing the object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.get_proxy","title":"get_proxy  <code>async</code>","text":"<pre><code>get_proxy(path)\n</code></pre> <p>Provides proxy object after introspecting the given path.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.hide","title":"hide","text":"<pre><code>hide()\n</code></pre> <p>Revert widget contents to default.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.scroll_down","title":"scroll_down","text":"<pre><code>scroll_down()\n</code></pre> <p>Scroll down to next item.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.scroll_up","title":"scroll_up","text":"<pre><code>scroll_up()\n</code></pre> <p>Scroll up to next item.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.show_line","title":"show_line","text":"<pre><code>show_line()\n</code></pre> <p>Formats the text of the current menu item.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Bluetooth.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU","title":"CPU","text":"<pre><code>CPU(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A simple widget to display CPU load and frequency.</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPU.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph","title":"CPUGraph","text":"<pre><code>CPUGraph(**config)\n</code></pre> <p>             Bases: <code>_Graph</code></p> <p>Display CPU usage graph.</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CPUGraph.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto","title":"Canto","text":"<pre><code>Canto(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Display RSS feeds updates using the canto console reader</p> <p>Widget requirements: canto.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Canto.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator","title":"CapsNumLockIndicator","text":"<pre><code>CapsNumLockIndicator(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Really simple widget to show the current Caps/Num Lock state.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_indicators</code>           \u2013            <p>Return a list with the current state of the keys.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>poll</code>           \u2013            <p>Poll content for the text box.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.get_indicators","title":"get_indicators","text":"<pre><code>get_indicators()\n</code></pre> <p>Return a list with the current state of the keys.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.poll","title":"poll","text":"<pre><code>poll()\n</code></pre> <p>Poll content for the text box.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CapsNumLockIndicator.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates","title":"CheckUpdates","text":"<pre><code>CheckUpdates(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CheckUpdates.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord","title":"Chord","text":"<pre><code>Chord(width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Display current key chord</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Chord.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard","title":"Clipboard","text":"<pre><code>Clipboard(width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Display current clipboard contents</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clipboard.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock","title":"Clock","text":"<pre><code>Clock(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>A simple but flexible text-based clock</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> <li> <code>update_timezone</code>           \u2013            <p>Force the clock to update timezone information.</p> </li> <li> <code>use_system_timezone</code>           \u2013            <p>Force clock to use system timezone.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.update_timezone","title":"update_timezone","text":"<pre><code>update_timezone(timezone: str | tzinfo | None = None)\n</code></pre> <p>Force the clock to update timezone information.</p> <p>If the method is called with no arguments then the widget will reload the timzeone set on the computer (e.g. via <code>timedatectl set-timezone ..</code>). This will have no effect if you have previously set a <code>timezone</code> value.</p> <p>Alternatively, you can pass a timezone string (e.g. <code>\"Europe/Lisbon\"</code>) to change the specified timezone. Setting this to an empty string will cause the clock to rely on the system timezone.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Clock.use_system_timezone","title":"use_system_timezone","text":"<pre><code>use_system_timezone()\n</code></pre> <p>Force clock to use system timezone.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus","title":"Cmus","text":"<pre><code>Cmus(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A simple Cmus widget.</p> <p>Show the metadata of now listening song and allow basic mouse control from the bar:</p> <pre><code>- toggle pause (or play if stopped) on left click;\n- skip forward in playlist on scroll up;\n- skip backward in playlist on scroll down.\n</code></pre> <p>Cmus (https://cmus.github.io) should be installed.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_info</code>           \u2013            <p>Return a dictionary with info about the current cmus status.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>now_playing</code>           \u2013            <p>Return a string with the now playing info.</p> </li> <li> <code>play</code>           \u2013            <p>Play music if stopped, else toggle pause.</p> </li> <li> <code>poll</code>           \u2013            <p>Poll content for the text box.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.get_info","title":"get_info","text":"<pre><code>get_info()\n</code></pre> <p>Return a dictionary with info about the current cmus status.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.now_playing","title":"now_playing","text":"<pre><code>now_playing()\n</code></pre> <p>Return a string with the now playing info.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.play","title":"play","text":"<pre><code>play()\n</code></pre> <p>Play music if stopped, else toggle pause.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.poll","title":"poll","text":"<pre><code>poll()\n</code></pre> <p>Poll content for the text box.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Cmus.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown","title":"Countdown","text":"<pre><code>Countdown(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>A simple countdown timer text widget</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Countdown.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker","title":"CryptoTicker","text":"<pre><code>CryptoTicker(**config)\n</code></pre> <p>             Bases: <code>GenPollUrl</code></p> <p>A cryptocurrency ticker widget, data provided by the coinbase.com or the binance.com API. Defaults to displaying currency in whatever the current locale is. Examples:</p> <pre><code># display the average price of bitcoin in local currency\nwidget.CryptoTicker()\n\n# display it in Euros:\nwidget.CryptoTicker(currency=\"EUR\")\n\n# or a different cryptocurrency!\nwidget.CryptoTicker(crypto=\"ETH\")\n\n# change the currency symbol:\nwidget.CryptoTicker(currency=\"EUR\", symbol=\"\u20ac\")\n\n# display from Binance API\nwidget.CryptoTicker(api=\"binance\", currency=\"USDT\")\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CryptoTicker.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout","title":"CurrentLayout","text":"<pre><code>CurrentLayout(width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Display the name of the current layout of the current group of the screen, the bar containing the widget, is on.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayout.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon","title":"CurrentLayoutIcon","text":"<pre><code>CurrentLayoutIcon(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Display the icon representing the current layout of the current group of the screen on which the bar containing the widget is.</p> <p>If you are using custom layouts, a default icon with question mark will be displayed for them. If you want to use custom icon for your own layout, for example, <code>FooGrid</code>, then create a file named \"layout-foogrid.png\" and place it in <code>~/.icons</code> directory. You can as well use other directories, but then you need to specify those directories in <code>custom_icon_paths</code> argument for this plugin.</p> <p>The widget will look for icons with a <code>png</code> or <code>svg</code> extension.</p> <p>The order of icon search is:</p> <ul> <li>dirs in <code>custom_icon_paths</code> config argument</li> <li><code>~/.icons</code></li> <li>built-in qtile icons</li> </ul> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentLayoutIcon.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen","title":"CurrentScreen","text":"<pre><code>CurrentScreen(width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Indicates whether the screen this widget is on is currently active or not</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.CurrentScreen.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF","title":"DF","text":"<pre><code>DF(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Disk Free Widget</p> <p>By default the widget only displays if the space is less than warn_space.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DF.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb","title":"DoNotDisturb","text":"<pre><code>DoNotDisturb(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>Displays Do Not Disturb status for notification server Dunst by default. Can be used with other servers by changing the poll command and mouse callbacks.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.DoNotDisturb.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand","title":"GenPollCommand","text":"<pre><code>GenPollCommand(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A generic text widget to display output from scripts or shell commands</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollCommand.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText","title":"GenPollText","text":"<pre><code>GenPollText(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A generic text widget that polls using poll function to get the text</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollText.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl","title":"GenPollUrl","text":"<pre><code>GenPollUrl(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A generic text widget that polls an url and parses it using parse function</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GenPollUrl.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker","title":"GmailChecker","text":"<pre><code>GmailChecker(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A simple gmail checker. If 'status_only_unseen' is True - set 'fmt' for one argument, ex. 'unseen: {0}'</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GmailChecker.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox","title":"GroupBox","text":"<pre><code>GroupBox(**config)\n</code></pre> <p>             Bases: <code>_GroupBase</code></p> <p>A widget that graphically displays the current group. All groups are displayed by their label. If the label of a group is the empty string that group will not be displayed.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>groups</code>         \u2013          <p>returns list of visible groups.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.groups","title":"groups  <code>property</code>","text":"<pre><code>groups\n</code></pre> <p>returns list of visible groups. The existing groups are filtered by the visible_groups attribute and their label. Groups with an empty string as label are never contained. Groups that are not named in visible_groups are not returned.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.GroupBox.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD","title":"HDD","text":"<pre><code>HDD(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Displays HDD usage in percent based on the number of milliseconds the device has been performing I/O operations.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDD.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph","title":"HDDBusyGraph","text":"<pre><code>HDDBusyGraph(**config)\n</code></pre> <p>             Bases: <code>_Graph</code></p> <p>Display HDD busy time graph</p> <p>Parses /sys/block//stat file and extracts overall device IO usage, based on <code>io_ticks</code>'s value.  See https://www.kernel.org/doc/Documentation/block/stat.txt <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDBusyGraph.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph","title":"HDDGraph","text":"<pre><code>HDDGraph(**config)\n</code></pre> <p>             Bases: <code>_Graph</code></p> <p>Display HDD free or used space graph</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.HDDGraph.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG","title":"IdleRPG","text":"<pre><code>IdleRPG(**config)\n</code></pre> <p>             Bases: <code>GenPollUrl</code></p> <p>A widget for monitoring and displaying IdleRPG stats.</p> <p>::</p> <pre><code># display idlerpg stats for the player 'pants' on freenode's #idlerpg\nwidget.IdleRPG(url=\"http://xethron.lolhosting.net/xml.php?player=pants\")\n</code></pre> <p>Widget requirements: xmltodict.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.IdleRPG.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image","title":"Image","text":"<pre><code>Image(length=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_Widget</code>, <code>MarginMixin</code></p> <p>Display a PNG image on the bar</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Image.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget","title":"ImapWidget","text":"<pre><code>ImapWidget(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Email IMAP widget</p> <p>This widget will scan one of your imap email boxes and report the number of unseen messages present.  I've configured it to only work with imap with ssl. Your password is obtained from the Gnome Keyring.</p> <p>Writing your password to the keyring initially is as simple as (changing out  and  for your userid and password): <p>1) create the file ~/.local/share/python_keyring/keyringrc.cfg with the    following contents::</p> <pre><code>   [backend]\n   default-keyring=keyring.backends.Gnome.Keyring\n   keyring-path=/home/&lt;userid&gt;/.local/share/keyring/\n</code></pre> <p>2) Execute the following python shell script once::</p> <pre><code>   #!/usr/bin/env python3\n   import keyring\n   user = &lt;userid&gt;\n   password = &lt;password&gt;\n   keyring.set_password('imapwidget', user, password)\n</code></pre> <p>mbox names must include the path to the mbox (except for the default INBOX).  So, for example if your mailroot is <code>~/Maildir</code>, and you want to look at the mailbox at HomeMail/fred, the mbox setting would be: <code>mbox=\"~/Maildir/HomeMail/fred\"</code>.  Note the nested sets of quotes! Labels can be whatever you choose, of course.</p> <p>Widget requirements: keyring.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ImapWidget.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd","title":"KeyboardKbdd","text":"<pre><code>KeyboardKbdd(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Widget for changing keyboard layouts per window, using kbdd</p> <p>kbdd should be installed and running, you can get it from: https://github.com/qnikst/kbdd</p> <p>The widget also requires dbus-next.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardKbdd.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout","title":"KeyboardLayout","text":"<pre><code>KeyboardLayout(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>Widget for changing and displaying the current keyboard layout</p> <p>To use this widget effectively you need to specify keyboard layouts you want to use (using \"configured_keyboards\") and bind function \"next_keyboard\" to specific keys in order to change layouts.</p> <p>For example:</p> <pre><code>Key([mod], \"space\", lazy.widget[\"keyboardlayout\"].next_keyboard(), desc=\"Next keyboard layout.\"),\n</code></pre> <p>When running Qtile with the X11 backend, this widget requires setxkbmap to be available. Xmodmap will also be used if .Xmodmap file is available.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>next_keyboard</code>           \u2013            <p>set the next layout in the list of configured keyboard layouts as</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.next_keyboard","title":"next_keyboard","text":"<pre><code>next_keyboard()\n</code></pre> <p>set the next layout in the list of configured keyboard layouts as new current layout in use</p> <p>If the current keyboard layout is not in the list, it will set as new layout the first one in the list.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KeyboardLayout.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar","title":"KhalCalendar","text":"<pre><code>KhalCalendar(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Khal calendar widget</p> <p>This widget will display the next appointment on your Khal calendar in the qtile status bar. Appointments within the \"reminder\" time will be highlighted.</p> <p>Widget requirements: dateutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.KhalCalendar.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar","title":"LaunchBar","text":"<pre><code>LaunchBar(\n    _progs: list[tuple[str, str, str]] | None = None,\n    width=CALCULATED,\n    **config\n)\n</code></pre> <p>             Bases: <code>_Widget</code></p> <p>This module defines a widget that displays icons to launch softwares or commands when clicked -- a launchbar. Only png icon files are displayed, not xpm because cairo doesn't support loading of xpm file. The order of displaying (from left to right) is in the order of the list.</p> <p>If no icon was found for the name provided and if default_icon is set to None then the name is printed instead. If default_icon is defined then this icon is displayed instead.</p> To execute a software <ul> <li>('thunderbird', 'thunderbird -safe-mode', 'launch thunderbird in safe mode')</li> </ul> <p>To execute a python command in qtile, begin with by 'qshell:'  - ('/path/to/icon.png', 'qshell:self.qtile.shutdown()', 'logout from qtile')</p> <p>Optional requirements: pyxdg_ for finding the icon path if it is not provided in the <code>progs</code> tuple.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>button_press</code>           \u2013            <p>Launch the associated command to the clicked icon.</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Compute the width of the widget according to each icon width.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Draw the icons in the widget.</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_icon_in_position</code>           \u2013            <p>Determine which icon is clicked according to its position.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>lookup_icons</code>           \u2013            <p>Search for the icons corresponding to the commands to execute.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>setup_images</code>           \u2013            <p>Create image structures for each icon files.</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.button_press","title":"button_press","text":"<pre><code>button_press(x, y, button)\n</code></pre> <p>Launch the associated command to the clicked icon.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Compute the width of the widget according to each icon width.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Draw the icons in the widget.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.get_icon_in_position","title":"get_icon_in_position","text":"<pre><code>get_icon_in_position(x, y)\n</code></pre> <p>Determine which icon is clicked according to its position.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.lookup_icons","title":"lookup_icons","text":"<pre><code>lookup_icons()\n</code></pre> <p>Search for the icons corresponding to the commands to execute.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.setup_images","title":"setup_images","text":"<pre><code>setup_images()\n</code></pre> <p>Create image structures for each icon files.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.LaunchBar.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load","title":"Load","text":"<pre><code>Load(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A small widget to show the load averages of the system. Depends on psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Load.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir","title":"Maildir","text":"<pre><code>Maildir(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A simple widget showing the number of new mails in maildir mailboxes</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>format_text</code>           \u2013            <p>Converts the state of the subfolders to a string</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>poll</code>           \u2013            <p>Scans the mailbox for new messages</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.format_text","title":"format_text","text":"<pre><code>format_text(state: dict[str, int]) -&gt; str\n</code></pre> <p>Converts the state of the subfolders to a string</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.format_text--parameters","title":"Parameters","text":"<p>state: dict[str, int]     a dictionary mapping subfolder labels to new mail values</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.format_text--returns","title":"Returns","text":"<p>a string representation of the given state</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.poll","title":"poll","text":"<pre><code>poll()\n</code></pre> <p>Scans the mailbox for new messages</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.poll--returns","title":"Returns","text":"<p>A string representing the current mailbox state</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Maildir.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory","title":"Memory","text":"<pre><code>Memory(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Display memory/swap usage.</p> <p>The following fields are available in the <code>format</code> string:</p> <ul> <li><code>MemUsed</code>: Memory in use.</li> <li><code>MemTotal</code>: Total amount of memory.</li> <li><code>MemFree</code>: Amount of memory free.</li> <li><code>Available</code>: Amount of memory available.</li> <li><code>MemPercent</code>: Memory in use as a percentage.</li> <li><code>Buffers</code>: Buffer amount.</li> <li><code>Active</code>: Active memory.</li> <li><code>Inactive</code>: Inactive memory.</li> <li><code>Shmem</code>: Shared memory.</li> <li><code>SwapTotal</code>: Total amount of swap.</li> <li><code>SwapFree</code>: Amount of swap free.</li> <li><code>SwapUsed</code>: Amount of swap in use.</li> <li><code>SwapPercent</code>: Swap in use as a percentage.</li> <li><code>mm</code>: Measure unit for memory.</li> <li><code>ms</code>: Measure unit for swap.</li> </ul> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Memory.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph","title":"MemoryGraph","text":"<pre><code>MemoryGraph(**config)\n</code></pre> <p>             Bases: <code>_Graph</code></p> <p>Displays a memory usage graph.</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.MemoryGraph.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror","title":"Mirror","text":"<pre><code>Mirror(reflection, **config)\n</code></pre> <p>             Bases: <code>_Widget</code></p> <p>A widget for showing the same widget content in more than one place, for instance, on bars across multiple screens.</p> <p>You don't need to use it directly; instead, just instantiate your widget once and hand it in to multiple bars. For instance::</p> <pre><code>cpu = widget.CPUGraph()\nclock = widget.Clock()\n\nscreens = [\n    Screen(top=bar.Bar([widget.GroupBox(), cpu, clock])),\n    Screen(top=bar.Bar([widget.GroupBox(), cpu, clock])),\n]\n</code></pre> <p>Widgets can be passed to more than one bar, so that there don't need to be any duplicates executing the same code all the time, and they'll always be visually identical.</p> <p>This works for all widgets that use <code>drawers</code> (and nothing else) to display their contents. Currently, this is all widgets except for <code>Systray</code>.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mirror.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc","title":"Moc","text":"<pre><code>Moc(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>A simple MOC widget.</p> <p>Show the artist and album of now listening song and allow basic mouse control from the bar:</p> <ul> <li>toggle pause (or play if stopped) on left click;</li> <li>skip forward in playlist on scroll up;</li> <li>skip backward in playlist on scroll down.</li> </ul> <p>MOC (http://moc.daper.net) should be installed.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_info</code>           \u2013            <p>Return a dictionary with info about the current MOC status.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>now_playing</code>           \u2013            <p>Return a string with the now playing info (Artist - Song Title).</p> </li> <li> <code>play</code>           \u2013            <p>Play music if stopped, else toggle pause.</p> </li> <li> <code>poll</code>           \u2013            <p>Poll content for the text box.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.get_info","title":"get_info","text":"<pre><code>get_info()\n</code></pre> <p>Return a dictionary with info about the current MOC status.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.now_playing","title":"now_playing","text":"<pre><code>now_playing()\n</code></pre> <p>Return a string with the now playing info (Artist - Song Title).</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.play","title":"play","text":"<pre><code>play()\n</code></pre> <p>Play music if stopped, else toggle pause.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.poll","title":"poll","text":"<pre><code>poll()\n</code></pre> <p>Poll content for the text box.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Moc.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2","title":"Mpd2","text":"<pre><code>Mpd2(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Mpd2 Object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2--parameters","title":"Parameters","text":"<p>status_format:     format string to display status</p> <pre><code>For a full list of values, see:\n    MPDClient.status() and MPDClient.currentsong()\n\nhttps://musicpd.org/doc/protocol/command_reference.html#command_status\nhttps://musicpd.org/doc/protocol/tags.html\n\nDefault::\n\n    '{play_status} {artist}/{title} \\\n        [{repeat}{random}{single}{consume}{updating_db}]'\n\n    ``play_status`` is a string from ``play_states`` dict\n\n    Note that the ``time`` property of the song renamed to ``fulltime``\n    to prevent conflicts with status information during formating.\n</code></pre> idle_format <p>format string to display status when no song is in queue.</p> <p>Default::</p> <pre><code>'{play_status} {idle_message} \\\n    [{repeat}{random}{single}{consume}{updating_db}]'\n\nNote that the ``artist`` key fallbacks to similar keys in specific order.\n(``artist`` -&gt; ``albumartist`` -&gt; ``performer`` -&gt;\n -&gt; ``composer`` -&gt; ``conductor`` -&gt; ``ensemble``)\n</code></pre> idle_message <p>text to display instead of song information when MPD is idle. (i.e. no song in queue)</p> <p>Default:: \"MPD IDLE\"</p> undefined_value <p>text to display when status key is undefined</p> <p>Default:: \"Undefined\"</p> prepare_status <p>dict of functions to replace values in status with custom characters.</p> <p><code>f(status, key, space_element) =&gt; str</code></p> <p>New functionality allows use of a dictionary of plain strings.</p> <p>Default::</p> <pre><code>status_dict = {\n    'repeat': 'r',\n    'random': 'z',\n    'single': '1',\n    'consume': 'c',\n    'updating_db': 'U'\n}\n</code></pre> format_fns <p>A dict of functions to format the various elements.</p> <p>'Tag': f(str) =&gt; str</p> <p>Default:: { 'all': lambda s: cgi.escape(s) }</p> <p>N.B. if 'all' is present, it is processed on every element of song_info     before any other formatting is done.</p> mouse_buttons <p>A dict of mouse button numbers to actions</p> <p>Widget requirements: python-mpd2.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>button_press</code>           \u2013            <p>handle click event on widget.</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>finalize</code>           \u2013            <p>finalize.</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>formatter</code>           \u2013            <p>format song info.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>poll</code>           \u2013            <p>Called by qtile manager.</p> </li> <li> <code>prepare_formatting</code>           \u2013            <p>old way of preparing status formatting.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>toggle</code>           \u2013            <p>toggle play/pause.</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> <li> <code>update_status</code>           \u2013            <p>get updated info from mpd server and call format.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>connected</code>         \u2013          <p>Attempt connection to mpd server.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.connected","title":"connected  <code>property</code>","text":"<pre><code>connected\n</code></pre> <p>Attempt connection to mpd server.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.button_press","title":"button_press","text":"<pre><code>button_press(x, y, button)\n</code></pre> <p>handle click event on widget.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.finalize","title":"finalize","text":"<pre><code>finalize()\n</code></pre> <p>finalize.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.formatter","title":"formatter","text":"<pre><code>formatter(status, current_song)\n</code></pre> <p>format song info.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.poll","title":"poll","text":"<pre><code>poll()\n</code></pre> <p>Called by qtile manager.</p> <p>poll the mpd server and update widget.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.prepare_formatting","title":"prepare_formatting","text":"<pre><code>prepare_formatting(status)\n</code></pre> <p>old way of preparing status formatting.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.toggle","title":"toggle","text":"<pre><code>toggle()\n</code></pre> <p>toggle play/pause.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpd2.update_status","title":"update_status","text":"<pre><code>update_status()\n</code></pre> <p>get updated info from mpd server and call format.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2","title":"Mpris2","text":"<pre><code>Mpris2(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>An MPRIS 2 widget</p> <p>A widget which displays the current track/artist of your favorite MPRIS player. This widget scrolls the text if neccessary and information that is displayed is configurable.</p> <p>The widget relies on players broadcasting signals when the metadata or playback status changes. If you are getting inconsistent results then you can enable background polling of the player by setting the <code>poll_interval</code> parameter. This is disabled by default.</p> <p>Basic mouse controls are also available: button 1 = play/pause, scroll up = next track, scroll down = previous track.</p> <p>Widget requirements: dbus-next.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>What's the current state of the widget?</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>next</code>           \u2013            <p>Play the next track.</p> </li> <li> <code>parse_message</code>           \u2013            <p>http://specifications.freedesktop.org/mpris-spec/latest/Track_List_Interface.html#Mapping:Metadata_Map</p> </li> <li> <code>play_pause</code>           \u2013            <p>Toggle the playback status.</p> </li> <li> <code>previous</code>           \u2013            <p>Play the previous track.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>stop</code>           \u2013            <p>Stop playback.</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>What's the current state of the widget?</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.next","title":"next","text":"<pre><code>next() -&gt; None\n</code></pre> <p>Play the next track.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.parse_message","title":"parse_message","text":"<pre><code>parse_message(\n    _interface_name: str,\n    changed_properties: dict[str, Any],\n    _invalidated_properties: list[str],\n) -&gt; None\n</code></pre> <p>http://specifications.freedesktop.org/mpris-spec/latest/Track_List_Interface.html#Mapping:Metadata_Map</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.play_pause","title":"play_pause","text":"<pre><code>play_pause() -&gt; None\n</code></pre> <p>Toggle the playback status.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.previous","title":"previous","text":"<pre><code>previous() -&gt; None\n</code></pre> <p>Play the previous track.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop playback.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Mpris2.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net","title":"Net","text":"<pre><code>Net(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Displays interface down and up speed</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>convert_b</code>           \u2013            <p>Converts the number of bytes to the correct unit</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.convert_b","title":"convert_b","text":"<pre><code>convert_b(num_bytes: float) -&gt; tuple[float, str]\n</code></pre> <p>Converts the number of bytes to the correct unit</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Net.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph","title":"NetGraph","text":"<pre><code>NetGraph(**config)\n</code></pre> <p>             Bases: <code>_Graph</code></p> <p>Display a network usage graph.</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NetGraph.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify","title":"Notify","text":"<pre><code>Notify(width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>A notify widget</p> <p>This widget can handle actions provided by notification clients. However, only the default action is supported, so if a client provides multiple actions then only the default (first) action can be invoked. Some programs will provide their own notification windows if the notification server does not support actions, so if you want your notifications to handle more than one action then specify <code>False</code> for the <code>action</code> option to disable all action handling. Unfortunately we cannot specify the capability for exactly one action.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>clear</code>           \u2013            <p>Clear the notification</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>invoke</code>           \u2013            <p>Invoke the notification's default action</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>prev</code>           \u2013            <p>Show previous notification.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>toggle</code>           \u2013            <p>Toggle showing/clearing the notification</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.clear","title":"clear","text":"<pre><code>clear(reason=dismissed)\n</code></pre> <p>Clear the notification</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.invoke","title":"invoke","text":"<pre><code>invoke()\n</code></pre> <p>Invoke the notification's default action</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.prev","title":"prev","text":"<pre><code>prev()\n</code></pre> <p>Show previous notification.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.toggle","title":"toggle","text":"<pre><code>toggle()\n</code></pre> <p>Toggle showing/clearing the notification</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Notify.update","title":"update","text":"<pre><code>update(notif)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors","title":"NvidiaSensors","text":"<pre><code>NvidiaSensors(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Displays temperature, fan speed and performance level Nvidia GPU.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.NvidiaSensors.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather","title":"OpenWeather","text":"<pre><code>OpenWeather(**config)\n</code></pre> <p>             Bases: <code>GenPollUrl</code></p> <p>A weather widget, data provided by the OpenWeather API.</p> Some format options <ul> <li>location_city</li> <li>location_cityid</li> <li>location_country</li> <li>location_lat</li> <li> <p>location_long</p> </li> <li> <p>weather</p> </li> <li>weather_details</li> <li>units_temperature</li> <li>units_wind_speed</li> <li>isotime</li> <li>humidity</li> <li>pressure</li> <li>sunrise</li> <li>sunset</li> <li>temp</li> <li>visibility</li> <li>wind_speed</li> <li>wind_deg</li> <li> <p>wind_direction</p> </li> <li> <p>main_feels_like</p> </li> <li>main_temp_min</li> <li>main_temp_max</li> <li>clouds_all</li> <li>icon</li> </ul> <p>Icon support is available but you will need a suitable font installed. A default icon mapping is provided (<code>OpenWeather.symbols</code>) but changes can be made by setting <code>weather_symbols</code>. Available icon codes can be viewed here: https://openweathermap.org/weather-conditions#Icon-list</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.OpenWeather.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro","title":"Pomodoro","text":"<pre><code>Pomodoro(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Pomodoro technique widget</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Pomodoro.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt","title":"Prompt","text":"<pre><code>Prompt(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>A widget that prompts for user input</p> <p>Input should be started using the <code>.start_input()</code> method on this class.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>exec_general</code>           \u2013            <p>Execute a cmd of any object. For example layout, group, window, widget</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Returns a dictionary of info for this object</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>process_key_press</code>           \u2013            <p>Key press handler for the minibuffer.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>start_input</code>           \u2013            <p>Run the prompt</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length() -&gt; int\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.exec_general","title":"exec_general","text":"<pre><code>exec_general(\n    prompt,\n    object_name,\n    cmd_name,\n    selector=None,\n    completer=None,\n)\n</code></pre> <p>Execute a cmd of any object. For example layout, group, window, widget , etc with a string that is obtained from start_input.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.exec_general--parameters","title":"Parameters","text":"<p>prompt :     Text displayed at the prompt. object_name :     Name of a object in Qtile. This string has to be 'layout', 'widget',     'bar', 'window' or 'screen'. cmd_name :     Execution command of selected object using object_name and selector. selector :     This value select a specific object within a object list that is     obtained by object_name.     If this value is None, current object is selected. e.g. current layout,     current window and current screen. completer:     Completer to use.</p> config example <p>Key([alt, 'shift'], 'a',     lazy.widget['prompt'].exec_general(         'section(add)',         'layout',         'add_section'))</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Returns a dictionary of info for this object</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.process_key_press","title":"process_key_press","text":"<pre><code>process_key_press(keysym: int)\n</code></pre> <p>Key press handler for the minibuffer.</p> <p>Currently only supports ASCII characters.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.start_input","title":"start_input","text":"<pre><code>start_input(\n    prompt,\n    callback,\n    complete=None,\n    strict_completer=False,\n    allow_empty_input=False,\n    aliases: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>Run the prompt</p> <p>Displays a prompt and starts to take one line of keyboard input from the user. When done, calls the callback with the input string as argument. If history record is enabled, also allows to browse between previous commands with \u2191 and \u2193, and execute them (untouched or modified). When history is exhausted, fires an alert. It tries to mimic, in some way, the shell behavior.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.start_input--parameters","title":"Parameters","text":"<p>complete :     Tab-completion. Can be None, \"cmd\", \"file\", \"group\", \"qshell\" or     \"window\". prompt :     text displayed at the prompt, e.g. \"spawn: \" callback :     function to call with returned value. complete :     completer to use. strict_completer :     When True the return value wil be the exact completer result where     available. allow_empty_input :     When True, an empty value will still call the callback function aliases :     Dictionary mapping aliases to commands. If the entered command is a key in     this dict, the command it maps to will be executed instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Prompt.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume","title":"PulseVolume","text":"<pre><code>PulseVolume(**config)\n</code></pre> <p>             Bases: <code>Volume</code></p> <p>Volume widget for systems using PulseAudio.</p> <p>The widget connects to the PulseAudio server by using the libpulse library and so should be updated virtually instantly rather than needing to poll the volume status regularly (NB this means that the <code>update_interval</code> parameter serves no purpose for this widget).</p> <p>The widget relies on the pulsectl_asyncio_ library to access the libpulse bindings. If you are using python 3.11 you must use <code>pulsectl_asyncio &gt;= 1.0.0</code>.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>decrease_vol</code>           \u2013            <p>Decrease volume.</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>increase_vol</code>           \u2013            <p>Increase volume.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>mute</code>           \u2013            <p>Mute the sound device.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>same method as in Volume widgets except that here we don't need to</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.decrease_vol","title":"decrease_vol","text":"<pre><code>decrease_vol(value=None)\n</code></pre> <p>Decrease volume.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.increase_vol","title":"increase_vol","text":"<pre><code>increase_vol(value=None)\n</code></pre> <p>Increase volume.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.mute","title":"mute","text":"<pre><code>mute()\n</code></pre> <p>Mute the sound device.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.PulseVolume.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>same method as in Volume widgets except that here we don't need to manually re-schedule update</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit","title":"QuickExit","text":"<pre><code>QuickExit(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>A button to shut down Qtile. When clicked, a countdown starts. Clicking the button again stops the countdown and prevents Qtile from shutting down.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.QuickExit.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit","title":"ScreenSplit","text":"<pre><code>ScreenSplit(**config)\n</code></pre> <p>             Bases: <code>TextBox</code></p> <p>A simple widget to show the name of the current split and layout for the <code>ScreenSplit</code> layout.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Retrieve the text in a TextBox widget</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.get","title":"get","text":"<pre><code>get()\n</code></pre> <p>Retrieve the text in a TextBox widget</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ScreenSplit.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep","title":"Sep","text":"<pre><code>Sep(**config)\n</code></pre> <p>             Bases: <code>_Widget</code></p> <p>A visible widget separator</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Sep.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She","title":"She","text":"<pre><code>She(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>Widget to display the Super Hybrid Engine status</p> <p>Can display either the mode or CPU speed on eeepc computers.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.She.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.She.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.She.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer","title":"Spacer","text":"<pre><code>Spacer(length=STRETCH, **config)\n</code></pre> <p>             Bases: <code>_Widget</code></p> <p>Just an empty space on the bar</p> <p>Often used with length equal to bar.STRETCH to push bar widgets to the right or bottom edge of the screen.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer--parameters","title":"Parameters","text":"<p>length :     Length of the widget.  Can be either <code>bar.STRETCH</code> or a length in     pixels. width :     DEPRECATED, same as <code>length</code>.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Spacer.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier","title":"StatusNotifier","text":"<pre><code>StatusNotifier(**config)\n</code></pre> <p>             Bases: <code>_Widget</code></p> <p>A 'system tray' widget using the freedesktop StatusNotifierItem specification.</p> <p>As per the specification, app icons are first retrieved from the user's current theme. If this is not available then the app may provide its own icon. In order to use this functionality, users are recommended to install the pyxdg module to support retrieving icons from the selected theme. If the icon specified by StatusNotifierItem can not be found in the user's current theme and no other icons are provided by the app, a fallback icon is used.</p> <p>Left-clicking an icon will trigger an activate event.</p> <p>Note</p> <p> Context menus are not currently supported by the official widget. However, a modded version of the widget which provides basic menu support is available from elParaguayo's qtile-extras repo.</p> <p>Methods:</p> <ul> <li> <code>activate</code>           \u2013            <p>Primary action when clicking on an icon</p> </li> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>find_icon_at_pos</code>           \u2013            <p>returns StatusNotifierItem object for icon in given position</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.activate","title":"activate","text":"<pre><code>activate()\n</code></pre> <p>Primary action when clicking on an icon</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.find_icon_at_pos","title":"find_icon_at_pos","text":"<pre><code>find_icon_at_pos(x, y)\n</code></pre> <p>returns StatusNotifierItem object for icon in given position</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StatusNotifier.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker","title":"StockTicker","text":"<pre><code>StockTicker(**config)\n</code></pre> <p>             Bases: <code>GenPollUrl</code></p> <p>A stock ticker widget, based on the alphavantage API. Users must acquire an API key from https://www.alphavantage.co/support/#api-key</p> <p>The widget defaults to the TIME_SERIES_INTRADAY API function (i.e. stock symbols), but arbitrary Alpha Vantage API queries can be made by passing extra arguments to the constructor.</p> <p>::</p> <pre><code># Display AMZN\nwidget.StockTicker(apikey=..., symbol=\"AMZN\")\n\n# Display BTC\nwidget.StockTicker(\n    apikey=..., function=\"DIGITAL_CURRENCY_INTRADAY\", symbol=\"BTC\", market=\"USD\"\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.StockTicker.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph","title":"SwapGraph","text":"<pre><code>SwapGraph(**config)\n</code></pre> <p>             Bases: <code>_Graph</code></p> <p>Display a swap info graph.</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.SwapGraph.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray","title":"Systray","text":"<pre><code>Systray(**config)\n</code></pre> <p>             Bases: <code>_Widget</code>, <code>_Window</code></p> <p>A widget that manages system tray.</p> <p>Only one Systray widget is allowed. Adding additional Systray widgets will result in a ConfigError.</p> <p>Note</p> <p> Icons will not render correctly where the bar/widget is drawn with a semi-transparent background. Instead, icons will be drawn with a transparent background.</p> <p>If using this widget it is therefore recommended to use a fully opaque background colour or a fully transparent one.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>change_layer</code>           \u2013            <p>Raise a window above its peers or move it below them, depending on 'up'.</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>create_mirror</code>           \u2013            <p>Systray cannot be mirrored as we do not use a Drawer object to render icons.</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>focus</code>           \u2013            <p>Focuses the window.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_hints</code>           \u2013            <p>Returns the X11 hints (WM_HINTS and WM_SIZE_HINTS) for this window.</p> </li> <li> <code>get_layering_information</code>           \u2013            <p>Get layer-related EMWH-flags</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>inspect</code>           \u2013            <p>Tells you more than you ever wanted to know about a window</p> </li> <li> <code>is_transient_for</code>           \u2013            <p>What window is this window a transient windor for?</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>place</code>           \u2013            <p>Places the window at the specified location with the given size.</p> </li> <li> <code>raise_children</code>           \u2013            <p>Ensure any transient windows are moved up with the parent.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>send_configure_notify</code>           \u2013            <p>Send a synthetic ConfigureNotify</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update_hints</code>           \u2013            <p>Update the local copy of the window's WM_HINTS</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.change_layer","title":"change_layer","text":"<pre><code>change_layer(up=True, top_bottom=False)\n</code></pre> <p>Raise a window above its peers or move it below them, depending on 'up'. Raising a normal window will not lift it above pinned windows etc.</p> <p>There are a few important things to take note of when relaying windows: 1. If a window has a defined parent, it should not be moved underneath it.    In case children are blocking, this could leave an application in an unusable state. 2. If a window has children, they should be moved along with it. 3. If a window has a defined parent, either move the parent or do nothing at all. 4. EMWH-flags follow strict layering rules:    https://specifications.freedesktop.org/wm-spec/1.3/ar01s07.html#STACKINGORDER</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.create_mirror","title":"create_mirror","text":"<pre><code>create_mirror()\n</code></pre> <p>Systray cannot be mirrored as we do not use a Drawer object to render icons.</p> <p>Return new, unconfigured instance so that, when the bar tries to configure it again, a ConfigError is raised.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.focus","title":"focus","text":"<pre><code>focus(warp: bool = True) -&gt; None\n</code></pre> <p>Focuses the window.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.get_hints","title":"get_hints","text":"<pre><code>get_hints()\n</code></pre> <p>Returns the X11 hints (WM_HINTS and WM_SIZE_HINTS) for this window.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.get_layering_information","title":"get_layering_information","text":"<pre><code>get_layering_information() -&gt; (\n    tuple[bool, bool, bool, bool, bool, bool]\n)\n</code></pre> <p>Get layer-related EMWH-flags https://specifications.freedesktop.org/wm-spec/1.3/ar01s07.html#STACKINGORDER</p> <p>Copied here:</p> <p>To obtain good interoperability between different Desktop Environments,  the following layered stacking order is recommended, from the bottom:</p> <pre><code>- windows of type _NET_WM_TYPE_DESKTOP\n- windows having state _NET_WM_STATE_BELOW\n- windows not belonging in any other layer\n- windows of type _NET_WM_TYPE_DOCK (unless they have state\n  _NET_WM_TYPE_BELOW) and windows having state _NET_WM_STATE_ABOVE\n- focused windows having state _NET_WM_STATE_FULLSCREEN\n</code></pre> <p>Windows that are transient for another window should be kept above this window.</p> <p>The window manager may choose to put some windows in different stacking positions, for example to allow the user to bring currently a active window to the top and return it back when the window loses focus. To this end, qtile adds an additional layer so that scratchpad windows are placed above all others, always.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.inspect","title":"inspect","text":"<pre><code>inspect()\n</code></pre> <p>Tells you more than you ever wanted to know about a window</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.is_transient_for","title":"is_transient_for","text":"<pre><code>is_transient_for()\n</code></pre> <p>What window is this window a transient windor for?</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.place","title":"place","text":"<pre><code>place(\n    x,\n    y,\n    width,\n    height,\n    borderwidth,\n    bordercolor,\n    above=False,\n    margin=None,\n    respect_hints=False,\n)\n</code></pre> <p>Places the window at the specified location with the given size.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.place--parameters","title":"Parameters","text":"<p>x: int y: int width: int height: int borderwidth: int bordercolor: string above: bool, optional margin: int or list, optional     space around window as int or list of ints [N E S W] above: bool, optional     If True, the geometry will be adjusted to respect hints provided by the     client.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.raise_children","title":"raise_children","text":"<pre><code>raise_children(stack=None)\n</code></pre> <p>Ensure any transient windows are moved up with the parent.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.send_configure_notify","title":"send_configure_notify","text":"<pre><code>send_configure_notify(x, y, width, height)\n</code></pre> <p>Send a synthetic ConfigureNotify</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Systray.update_hints","title":"update_hints","text":"<pre><code>update_hints()\n</code></pre> <p>Update the local copy of the window's WM_HINTS</p> <p>See http://tronche.com/gui/x/icccm/sec-4.html#WM_HINTS</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList","title":"TaskList","text":"<pre><code>TaskList(**config)\n</code></pre> <p>             Bases: <code>_Widget</code>, <code>PaddingMixin</code>, <code>MarginMixin</code></p> <p>Displays the icon and name of each window in the current group</p> <p>Contrary to WindowTabs this is an interactive widget.  The window that currently has focus is highlighted.</p> <p>Optional requirements: pyxdg_ is needed to use theme icons and to display icons on Wayland.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>box_width</code>           \u2013            <p>calculate box width for given text.</p> </li> <li> <code>calc_box_widths</code>           \u2013            <p>Calculate box width for each window in current group.</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_taskname</code>           \u2013            <p>Get display name for given window.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.box_width","title":"box_width","text":"<pre><code>box_width(text)\n</code></pre> <p>calculate box width for given text. If max_title_width is given, the returned width is limited to it.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.calc_box_widths","title":"calc_box_widths","text":"<pre><code>calc_box_widths()\n</code></pre> <p>Calculate box width for each window in current group. If the available space is less than overall size of boxes, the boxes are shrunk by percentage if greater than average.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.get_taskname","title":"get_taskname","text":"<pre><code>get_taskname(window)\n</code></pre> <p>Get display name for given window. Depending on its state minimized, maximized and floating appropriate characters are prepended.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TaskList.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox","title":"TextBox","text":"<pre><code>TextBox(text=' ', width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>A flexible textbox that can be updated from bound keys, scripts, and qshell.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Retrieve the text in a TextBox widget</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.get","title":"get","text":"<pre><code>get()\n</code></pre> <p>Retrieve the text in a TextBox widget</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.TextBox.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor","title":"ThermalSensor","text":"<pre><code>ThermalSensor(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>Widget to display temperature sensor information</p> <p>For using the thermal sensor widget you need to have lm-sensors installed. You can get a list of the tag_sensors executing \"sensors\" in your terminal. Then you can choose which you want, otherwise it will display the first available.</p> <p>Widget requirements: psutil.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>get_temp_sensors</code>           \u2013            <p>Reads temperatures from sys-fs via psutil.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.get_temp_sensors","title":"get_temp_sensors","text":"<pre><code>get_temp_sensors()\n</code></pre> <p>Reads temperatures from sys-fs via psutil. Output will be read Fahrenheit if user has specified it to be.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalSensor.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone","title":"ThermalZone","text":"<pre><code>ThermalZone(**config)\n</code></pre> <p>             Bases: <code>ThreadPoolText</code></p> <p>Thermal zone widget.</p> <p>This widget was made to read thermal zone files and transform values to human readable format. You can set zone parameter to any standard thermal zone file from /sys/class/thermal directory.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.ThermalZone.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume","title":"Volume","text":"<pre><code>Volume(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Widget that display and change volume</p> <p>By default, this widget uses <code>amixer</code> to get and set the volume so users will need to make sure this is installed. Alternatively, users may set the relevant parameters for the widget to use a different application.</p> <p>If theme_path is set it draw widget as icons.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Volume.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper","title":"Wallpaper","text":"<pre><code>Wallpaper(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wallpaper.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox","title":"WidgetBox","text":"<pre><code>WidgetBox(_widgets: list[_Widget] | None = None, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>A widget to declutter your bar.</p> <p>WidgetBox is a widget that hides widgets by default but shows them when the box is opened.</p> <p>Widgets that are hidden will still update etc. as if they were on the main bar.</p> <p>Button clicks are passed to widgets when they are visible so callbacks will work.</p> <p>Widgets in the box also remain accessible via command interfaces.</p> <p>Widgets can only be added to the box via the configuration file. The widget is configured by adding widgets to the \"widgets\" parameter as follows::</p> <pre><code>widget.WidgetBox(widgets=[\n    widget.TextBox(text=\"This widget is in the box\"),\n    widget.Memory()\n    ]\n),\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>close</code>           \u2013            <p>Close the widgetbox.</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>open</code>           \u2013            <p>Open the widgetbox.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>toggle</code>           \u2013            <p>Toggle box state</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the widgetbox.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Open the widgetbox.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.toggle","title":"toggle","text":"<pre><code>toggle()\n</code></pre> <p>Toggle box state</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WidgetBox.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount","title":"WindowCount","text":"<pre><code>WindowCount(width=CALCULATED, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>A simple widget to display the number of windows in the current group of the screen on which the widget is.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Retrieve the current text.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.get","title":"get","text":"<pre><code>get()\n</code></pre> <p>Retrieve the current text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowCount.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName","title":"WindowName","text":"<pre><code>WindowName(width=STRETCH, **config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Displays the name of the window that currently has focus</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowName.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs","title":"WindowTabs","text":"<pre><code>WindowTabs(**config)\n</code></pre> <p>             Bases: <code>_TextBox</code></p> <p>Displays the name of each window in the current group. Contrary to TaskList this is not an interactive widget. The window that currently has focus is highlighted.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.WindowTabs.update","title":"update","text":"<pre><code>update(*args)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan","title":"Wlan","text":"<pre><code>Wlan(**config)\n</code></pre> <p>             Bases: <code>InLoopPollText</code></p> <p>Displays Wifi SSID and quality.</p> <p>Widget requirements: iwlib.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wlan.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr","title":"Wttr","text":"<pre><code>Wttr(**config)\n</code></pre> <p>             Bases: <code>GenPollUrl</code></p> <p>Display weather widget provided by wttr.in.</p> <p>To specify your own custom output format, use the special %-notation (example: 'My_city: %t(%f), wind: %w'):</p> <ul> <li>%c    Weather condition,</li> <li>%C    Weather condition textual name,</li> <li>%h    Humidity,</li> <li>%t    Temperature (Actual),</li> <li>%f    Temperature (Feels Like),</li> <li>%w    Wind,</li> <li>%l    Location,</li> <li>%m    Moonphase \ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18,</li> <li>%M    Moonday,</li> <li>%p    precipitation (mm),</li> <li>%P    pressure (hPa),</li> <li>%D    Dawn !,</li> <li>%S    Sunrise !,</li> <li>%z    Zenith !,</li> <li>%s    Sunset !,</li> <li>%d    Dusk !. (!times are shown in the local timezone)</li> </ul> <p>Add the character <code>~</code> at the beginning to get weather for some special location: <code>~Vostok Station</code> or <code>~Eiffel Tower</code>.</p> <p>Also can use IP-addresses (direct) or domain names (prefixed with @) to specify a location: <code>@github.com</code>, <code>123.456.678.123</code></p> <p>Specify multiple locations as dictionary:</p> <pre><code>location={\n    'Minsk': 'Minsk',\n    '64.127146,-21.873472': 'Reykjavik',\n}\n</code></pre> <p>Cities will change randomly every update.</p> <p>Methods:</p> <ul> <li> <code>add_callbacks</code>           \u2013            <p>Add default callbacks with a lower priority than user-specified callbacks.</p> </li> <li> <code>add_defaults</code>           \u2013            <p>Add defaults to this object, overwriting any which already exist</p> </li> <li> <code>calculate_length</code>           \u2013            <p>Must be implemented if the widget can take CALCULATED for length.</p> </li> <li> <code>call_process</code>           \u2013            <p>This method uses <code>subprocess.check_output</code> to run the given command</p> </li> <li> <code>check_width</code>           \u2013            <p>Check whether the widget needs to have calculated or fixed width</p> </li> <li> <code>command</code>           \u2013            <p>Return the command with the given name</p> </li> <li> <code>commands</code>           \u2013            <p>Returns a list of possible commands for this object</p> </li> <li> <code>doc</code>           \u2013            <p>Returns the documentation for a specified command name</p> </li> <li> <code>draw</code>           \u2013            <p>Method that draws the widget. You may call this explicitly to</p> </li> <li> <code>eval</code>           \u2013            <p>Evaluates code in the same context as this function</p> </li> <li> <code>force_update</code>           \u2013            <p>Immediately poll the widget. Existing timers are unaffected.</p> </li> <li> <code>function</code>           \u2013            <p>Call a function with current object as argument</p> </li> <li> <code>get</code>           \u2013            <p>Utility function for quick retrieval of a widget by name.</p> </li> <li> <code>info</code>           \u2013            <p>Info for this object.</p> </li> <li> <code>items</code>           \u2013            <p>Build a list of contained items for the given item class.</p> </li> <li> <code>select</code>           \u2013            <p>Return a selected object</p> </li> <li> <code>set_font</code>           \u2013            <p>Change the font used by this widget. If font is None, the current</p> </li> <li> <code>timeout_add</code>           \u2013            <p>This method calls <code>.call_later</code> with given arguments.</p> </li> <li> <code>timer_setup</code>           \u2013            <p>This is called exactly once, after the widget has been configured</p> </li> <li> <code>update</code>           \u2013            <p>Update the widget text.</p> </li> </ul>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.add_callbacks","title":"add_callbacks","text":"<pre><code>add_callbacks(defaults)\n</code></pre> <p>Add default callbacks with a lower priority than user-specified callbacks.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.add_defaults","title":"add_defaults","text":"<pre><code>add_defaults(defaults)\n</code></pre> <p>Add defaults to this object, overwriting any which already exist</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.calculate_length","title":"calculate_length","text":"<pre><code>calculate_length()\n</code></pre> <p>Must be implemented if the widget can take CALCULATED for length. It must return the width of the widget if it's installed in a horizontal bar; it must return the height of the widget if it's installed in a vertical bar. Usually you will test the orientation of the bar with 'self.bar.horizontal'.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.call_process","title":"call_process","text":"<pre><code>call_process(command, **kwargs)\n</code></pre> <p>This method uses <code>subprocess.check_output</code> to run the given command and return the string from stdout, which is decoded when using Python 3.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.check_width","title":"check_width","text":"<pre><code>check_width()\n</code></pre> <p>Check whether the widget needs to have calculated or fixed width and whether the text should be scrolled.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.command","title":"command","text":"<pre><code>command(name: str) -&gt; Callable | None\n</code></pre> <p>Return the command with the given name</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.command--parameters","title":"Parameters","text":"<p>name: str     The name of the command to fetch.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.commands","title":"commands","text":"<pre><code>commands() -&gt; list[str]\n</code></pre> <p>Returns a list of possible commands for this object</p> <p>Used by qsh for command completion and online help</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.doc","title":"doc","text":"<pre><code>doc(name) -&gt; str\n</code></pre> <p>Returns the documentation for a specified command name</p> <p>Used by qsh to provide online help.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.draw","title":"draw","text":"<pre><code>draw()\n</code></pre> <p>Method that draws the widget. You may call this explicitly to redraw the widget, but only if the length of the widget hasn't changed. If it has, you must call bar.draw instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.eval","title":"eval","text":"<pre><code>eval(code: str) -&gt; tuple[bool, str | None]\n</code></pre> <p>Evaluates code in the same context as this function</p> <p>Return value is tuple <code>(success, result)</code>, success being a boolean and result being a string representing the return value of eval, or None if exec was used instead.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.force_update","title":"force_update","text":"<pre><code>force_update()\n</code></pre> <p>Immediately poll the widget. Existing timers are unaffected.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.function","title":"function","text":"<pre><code>function(function, *args, **kwargs) -&gt; None\n</code></pre> <p>Call a function with current object as argument</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.get","title":"get","text":"<pre><code>get(q, name)\n</code></pre> <p>Utility function for quick retrieval of a widget by name.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Info for this object.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.items","title":"items","text":"<pre><code>items(name: str) -&gt; tuple[bool, list[str | int] | None]\n</code></pre> <p>Build a list of contained items for the given item class.</p> <p>Exposing this allows qsh to navigate the command graph.</p> <p>Returns a tuple <code>(root, items)</code> for the specified item class, where:</p> <pre><code>root: True if this class accepts a \"naked\" specification without an\nitem seletion (e.g. \"layout\" defaults to current layout), and False\nif it does not (e.g. no default \"widget\").\n\nitems: a list of contained items\n</code></pre>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.select","title":"select","text":"<pre><code>select(selectors: list[SelectorType]) -&gt; CommandObject\n</code></pre> <p>Return a selected object</p> <p>Recursively finds an object specified by a list of <code>(name, selector)</code> items.</p> <p>Raises SelectError if the object does not exist.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.set_font","title":"set_font","text":"<pre><code>set_font(\n    font: Union[str, None] = None,\n    fontsize: int = 0,\n    fontshadow: ColorType = \"\",\n)\n</code></pre> <p>Change the font used by this widget. If font is None, the current font is used.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.timeout_add","title":"timeout_add","text":"<pre><code>timeout_add(seconds, method, method_args=())\n</code></pre> <p>This method calls <code>.call_later</code> with given arguments.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.timer_setup","title":"timer_setup","text":"<pre><code>timer_setup()\n</code></pre> <p>This is called exactly once, after the widget has been configured and timers are available to be set up.</p>"},{"location":"manual/ref/widgets/#libqtile.widget.Wttr.update","title":"update","text":"<pre><code>update(text)\n</code></pre> <p>Update the widget text.</p>"}]}